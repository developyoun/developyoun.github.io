---
title: 03.설계 원칙

categories:
- 클린아키텍처

tags:
- design-pattern
- study

toc: true
toc_sticky: true
toc_label: Contents
---

좋은 소프트웨어 시스템은 깔끔한 코드(Clean Code)로부터 시작한다.  

좋은 벽돌을 사용하더라도 빌딩의 아키텍처를 엉망으로 만들 수 있다. 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 바로 **SOLID** 원칙이다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 이 클래스를 서로 결합하는 방법을 설명해준다.  

이 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

> ‘중간수준’이란, 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.
즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.
> 

SOLID의 개략적인 설명은 아래와 같다.

- SRP (Single Responsibility Principle) 단일 책임 원칙
    - 각 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다.
- OCP (Open-Clodes Principle) 개방-폐쇄 원칙
    - 기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 시스템을 쉽게 변경할 수 있다.
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
    - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
    - 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
- DIP (Dependency Inversion Principle) 의존성 역전 원칙
    - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다.

---

## 7. SRP: 단일 책임 원칙

단일 책임 원칙은 최종적으로 아래와 같은 정의로 나타낼 수 있다.  

**하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 져야한다.**  

> 액터(actor)는, 해당 변경을 요청하는 한 명 이상의 사람들을 가리킨다.
> 

> SRP을 이해하는 가장 좋은 방법은 이 원칙을 위반하는 징후들을 살펴보는 것이다.
> 

### 7-1. 우발적 중복

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/e0e20d82-b7fa-4711-94d4-75473e19007c/Untitled.png)

Employee 클래스는 세 가지 메서드(calculatePay, reportHours, save)가 존재한다.   

이 클래스는 SRP를 위반한다. 세 가지 메서드가 서로 다른 세 명의 액터를 책임지기 때문이다.

- `calculatePay()` 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.
- `reportHours()` 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.
- `save()` 메서드는 데이터베이스 관리자가 기능을 정의하고 CTO 보고를 위해 사용한다.

개발자가 이 세 메서드를 Employee라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다.  

(이로 인해 CFO팀에서 결정한 조치가 COO팀에 영향을 줄 수 있다.)

이러한 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.  

SRP는 **서로 다른 액터가 의존하는 코드를 서로 분리**하라고 말한다.

### 7-2. 병합

소스파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하긴 어려운게 아니다.  

특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 더 높다.

두 명의 서로 다른 팀의 개발자가 `Employee` 클래스를 체크아웃받은 후 변경사항을 적용하면, 이들 변경사항의 병합은 충돌한다.  

이러한 병합은 모두를 곤경에 빠뜨릴 수 있다.

이러한 징후는 모두 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당된다.  

이 문제를 벗어나는 방법은 **서로 다른 액터를 뒷바침하는 코드를 서로 분리**하는 것이다.

### 해결책

해결책은 다양한데, 바로 그 모두가 메서드를 각기 다른 클래스로 이동시키는 방식이다.

아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다.

즉, 아무런 메서드가 없는 간단한 데이터 구조인 `EmployeeData`클래스를 만들어, 세 개의 클래스가 공유하도록 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/38694a1b-15c0-44f1-955e-56fb324670fd/Untitled.png)

각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함하며, 서로의 존재를 몰라야 한다. (= 우연한 중복을 피할 수 있다.)

하지만 이러한 해결책은, 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 단점이 있다.

그래서 이 난관을 빠져나올 때 흔히 쓰는 기법으로 **퍼사드(Facade) 패턴**이 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/6feeb560-9048-4af7-b69b-18953a522a51/Untitled.png)

`EmployeeFacade` 클래스에 코드는 거의 없고, 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다.

이런 경우라면 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하고, 덜 중요한 메서드들에 대한 퍼사드로 사용할 수도 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/b4b36769-233c-41f1-9269-3ffb1e655249/Untitled.png)

### 결론

**단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.** 

이보다 상위의 두 수준에서도 다른 형태로 등장한다.

- 컴포넌트 수준: 공통 폐쇄 원칙 (Common Closure Principle)
- 아키텍처 수준: 변경의 축 (Axis of Change)

---

## 8. OCP: 개방-폐쇄 원칙

개방 폐쇄 원칙의 정의는 아래와 같다.

**소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**

즉, 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 개체를 변경해서는 안된다.

소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다.

요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패를 마주한다.

OCP는 클래스와 모듈을 설계할 때 도움이 되는 원칙이라고 알고 있지만,

아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.

### 사고 실험

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/3b2f1975-fbfb-4476-b31d-cac6342afa97/Untitled.png)

모든 컴포넌트는 단방향으로 이루어지며, 화살표는 변경으로부터 보호하려는 컴포넌트를 행하도록 그려진다.

> 화살표가 A클래스에서 B클래스로 향한다면, A클래스에서는 B클래스를 호출하지만 B클래스에서는 A클래스를 전혀 호출하지 못한다.
A컴포넌트에서 발생한 변경으로부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야 한다.
> 
- `Presenter`에서 발생한 변경으로터 `Controller`를 보호한다.
- `View`에서 발생한 변경으로부터 `Presenter`보호한다.
- `Intercator`는 다른 모든 것에서 발생한 변경으로부터 보호한다.

보호의 계층구조가 ***수준(Level)*** 이라는 개념을 바탕으로 생성된다.

이것이 바로 아키텍처 수준에서 OCP가 동작하는 방식이다.

**아키텍트는 기능이 어떻게(How), 왜(Why), 언제(When) 발생한는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.**

컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/201e6ed6-5e9f-488f-a8ab-489554b72f93/Untitled.png)

### 방향성 제어

`FinancialDataGateway` 인터페이스는 `FinancialReportGenerator`와 `FinancialDataMapper`사이에 위치하는데, 이는 의존성을 역전시키기 위해서이다.

`FinancialDataGateway`인터페이스가 없었다면, 의존성이 `Interactor` 컴포넌트에서 `Database` 컴포넌트로 바로 항하게 된다.

### 정보은닉

`FinancialReportRequester` 인터페이스는 `FinancialReportController`가 `Interactor` 내부에 대해 너무 알지 못하게 막기 위해 존재한다.

만약, 이 인터페이스가 없었다면, `Controller`는 `FinancialEntities`에 대해 추이 종속성을 가지게 된다.

추이 종속성을 가지게 되면, 소프트웨어 엔티티는 “*자신이 직접 사용하지 않는 요소에는 절대 의존해서는 안 된다”* 는 소프트웨어 원칙을 위반하게 된다.

(이 원칙은 인터페이스 분리 원칙(ISP)와, 공통 재사용 원칙(CRP)에서 다시 설명)

> **추이 종속성**
A클래스가 B클래스에 의존하고, B클래스가 C클래스에 의존한다면 A클래스는 C클래스에 의존하게 된다.
> 

### 결론

- OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나이다.
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.
- 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호하는 의존형 계층구조가 만들어지도록 해야한다.

---

## 9. LSP: 리스코프 치환 원칙

상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.

### 상속을 사용하도록 가이드하기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/8fb9f463-ee1f-4879-819e-17257c05e645/Untitled.png)

`License`라는 클래스는 `calFee()`라는 메서드를 가지며, `Billing` 애플리케이션에서 이 메서드를 호출한다.

그리고, `License`에는 `personalLicense`와 `BusinessLicense`라는 두 가지 ‘하위 타입’이 존재하며 모두 `License` 타입으로 치환할 수 있다.

이 설계는 LSP를 준수하는데, 

`Billing` 애플리케이션의 행위가 `License` 하위타입 중 무엇을 사용하는지에 대해 의존하지 않는다.

그리고, 하위 타입은 모두 `License` 타입을 치환할 수 있다.

### 정사각형/직사각형 문제

> LSP를 위반하는 전형적인 문제로는 유명한 정사각형/직사각형(square/rectangle) 문제가 있다.
> 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/ab1ddf26-aad4-4e72-a258-762c7856b3d2/Untitled.png)

`Ractangle`의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, `Square`의 높이와 너비는 반드시 함께 변경된다.

이는 `Square`가 `Rectangle`의 하위타입으로는 적절하지 않음을 보여준다.

### LSP와 아키텍처

> 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.
> 

아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

### 결론

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.

치환 가능성을 조금이라도 위배하면 상당향의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

---

## 10. ISP: 인터페이스 분리 원칙

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/bba46c45-8e0f-494e-ad89-6d3379dbb4d6/Untitled.png)

User1은 오직 op1을, User2는 op2, User3는 Op3만을 사용한다.

OPS가 정적 타입 언어로 작성되었다고 하면, 

User1은 op2, op3를 사용하지 않음에도 두 메서드에 의존하게 되며, 두 메서드가 변경되면 User1도 다시 컴파일 후 배포해야한다.

이러한 문제는, 인터페이스 단위로의 분리로 해결할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/a6c570a3-8f40-4807-8189-b9782354fe7a/Untitled.png)

User1의 소스 코드는 U1Ops와 op1에는 의존하지만, OPS에는 의존하지 않게 된다.

즉, OPS에서 발생한 변경이 User1과는 관계없는 변경이라면, User1을 다시 컴파일하고 새로 배포하는 상황은 초래되지 않는다.

### ISP와 언어

**정적 타입 언어**는 사용자가 타입 선언문을 사용하도록 강제한다. 

소스 코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.

**동적 타입 언어**에서는 소스 코드에 이러한 선언문이 존재하지 않고 런타임에 추론이 발생한다.

동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유이다.

이러한 사실로 인해, **ISP를 아키텍처가 아니라 언어와 관련된 문제라고 결론 내릴 여지가 있다.**

### ISP와 아키텍처

일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.

소스 코드 의존성의 경우 이는 불필요한 재컴파일과 재배포를 강제하기 때문이다.

하지만 더 고수준인 아키텍처에서도 마찬가지 상황이 발생한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/174df69f-a8b6-4f72-bb95-076a4f478d75/Untitled.png)

S는 F에 의존하며, F는 다시 D에 의존한다.

이때 D 내부가 변경되면, F를 재배포 해야할수도 있고 S까지 재배포해야 할지 모른다. (문제가 있는 상황도 마찬가지)

---

## 11. DIP: 의존성 역전 원칙

DIP에서 말하는 ‘*유연성이 극대화된 시스템*’이란 소스 코드 의존성이 **추상**(abstraction)에 의존하며 **구체**(concretion)에는 의존하지 않는 시스템이다.

이 원칙을 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.

이들 환경에 대한 의존성은 용납하는데, 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고 있기 때문이다.

**우리가 의존하지 않고 피하고자 하는 것은 변동성이 큰(volatile) 구체적인 요소이다.**

### 안정된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 수정해야 한다.

반대로 구체적인 구현체에 대한 변경이 생기더라도 구현한 인터페이스는 대부분의 경우 변경할 필요가 없다.

즉, **인터페이스는 구현체보다 변동성이 낮다.**

> 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.
실제로 뛰어난 소프트웨어 설계자가 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다.
> 

- 변동성이 큰 구체 클래스를 참조하지 말라.
    - 대신 추상 클래스를 참조하라.
    - 정적타입이든 동적타입이든 관계없이 모두 적용된다.
    - 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반저긍로 추상 팩토리(Abstract Factory)를 사용하도록 강제한다.
- 변동성이 큰 구체 클래스로부터 파생하지 말라.
    - 정적 타입 언어에서 상속은 변경하기 어렵다. 따라서 신중하게 사용해야 한다.
    - 동적 타입 언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함없다.
- 구체 함수를 오버라이드 하지 말라.
    - 대체로 구체 함수는 소스 코드 의존성을 필요로 하므로, 오버라이드하면 이러한 의존성을 제거할 수 없게 되며 의존성을 상속하게 된다.
    - 이러한 의존성을 제거하려면, 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
    - DIP 원칙의 실천법이다.

### 팩토리

자바 등 대다수의 객체 지향 언어에서 바람하지 못한 의존성을 처리할 때 **추상 팩토리**를 사용하곤 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b79aff2d-2bdd-4efc-b7a3-a292945f904f/4ed482b9-62f3-42c5-9f6c-69d7bc4bd276/Untitled.png)

곡선은 아키텍처 경계를 뜻하며, 구체적인 것들로부터 추상적인 것들을 분리한다.

하나는 애플리케이션의 모든 고수준 업무 규칙을 포함한 **추상 컴포넌트**이며, 다른 하나는 업무 규칙을 다루기 위해 필요한 세부사항을 포함한 **구체 컴포넌트**이다.

제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점을 주목하자. 

즉, 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.

이 원칙을 **의존성 역전(Dependency Inversion)**이라고 부른다.

### 구체 컴포넌트

DIP 위배를 모두 없앨 수는 없다. 하지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 시스템의 나머지 부분과는 분리할 수 있다.

> ServiceFactoryImpl 구체 클래스가 ConcreteImpl 구체 클래스에 의존한다.
