---
title: 02.벽돌부터 시작하기, 프로그래밍 패러다임

categories:
- 클린아키텍처

tags:
- design-pattern
- study

toc: true
toc_sticky: true
toc_label: Contents
---

## 3. 패러다임의 개요

- 구조적 프로그래밍
    - 최초로 적용된 패러다임
    - 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍
    - 제어흐름의 간적적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍
    - 가장 먼저 만들어진 패러다임
    - 할당문에 대해 규칙을 부과한다.

패터다임은 무엇을 해야 할지를 말하기보다는 *무엇을 해서는 안 되는지를 말해준다.*

---

## 4. 구조적 프로그래밍

초기 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 못한다는 문제가 있었다.

당시 모든 프로그램은 단순할지라도 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담았다.

**아주 작은 세부사항이라도 간과하면 프로그램이라도 결국엔 예상 외의 방식으로 실패하곤 했다.**

데이크스트라는 증명(proof)이라는 수학적 원리를 적용해 문제를 해결하려 했다.

이는, *프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이었다.*

뵘과 야코피니는 모든 프로그램을 *순차* (sequence), *분기* (selection), *반복* (interation)이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.

즉, 모듈을 증명 가능하게 하는 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실을 의미한다.

→ 구조적 프로그래밍의 탄생

- **순차 구문 (sequential statement)**
    - 단순한 열거법을 이용해 입증할 수 있다는 사실을 보여줌
    - 각 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적한다.
    - 이 접근법은 일반적인 수학적 증명 방식과 다를 바 없다.
- **분기 (selection)**
    - 열거법을 재적용하는 방식으로 처리
    - 분기를 통한 각 경로를 열거하고, 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.
- **반복 (iteration)**
    - 반복이 올바름을 증명하기 위해 귀납법을 사용
    - 열거법에 따라 1의 경우가 올바름을 증명, N의 경우가 올바르다고 가정할 때 N+1의 경우도 올바름을 증명한다.
    - 반복의 시작 조건과 종료 조건도 열거법을 통해 증명

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있었다.

이는 모듈을 기능적으로 분해할 수 있음을 뜻했다.

즉, **거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.**

> 이를 토대로 구조적 분석(structured analysis)이나 구조적 설계(structured design)와 같은 기법이 1970년대 후반에서 1980년대에 걸쳐 인기를 끌었다.
> 

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.

그리고 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.

### 결론

**구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.**

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 반증 가능성에 의해 주도된다.
(= 소트프웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 노력해야한다)

---

## **5. 객체 지향 프로그래밍**

좋은 아키텍처를 만드는 일은 객체 지향(Object-Oriented) 설계 원칙을 이해하고 응용하는 데서 출발한다.
객체 지향의 본질을 설명하기 위해 *캡슐화* (encapsulation), *상속* (inheritance), *다형성* (polymorphism) 에 기대기도 한다.

> 이 세 가지 개념을 적절하게 조합하거나, 세 가지 요소를 지원해야 한다고 한다
> 

### **캡슐화**

캡슐화를 언급하는 이유는, 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 객체 지향 언어가 제공하기 때문이다.
이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓도록 할 수 있다.

> 구분선 밖에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.
> 

캡슐화의 개념이 객체 지향언어에 국한된 것은 아니다.

`point.h`

```c
struct Point;
struct Point* makePoint (double x, double y);
double distance (struct Point *p1, struct Point *p2);
```

`point.c`

```c
#include "point.h"
#include <stdlib.h>
#include <math.h>

struct Point {
    double x, y;
}

struct Point* makepoint (double x, double y) {
    struct Point* p = malloc(sizeof(struct Point);
    p -> x = x;
    p -> y = y;
    return p;
}

double distance(struct Point* p1, struct Point* p2) {
    double dx = p1 -> x - p2 -> x;
    double dy = p1 -> y - p2 -> y;
    return sqrt (dx*dx + dy*dy);
}
```

여기서 `point.h`를 사용하는 측에서 struct Point의 멤버에 접근할 방법이 전혀 없다.
사용자는 `makePoint()` 함수와 distance() 함수를 호출할 수는 있지만, Point 구조체의 데이터 구조와 함수가 어떻게 구현되었는지 조금도 알지 못한다.
이것이 완벽한 캡슐화이며, 객체 지향이 아닌 언어에서도 충분히 캡슐화가 가능하다.

이후에 C++라는 형태로 객체 지향이 등장했지만, C가 제공하던 완전한 캡슐화가 깨지게 되었다.  
언어에 public, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 사실상 어느 정도 보완하기는했지만, 컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 했기 때문에 조치한 임시방편이다.

자바와 C#은 헤더와 구현체를 분리하는 방식을 모두 버렸고, 캡슐화는 더욱 심하게 훼손되었다.  
(이런 언어에서는 클래스 선언과 정의를 구분하는게 아예 불가능하다.)  
이 때문에 객체 지향이 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들고, 실제도로 많은 객체 지향 언어가 캡슐화를 거의 강제하진 않는다.

### **상속**

> 객체 지향 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 확실히 제공했다.
> 

상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.  
(사실상 객체 지향 언어가 있기 훨씬 이전에도 C 프로그래머는 언어의 도움 없이 손수 이러한 방식으로 구현할 수 있었다.)

`namedPoint.h`

```c
struct NamedProint;

struct NamedPoint* makeNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);
```

`namedPoint.c`

```c
#include "namedPoint.h"
#include <stdlib.h>

struct NamedPoint {
    double x,y;
    char* name;
};

struct NamedPoint* makeNamedPoint(double x, double y, char* name) {
    struct NamedPoint* p = malloc(sizeof(struct NamedPoint));
    p->x = x;
    p->y = y;
    p->name = name;
    return p;
}

void setName(struct NamedPoint* np, char* name) {
    np->name = name;
}

char* getName(struct NamedPoint* np) {
    return np->name;
}
```

`main.c`

```c
#inlcude "point.h"
#include "namedPoint.h"
#include <stdio.h>

int main(int ac, char** av) {
    struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");
    struct NamedPoint* upperRight = makeNamedPoint(1.0, 1.0, "upperRight");
    printf("distance=%f\n", distance((struct Point*) origin, (struct Point*) upperRight));
}
```

`main` 프로그램을 잘 보면, **`NamedPoint`데이터 구조가 마치 `Point` 데이터 구조로부터 파생된 구조인 것처럼 동작한다는 사실을 볼 수 있다.**
즉, `NamedPoint`는 `Point`의 가면을 쓴 것처럼 동작할 수 있는데, `NamedPoint`가 `Point`를 포함하는 상위 집합으로 대응하는 멤버 변수의 순서가 유지되기 때문이다.

> 눈속임처럼 보이는 이 방식은 객체 지향이 출현하기 이전부터 프로그래머가 흔히 사용하던 기법이다. (실제로 C++에서는 이 방법으로 단일 상속을 구현했다.)
상속을 흉내내는 요령은 있었지만, 사실상 상속만큼 편리한 방식은 절대 아니고 이 기법으로 다중 상속을 구현하기란 훨씬 더 어려운 일이었다.
> 

또한, `main.c`에서 `NamedPoint` 인자를 `Point`로 타입을 강제 변환한 점도 확인할 수 있는데, 진짜 객체 지향 언어에서는 이런한 업캐스팅(Upcasting)이 암묵적으로 이뤄진다.

**객체 지향 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수는 있다.**

### **다형성**

> 객체 지향 언어가 있기 이전에도 다형성을 표현할 수 있는 언어는 있었다
> 

```c
# include <stdio.h>

void copy() {
    int c;
    while ((c=getchar()) != EOF)
        putchar(c);
}
```

`getchar()` 함수는 STDIN에서 문자를 읽고, `putchar()` 함수는 STDOUT으로 문자를 쓴다.
이러한 함수는 **다형적(polymorphic)**이다. 즉 행위가 STDIN과 STDOUT 타입에 의존한다.

STDIN과 STDOUT은 사실상 자바 형식의 인터페이스로, 자바에서는 각 장치별로 구현체가 있다. 하지만 C 프로그램에는 이러한 인터페이스는 없다.

`getchar()` 함수를 호출할 때 어떤 방식으로 문자를 읽는 장치 드라이버를 호출할 수 있는가? 
유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek) 다섯 가지 표준 함수를 제공한다.

```c
struct FILE {
    void (*open)(char* name, int mode);
    void (*close)();
    int (*read)();
    void (*wirte)(char);
    void (*seek)(long index, int mode);
}
```

```c
#include "file.h"

void open(char* name, int mode) {/*...*/};
void close() {/*...*/};
int read() {int c; /*...*/ return c};
void wirte(char) {/*...*/};
void seek(long index, int mode) {/*...*/};
```

```c
extern struct FILE* STDIN;

int getchar() {
    return STDIN->read();
}
```

객체 지향 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 해준다.

### **다형성이 가진 힘**

앞의 복사 프로그램을 예제로 들어본다.
새로운 입출력 장치가 생긴다면 복사 프로그램의 소스 코드는 입출력 드라이버에 의존하지 않기 때문에 아무런 변경도 필요하지 않는다.
입출력 드라이버가 FILE에 정의된 다섯 가지 표준 함수를 구현한다면, 복사 프로그램에서는 이 입출력 드라이버를 얼마든지 사용할 수 있다.

장치에 의존적인 수많은 프로그램을 만들고 나서야, 이들 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만들어야 겠다는 점을 깨닫고, 1950년대 후반부터 장치 독립적(device independent)이어야 한다는 점을 알았다.

### **의존성 역전**

전형적인 호출 트리의 경우 `main` 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수준 함수를 호출한다.이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름(flow of controll)을 따르게 된다.

`main` 함수가 고수준 함수를 호출하려면 고수준 함수가 포함된 모듈의 이름을 지정해야만 한다. (c에서는 #include,자바에서는 import, c#에서는 using 구문)  
실제로 모든 호출 함수는 피호출 함수가 포함된 모듈의 이름을 명시적으로 지정해야 한다.  
즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.

하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다.

HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다.
이 인터페이스는 런라임에는 존재하지 않고, HL1은 단순히 ML1 모듈의 함수 F()를 호출할 뿐이다.

---

## 06. 함수형 프로그래밍

> 함수형 프로그래밍의 핵심은 람다(lambda) 계산법으로, 알론조 처치가 1930년대 발명했다.
> 

함수형 언어에서 변수는 **변경되지 않는다.**

### 불변성과 아키텍처

아키텍트는 변수의 가변성을 염려한다.  

경합 조건(Race Condition), 교착상태조건(Deadlock), 동시 업데이트(Concurrent Update) 문제가 모두 가변 변수로 인해 발생하기 때문이다.  

만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않으며, 락(lock)이 가변적이지 않다면 교착상태도 일어나지 않는다.  

아키텍트라면 동시성(Concurrency) 문제에 관심을 가져야 한다.

### 가변성의 분리

불변성과 관련하여 가장 중요한 타엽 중 하나는 애플리케이션 혹은 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.  

불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.  

애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다는 것이다.  

그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 한다.

**현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.**

### 이벤트 소싱

이벤트 소싱은(Event Sourcing)은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지만 단순히 상태의 시작점으로부터 모든 트랜잭션을 처리한다.  

저장공간과 처리능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 완전한 함수형으로 만들수 있다.

### 결론

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
