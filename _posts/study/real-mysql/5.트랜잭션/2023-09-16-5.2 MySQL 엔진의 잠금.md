---
title: 5.2 MySQL 엔진의 잠금

categories:
- real-mysql

tags:
- database
- study

toc: true
toc_sticky: true
toc_label: Contents
---

> MySQL에서 사용되는 잠금은 크게 2가지로 나눌 수 있다.\
>
>
> * 스토리지 엔진 레벨 잠금 → 스토리지 엔진 간 상호 영향을 미치지는 않는다.&#x20;
> * MySQL 엔진 레벨 잠금 → 모든 스토리지 엔진에 영향을 미친다.

### 5.2.1 글로벌 락 (GLOBAL LOCK)

* 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다
* MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
* 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나, DML 문장을 실행하는 경우, 글로벌 락이 해제될 때까지 대기 상태로 남는다.
* 글록벌 락이 영향을 미치는 범위는 MySQL 서버 전체이다.
* 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

> 글로벌 락을 거는 `FLUSH WITH READ LOCK` 명령은 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 건다.\
> 그래서, 테이블에 읽기 잠금을 걸기 전에 먼저 테이블을 플러시해야 하기 때문에 실행 중인 모든 종류의 쿼리가 완료돼야 한다.

\
`FLUSH TABLES WITH READ LOCK` 명령을 이용한 글로벌 락은 MySQL 서버의 모든 변경 작업을 멈춘다.→ 하지만, InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요 없다.\
MySQL 8.0 버전부터는 Xtrabackup 이나 Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입되었다.

```
LOCK INSTANCE FOR BACKUP;  --백업 실행
UNLOCK INSTANCE;
```

→ 특정 세션에서 백업 락을 획득하면 모든 세션에서 아래와 같은 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.

* 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
* `REPAIR TABLE` 과 `OPTIMIZE TABLE`  명령
* 사용자 관리 및 비밀번호 변경

→ 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.\
→ MySQL 서버의 구성은 소스 서버와 레플리카 서버로 구성되는데, 주로 백업은 레플리카 서버에서 실행된다.\
\


### 5.2.2 테이블 락 (TABLE LOCK)

테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.

#### 명시적 테이블 락

* `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 특정 테이블 락을 획득할 수 있다.
* MyISAM뿐만 아니라, InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다.
* `UNLOCK TABLES` 명령으로 잠금을 반납할 수 있다.
* 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니면 어플리케이션에서 사용할 필요가 거의 없다.

#### 묵시적 테이블 락

* MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
* MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 점금을 해제하는 형태로 사용
	* 즉, 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료된 후 자동 해제된다.
* InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다.
	* InnoDB 테이블에도 테이블 락이 설정되긴 하지만, 대부분의 데이터 변경(DML) 쿼리에서는 무시되고, 스키마를 변경하는 쿼리(DDL)의 경우만 영향을 준다.

### 5.2.3 네임드 락 (NAMED LOCK)

네임드 락은 `GET_LOCK()`  함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.

* 대상이 테이블이나 레코드, `AUTO_INCREMENT` 와 같은 데이터베이스 객체가 아니라, 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.
* 자주 사용되지않는 잠금이다.
* 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
* 배치 프로그램처럼 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되는데, 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드락을 걸어 쿼리를 실행하면 간단히 해결할 수 있다.
* MySQL 8.0 버전부터는 네임드 락을 중첩해서 사용할 수 있게 되어, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 있다.

```
SELECT GET_LOCK('mylock_1', 10);  // mylock_1에 대한 작업 실행
SELECT GET_LOCK('mylock_2', 10);  // mylock_2에 대한 작업 실행

SELECT RELEASE_LOCK('mylock_2');
SELECT RELEASE_LOCK('mylock_1');

SELECT RELEASE_ALL_LOCKS();  // mylock_1, mylock_2를 동시에 모두 해제한다.

```

### 5.2.4 메타데이터 락 (METADATA\_LOCK)

메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.

* 명시적으로 획득하거나 해제할 수 있는 것이 아니다.
* `RENAME TABLE tab_a TO tab_b` 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
* `RENAME TABLE` 명령의 경우 원본 이름과 변경될 이름 모두 한번에 잠금을 설정한다.

```
## 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성
// 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업
// 새로 만들어진 랭킹(rank_new)을 서비스용으로 대체
RENAME TABLE rank TO rank_backup, rank_new TO rank;
```

위의 예제처럼, 하나의 `RENAME TABLE` 명령문에 두 개의 `RENAME` 작업을 한꺼번에 실행하면 실제 어플리케이션에서 “Table not found ‘rank’\`와 같은 상황을 발생시키지 않는다.

```
RENAME TABLE TO rank_backup;
RENAME TABLE rank_new TO rank;
```

위의 예제는, 짧은 시간에 rank 테이블이 존재하지 않는 상황이 생겨 순간적으로 실행되는 쿼리는 “Table not found ‘rank’” 오류를 발생시킨다.\
메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 있다.그 예로 테이블의 구조를 변경해야 하는 경우, 오래 걸리면서 생기는 언두 로그 증가와 Online DDL 버퍼 증가, DDL의 단일 스레드 작동으로 인한 장기간 작업등이 문제 될 수 있다.

1. 새로운 구조의 테이블을 생성하고 먼저 최근의 데이터까지는 프라이머리 키인 `id` 값을 범위별로 나눠서 여러 개의 스레드로 빠르게 복사.
2. 나머지 데이터는 트랜잭션과 테이블 잠금, `RENAME TABLE` 명령으로 응용 프로그램의 중단없이 실행.
3. 남은 데이터를 복사하는 시간 동안은 테이블 잠금으로 INSERT 할 수 없으므로, 미리 아주 최근 데이터까지 복사해 둬야 잠금 시간을 최소화한다.