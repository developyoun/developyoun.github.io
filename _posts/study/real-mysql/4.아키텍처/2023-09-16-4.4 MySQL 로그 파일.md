---
title: 4.4 MySQL 로그 파일

categories:
- real-mysql

tags:
- database
- study

toc: true
toc_sticky: true
toc_label: Contents
---

로그 파일을 이용하면 MySQL 서버의 깊은 내부 지식이 없어도 MySQL의 상태나 부하를 일으키는 원을 쉽게 찾아서 해결할 수 있다.

## 4.4.1 에러로그 파일

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다.

→ 에러 로그 파일의 위치는 MySQL 설정 파일(my.cnf)에서 `log_error` 라는 파라미터로 정의된 경로에 생성된다.

→ MySQL 설정 파일에 별도로 정의되지 않은 경우에는 데이터 디렉토리(datadir 파라미터에 설정된 디렉토리)에 .err라는 확장자가 붙은 파일로 생성된다.

### 4.4.1.1 MySQL이 시작되는 과정과 관련된 정보성 및 에러 메시지

MySQL의 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 이후 다시 시작하는 경우에는, 반드시 MySQL 에러 로그 파일을 통해 설정된 변수의 이름이나 값이 명확하게 설정되고 의도한 대로 적용됐는지 확인해야 한다.

→ MySQL 서버가 정상적으로 기동했고, 새로 변경하거나 추가한 파라미터에 대한 특별한 에러나 경고성 메시지가 없다면 정상적으로 판단하면 된다.

→ 정상적으로 기동하면 `mysqld: ready for connections`과 같은 메시지가 나온다.

### 4.4.1.2 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지

InnoDB의 경우에는 MySQL 서버가 비정상적 또는 강제적으로 종료됐다면 다시 시작되면서 완료되지 못한 트랜잭션을 정리하고, 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 하게 된다.

→ 간혹, 문제가 있어서 복구되지 못할 때는 해당 에러 메시지를 출력하고 MySQL은 다시 종료된다.

→ 일반적으로 이 단계에서 발생하는 문제는 상대적으로 해결하기 어려운 문제일 경우가 많다.

→ 때로는, `innodb_force_recovery` 파라미터를 0보다 큰 값으로 설정하고 재시작해야만 MySQL이 시작될 수도 있다.

### 4.4.1.3 쿼리 처리 도중에 문제가 발생하는 문제에 대한 에러 메시지

쿼리 도중 발생하는 문제점은 사전 예방이 어려우며, 주기적으로 에러 로그 파일을 검토하는 과정에서 알게 된다..

쿼리의 실행 도중 발생한 에러나 복제에서 문제가 될 만한 쿼리에 대한 경고 메시지가 에러 로그에 기록된다.

### 4.4.1.4 비정상적으로 종료된 커넥션 메시지(Aborted connection)

클라이언트 어플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 MySQL 서버의 에러 로그 파일에 이런 내용이 기록된다.

→ `max_connect_errors` 시스템 변숫값이 너무 낮게 설정된 경우 클라이언트 프로그램이 MySQL 서버에 접속하지 못하고 “Host {host\_name} is blocked”라는 에러가 발생할 수도 있다.

→ 이 메시지는 클라이언트 호스트에서 발생한 에러(커넥션 실패나 강제 연결 종료와 같은)의 횟수가 `max_connect_errors` 변수의 값을 넘게 되는 발생한다.

### 4.4.1.5 InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS 같은)의 결과 메시지

InnoDB의 테이블 모니터링이나 락 모니터링, 또는 InnoDB의 엔진 상태를 조회하는 명령은 상대적으로 큰 메시지를 에러 로그 파일에 기록한다.

InnoDB의 모니터링을 활성화 상태로 만들어 두고 그대로 유지하는 경우에는 에러 로그 파일이 매우 커져서 파일 시스템의 공간을 다 사용해 버릴지도 모른다.

→ 모니터링을 사용한 이후에는 다시 비활성화해서 에러 로그 파일이 커지지 않게 만들어야 한다.

### 4.4.1.6 MySQL의 종료 메시지

가끔 MySQL이 아무도 모르게 종료돼 있거나 때로는 아무도 모르게 재시작되는 경우를 본 적이 있다면 에러 로그 파일에서 MySQL이 마지막으로 종료되면서 출력한 메시지를 확인하는 것이 왜 MySQL 서버가 종료됐는지 확인하는 유일한 방법이다.

→ 만약 누군가가 MySQL 서버를 종료시켰다면 에러 로그 파일에서 ‘ㄲReceived SHUTDOWN from user ...’ 이라는 메시지를 확인할 수 있을 것이다.

→ 그렇지 않고 아무런 종료 관련 메시지가 없거나 스택 트레이스와 같은 내용이 출력되는 경우에는 MySQL 서버가 세그먼테이션 폴트로 비정상적으로 종료된 것으로 판단할 수 있다.

> 세그먼테이션 폴트로 종료된 경우에는 스택 트레이스의 내용을 최대한 잠조해서 MySQL의 버그와 연관이 있는지 조사한 후 MySQL의 버전을 업그레이드하거나 회피책을 찾는 것이 최적의 방법이다.

> **세그멘테이션 폴트?**\*\* 세그멘테이션 오류\*\* 또는 **세그멘테이션 결함**(Segmentation Fault)은 컴퓨터 소프트웨어의 실행 중에 일어날 수 있는 특수한 오류이다. **세그멘테이션 위반**, **세그멘테이션 실패**라고도 하며, **세그폴트**(Segfault)로 줄여서 쓰기도 한다. 세그멘테이션 오류는 프로그램이 허용되지 않은 메모리 영역에 접근을 시도하거나, 허용되지 않은 방법으로 메모리 영역에 접근을 시도할 경우 발생한다.

## 4.4.2 제너럴 쿼리 로그 파일 (제너럴 로그 파일, General log)

쿼리 로그 파일에는 시간 단위로 실행됐던 쿼리의 내용이 모두 기록된다. 제너럴 쿼리 로그는 실행되기 전에 MySQL이 쿼리 요청을 받으면 바로 기록하기 때문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다.

쿼리 로그 파일의 경로는 `general_log_file` 이름의 파라미터에 설정되어 있다.

→ 쿼리 로그를 파일이 아닌 테이블에 저장하도록 설정할수도 있기 때문에, 이 경우에는 파일이 아닌 테이블을 SQL로 조회해서 검토해야 한다.

```
SHOW GLOBAL LIKE 'general_log_file`;
```

쿼리 로그를 파일로 저장할 지, 테이블로 저장할지는 `log_output` 파라미터로 결정된다.

## 4.4.3 슬로우 쿼리 로그

서비스 운영중에 MySQL 서버의 저체적인 성능 저하를 검사하거나 정기적인 점섬을 위한 튜닝은, 어떤 쿼리가 문제의 쿼리인지 판단하기가 상당히 어렵기 때문에 슬로우 쿼리 로그가 상당히 많은 도움이 된다.

* 슬로우 쿼리 로그 파일에는 `long_qeury_time` 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다.
* 슬로우 쿼리 로그는 MySQL이 쿼리를 실행한 후, 실제 소요된 시간을 기준으로 슬로우 쿼리 로그에 기록할지 여부를 판단하기에, 반드시 쿼리가 성장적으로 실행이 완료되어야 기록될 수 있다.

`log_output` 옵션을 이용해 슬로우 쿼리 로그를 파일로 기록할지 테이블로 기록할지 선택할 수 있다.

* `log_output` 옵션을 `TABLE` 로 설정하면 제너럴 로그나 슬로우 쿼리 로그를 mysql DB의 테이블(general\_log, slow\_log)에 저장한다.
* `log_output` 옵션을 `FILE` 로 설정하면 로그의 내용을 디스크 파일로 저장한다.
* `log_output` 옵션을 `TABLE`로 설정하더라도 mysql DB의 slow\_log테이블과 general\_log 테이블은 CSV 스토리지 엔진을 사용하기 때문에 결국 CSV 파일로 저장하는 것과 동일하게 작동한다.

MySQL의 잠금 처리는 MySQL 엔진 레벨과 스토리지 엔진 레벨의 두 가지 레이어로 처리된다.

* MyISAM, MEMORY 스토리지 엔진과 같은 경우에는 별도의 스토리지 엔진 레벨의 잠금을 가지지 않는다.
* InnoDB의 경우 MySQL 엔진 레벨의 잠금과 스토리지 엔진 자체 잠금을 가지고 있다.

```
# Time: 2020-07-19T15:44:22.178487+09:00
# User@Host: root[root] @ localhost [] Id:  14
# Query_time: 1.180245  Lock_time: 0.002658 Rows_sent:  1  Rows_examined:2844047
use employes;
SET timestamp=1695141060;
select emp_no, max(salary) from salaries;
```

위의 슬로우 쿼리 로그를 살펴보자.

* `Time`
    * 쿼리가 시작된 시간이 아닌, 쿼리가 종료된 시점을 의미한다.
    * 쿼리가 언제 시작됐는지 확인하려면 ‘Time’ - ‘Query\_time\` 을 구하면 된다.
* `User@Host`
    * 쿼리를 실행한 사용자 계정이다
* `Query_time`
    * 쿼리가 실행되는 데 걸린 전체 시간을 의민한다.
* `Lock_time`
    * 두 가지 레벨의 잠금 가운데 MySQL 엔진 레벨에서 관장하는 테이블 잠금에 대한 대기 시간만 표현한다.
    * 예제 같은 경우, SELECT 문장을 실행하기 위해 0.002658초간 테이블 락을 기다렸다는 의미가 된다.
    * ‘Lock\_time’에 표기된 시간은 실제 쿼리가 실행되는 데 필요한 잠금 체크와 같은 코드 실행 부분의 시간까지 모두 포함되므로 0이 아니라고해서 무조건 잠금이 있었다고 하기 어렵다.
    * 이 값이 매우 작은 값이면 무시해도 무방하다.
* `Rows_examined`
    * 쿼리가 처리되기 위해 몇 건의 레코드에 접근했는지를 의미한다.
* `Rows_send`
    * 실제 몇 건의 처리 결과를 클라이언트로 보냈는지를 의미한다.
    * 만약 `Rows_examined` 의 레코드 건수는 높지만 `Rows_send` 에 표시된 레코드 건수가 상당히 적다면 튜닝해볼 가치가 있다.
        * GROUP BY, COUNT(), MIN(), MAX(), AVG() 등과 같은 집합 함수가 아닌 쿼리인 경우에 해당한다.

일반적으로 슬로우 쿼리 또는 제너럴 로그 파일의 내용이 상당히 많아서 직접 쿼리를 하나씩 검토하기에 시간이 너무 많이 걸리거나 어느 쿼리를 집중저그올 튜닝해야 할지 식별하기 어려울 수 있다.

이럴경우에는 Percona에서 개발한 **Percona Toolkit**의 **pt-query-digest** 스크립트를 이용하면 쉽게 빈도나 처리 성능별로 쿼리를 정렬해서 볼 수 있다.

```
## Gernal Log 파일 분석
pt-query-digest --type='genlog' general.log > parsed_general.log

## Slow Log 파일 분석
pt-query-digest --type='slowlog' mysql-slow.log > parsed_mysql-slog.log
```

### 4.4.3.1 슬로우 쿼리 통계

분석 결과의 최상단에 표시되며, 모든 쿼리를 대상으로 슬로우 쿼리 로그의 실행 시간, 잠금 대기 시간 등에 대해 평균 및 최소/최대 값을 표시한다.

### 4.4.3.2 실행 빈도 및 누적 실행 시간순 랭킹

각 쿼리별로 응답 시간과 실행 횟수를 보여주는데, pt-query-digest 명령 실행 시 --order-by 옵션으로 정렬 순서를 변경할 수 있다.

Query ID는 실행된 쿼리 문장을 정규화(쿼리에 사용된 리터럴을 제거)해서 만들어진 해시 값을 의미하는데, 일반적으로 같은 모양의 쿼리라면 동일한 Query ID를 갖게 된다.

### 4.4.3.3 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보

Query ID별 쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여준다.

랭킹별 쿼리에는 대상 테이블에 대해 어떤 쿼리인지만을 표시하는데, 실제 상세한 쿼리 내용은 개별 쿼리의 정보를 확인해보면 된다.