---
title: 10.1 통계 정보

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

> MySQL 5.7 버전까지는 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다.
> → 이는 테이블 컬럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다.
> MySQL 8.0 버전부터는 인덱스되지 않은 컬럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입되었다.

## 10.1.1 테이블 및 인덱스 통계 정보
### 10.1.1.1 MySQL 서버의 통계 정보
```ad-note
MySQL 5.5 버전까지는 각 테이블의 통계 정보가 메모리에만 관리되었기에, MySQL 서버가 재시작되면 수집된 모든 통계 정보가 사라진다.
```

MySQL 5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선되었다.
→ 각 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_status` 테이블과 `innodb_table_status` 테이블로 관리할 수 있게 개선되었다.
→ 통계 정보를 테이블로 관리함으로써 MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 됐다.

MySQL 5.6에서 테이블을 생성할 때는 `STATS_PERSISTENT` 옵션을 설정할 수 있는데, 설정값에 따라 테이블 단위로 영구적인 통계 정보를 보관할지 말지를 결정할 수 있다.
- `STATS_PERSISTENT=0`
	- 테이블을 통계 정보를 MySQL 5.5 이전의 방식대로 관리하며, mysql 데이터베이스의 `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장하지 않음
- `STATS_PERSISTENT=1`
	- 테이블의 통계 정보를 mysql 데이터베이스의 `innodb_index_stats`와 `innodb_table_stats` 테이블에 저장함
- `STATS_PERSISTENT=2`
	- 테이블을 생성할 때 별도로 STATS_PERSISTENT 옵션을 설정하지 않은 것과 동일하며, 테이블의 통계를 영구적으로 관리할지 말지를 innodb_stats_persistent 시스템 변수의 값으로 결정한다.

> innodb_stats_persistent 시스템 설정 변수를 기본적으로 ON으로 설정돼 있으며, STATS_PERSISTENT 옵션 없이 테이블을 생성하면 영구적인 통계 정보를 사용한다.

통계 정보의 각 컬럼은 다음과 같은 값을 저장하고 있다.
- innodb_index_stats.stat_name=‘n_diff_pfx%’: 인덱스가 가진 유니크한 값의 개수
- innodb_index_stats.stat_name=‘n_leaf_pages’: 인덱스의 리프 노드 페이지의 개수
- innodb_index_stats.stat_name=‘size’: 인덱스 트리의 전체 페이지 개수
- innodb_index_stats.n_rows: 테이블의 전체 레코드 건수
- innodb_index_stats.clustered_index_size: 프라이머리 키의 크기 (InnoDB 페이지 개수)
- innodb_index_stats.sum_of_other_index_sizes: 프라이머리 키를 제외한 인덱스의 크기 (InnoDB 페이지 개수)

`innodb_stats_auto_recalc` 시스템 설정 변수를 OFF로 설정하면 통계 정보가 자동으로 갱신되는 것을 막을 수 있다.
→ 기본값은 ON이므로, 영구적인 통계 정보를 이용하고자 한다면 OFF로 설정하자.
→ 통계 정보를 자동으로 수집할지 여부도 테이블을 생성할 때 `STATS_AUTO_RECALC` 옵션을 이용해 테이블 단위를 조정할 수 있다.
- STATS_AUTO_RECALC=1: 테이블의 통계 정보를 MySQL 5.5 이전의 방식대로 자동 수집한다.
- STATS_AUTO_RECALC=0: 테이블의 통계 정보는 ANALYZE TABLE 명령을 실행할 때만 수집된다.
- STATS_AUTO_RECLAC=DEFAULT: 테이블을 생성할 때 변도로 STATS_AUTO_RECALC 옵션을 설정하지 않은 것과 동일하며, 테이블의 통계 정보 수집을 `innodb_stats_auto_recalc` 시스템 변수의 값으로 결정한다.

MySQL 5.5 버전에서는 테이블의 통계 정보를 수집할 때 몇 개의 InnoDB 테이블 블록을 샘플링할지 결정하는 옵션으로 `innodb_stats_sample_pages` 시스템 설정 변수가 제공된다.
MySQL 5.6 버전부터는 `innodb_stats_transient_sample_pages` 와 `innodb_stats_persistent_sample_pages` 시스템 변수 2개로 제공된다.
- innodb_stats_transient_sample_pages: 기본값은 8이며, 자동으로 통계 정보 수집이 실행될 때 8개의 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계정보로 활용한다.
- innodb_stats_persistent_sample_pages: 기본값은 20이며, ANALYZE TABLE 명령이 실행되면 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장되고 활용한다.

정확한 통계 정보 수집은 많은 시간이 소요되지만, 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 충분히 가치있다.
→ 조금 더 정확한 통계 정보를 수집하고자 한다면 `innodb_stats_persistent_sample_pages` 시스템 변수를 높은 값으로 설정하면 된다.
→ 하지만 이 값을 너무 높이면 통계 정보 수집이 길어지므로 주의해야 한다.

## 10.1.2 히스토그램
MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다.
→ 옵티마이저는 이러한 부족함을 메우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다.
→ 8.0 버전으로 업그레이드 되면서 MySQL 서버도 드디어 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

### 10.1.2.1 히스토그램 정보 수집 및 삭제
MySQL 8.0 버전에서 히스토그램 정보는 컬럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.
→ 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다.
→ 그래서 실제 히스토그램 정보를 조회하려면 `column_statistic` 테이블을 SELECT해서 참조할 수 있다.

MySQL 8.0 버전에서는 2 종류의 히스토그램 타입이 지원된다.
- Singleton(싱글톤 히스토그램): 컬럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고도 부른다.
- Equi-Height(높이 균형 히스토그램): 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램으로도 불린다.

히스토그램은 버킷 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리된다.
→ 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며, 높이 균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다.
→ 싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도의 비율의 2개 값을 가진다.
→ 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 가진다.

`information_schema.column_statistics` 테이블의 HISTOGRAM 컬럼이 가진 나머지 필드들은 다음과 같은 의미를 가진다.
- sampling-rate: 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율을 저장한다.
- histogram-type: 히스토그램 종류를 저장한다.
- number-of-buckets-specified: 히스토그램을 생성할 때 설정했던 버킷의 개수를 저장한다.

생성된 히스토그램은 다음과 같이 삭제할 수 있다.
```sql
ANALYZE TABLE employees.employees
DROP HISTOGRAM ON gender, hire_date;
```
- 히스토그램 삭제 작업은 테이블의 데이터를 참조하는 것이 아니라, 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다.
- 하지만 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다.

히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 `optimizer_switch` 시스템 변수의 값을 변경하면 된다.
→ `optimizer_switch` 시스템 변수의 값을 글로벌로 변경하면 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않는다.
```sql
SET GLOBAL optimizer_switch='condition_fanout_filter=off';
```

→ 특정 커넥션 또는 특정 쿼리에서만 히스토그램을 사용하지 않고자 한다면 아래와 같은 방법을 사용하면 된다.
```sql
SET SESSION optimizer_switch='condition_fanout_filter=off';
```

### 10.1.2.2 히스토그램의 용도
실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.
→ 이러한 점을 고려하여 히스토그램이 도입되었다. 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.

### 10.1.2.3 히스토그램과 인덱스
MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 히스토그램과 어느 정도 공통점을 가진다고 볼 수 있다.
MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
→ 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다. (인덱스 다이브)
→ **MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.**

## 10.1.3 코스트 모델
MySQL 서버가 쿼리를 처리하려면 다양한 작업을 필요로 한다.
- 디스크로부터 데이터 페이지 읽기
- 메모리로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

MySQL 서버는 사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다.
→ 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 *코스트 모델*이라고 한다.
→ MySQL 8.0 서버의 코스트 모델은 2개 테이블에 저장돼 있는 설정값을 사용하는데, 두 테이블 모두 mysql DB에 존재한다.
- server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리

server_cost 테이블과 engine_cost 테이블은 공통으로 5개의 컬럼을 가지고 있다.
- cost_name: 코스트 모델의 각 단위 작업
- default_value: 각 단위 작업의 비용
- cost_value: DBMS 관리자가 설정한 값
- last_updated: 단위 작업의 비용이 변경된 시점
- comment: 비용에 대한 추가 설명

engine_cost 테이블은 추가로 2개 컬럼을 더 가지고 있다.
- engine_name: 비용이 적용된 스토리지 엔진
- device_type: 디스크 타입

```ad-info
코스트 모델의 자세한 설정 값은 p.409~410 에서 확인 가능하다.
```

```ad-info
각 단위 작업의 비용을 이용해 MySQL 서버의 실행 계획에 표시되는 비용을 직업 계산해보고 싶을 수 있지만, 이러한 계산을 직접 해보기는 쉽지 않다.
```

코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다.
- key_compare_cost 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
- row_evaluate_cost 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, MySQL 서버 옵티마이저는 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다.
- disk_temptable_create_cost와 disk_temptable_row_cost 비용을 높이면 MySQL 옵티마이저는 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
- memory_temptable_create_cost와 memory_temptable_row_cost 비용을 높이면 MySQL 서버 옵티마이저는 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.
- io_block_read_cost 비용이 높아지면 MySQL 서버 옵티마이저는 가능한 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다.
- memory_block_read_cost 비용이 높아지면 MySQL 서버는 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.