---
title: 10.3 실행 계획 분석

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

MySQL 8.0 버전부터는 `EXPLAIN` 명령의 결과로 출력되는 실행 계획의 포맷을 기존 테이블 포맷과 JSON, TREE 형태로 선택할 수 있다.
> 사실 실행 계획의 출력 포맷보다는 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요하다.

```ad-tip
출력된 실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고,
아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당한다.
```

## 10.3.1 id 컬럼
하나의 `SELECT` 문장은 다시 1개 이상의 하위(SUB) `SELECT` 문장을 포함할 수 있다.
하나의 `SELECT` 문장안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다.

```sql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no LIMIT 10;
```
- 실행 계획 레코드는 2개이지만 1개의 id 값이 부여된다.

```sql
EXPLAIN
SELECT (
	(SELECT COUNT(*) FROM employees) + (SELECT COUNT(*) FROM departments)
) AS total_COUNT;
```
- 실행 계획 레코드가 3개이며 각기 다른 id 값이 부여된다.

> 실행 계획의 id 컬럼이 테이블의 접근 순서를 의미하지는 않는다.

```ad-tip
EXPLAIN FORMAT=TREE 명령을 이용하면 순서를 더 정확히 확인할 수 있다.
```


## 10.3.2 select_type 컬럼
각 단위 `SELECT` 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다.

### 10.3.2.1 SIMPLE
`UNION`이나 서브쿼리를 사용하지 않는 단순한 `SELECT` 쿼리인 경우 해당 쿼리 문장의 `select_type`은 `SIMPLE` 로 표시된다.
→ 쿼리 문장이 아무리 복잡하더라도 실행 계획에서 `select_type`이 `SIMPLE`인 단위 쿼리는 하나만 존재한다.

> 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 SIMPLE로 표시된다.

### 10.3.2.2 PRIMARY
`UNION`이나 서브쿼리를 가지는 `SELECT` 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 `select_type`이 `PRIMARY`로 표시된다.
→ `SIMPLE` 과 마찬가지로 `select_type`이 `PRIMARY`인 단위 SELECT 쿼리는 하나만 존재한다.

> 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMIARY로 표시된다.

### 10.3.2.3 UNION
`UNION`으로 결합하는 단위 `SELECT` 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 `SELECT` 쿼리의 `select_type`은 `UNION`으로 표시된다.
→ `UNION`이 첫 번째 단위 `SELECT`는 `select_type`이 `UNION`이 아니라, 임시 테이블(`DERIVED`)로 표시된다.

### 10.3.2.4 DEPENDENT UNION
`DEPENDENT UNION` 또한 `UNION` `select_type과` 같이 `UNION`이나 `UNION ALL`로 집합을 결합하는 쿼리에서 표시된다. 
> 여기서 DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.

### 10.3.2.5 UNION RESULT
UNION RESULT는 `UNION` 결과를 담아두는 테이블을 의미한다.
→ MySQL 8.0 이전 버전에서는 `UNION ALL` 이나, `UNION`(또는 `UNION DISTINCT`) 쿼리는 모두 `UNION`의 결과를 임시 테이블로 생성했다.
→ MySQL 8.0 버전부터는 UNION ALL의 경우, 임시 테이블을 사용하지 않도록 기능이 개선되었다.

UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

### 10.3.2.6 SUBQUERY
`select_type`의 SUBQUERY는 `FROM`절 이외에서 사용되는 서브쿼리만을 의미한다.
→ MySQL 서버의 실행 계획에서 `FROM` 절에 사용된 서브쿼리는 `select_type`이 DERIVED로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시된다.

```ad-note
서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 가지고 있다.
- 중첩된 쿼리 (Nested Query): SELECT되는 컬럼에 사용된 서브쿼리를 네스티드 쿼리라고 한다.
- 서브쿼리 (Subquery): WHERE 절에 사용된 경우에 일반적으로 서브쿼리라고 한다.
- 파생 테이블 (Derived Table): FROM 절에 사용된 서브쿼리를 MySQL에서는 파생테이블이라고 하며, 일반적으로 RDBMS에서는 인라인 뷰 또는 서브 셀렉트라고 부른다.
```

```ad-note
서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분하기도 한다.
- 스칼라 서브쿼리 (Scalar Subquery): 하나의 값만 반환하는 쿼리 (컬럼이 단 하나인 레코드 1건만 반환)
- 로우 서브쿼리 (Row Subquery): 컬럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리
```

### 10.3.2.7 DEPENDENT SUBQUERY
서브쿼리가 바깥쪽 `SELECT` 쿼리에서 정의된 컬럼을 사용하는 경우, `select_type`에 DEPENDENT SUBQUERY라고 표시된다.
→ DEPENDENT UNION과 같이 DEPENDENT SUBQUERY 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.

### 10.3.2.8 DERIVED
DERIVED는 단위 `SELECT` 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
→ `select_type`이 DERIVED인 경우에 생성되는 임시 테이블을 파생 테이블이라고도 한다.

MySQL 5.5 버전까지는 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많았다.
→ 그러나 MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.

```ad-tip
파생 테이블에 대한 최적화가 부족한 버전의 MySQL 서버를 사용 중일 경우, 가능하다면 DERIVED 형태의 실행 께획을 조인으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋다.
```

MySQL 8.0 버전부터는 FROM절의 서브쿼리에 대한 최적화도 많이 개선되어 가능하다면 불필요한 서브쿼리는 조인으로 쿼리를 재작성해서 처리한다.
→ 하지만 옵티마이저가 처리할 수 있는 것은 한계가 있으므로 여전히 최적화된 쿼리를 작성하는 것은 중요하다.

### 10.3.2.9 DEPENDECT DERIVED
MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 컬럼을 사용할 수가 없었지만, MySQL 8.0 버전부터는 리터럴 조인 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 되었다.
→ `select_type` 컬럼의 DEPENDENT DERIVED 키워드는 해당 테이블이 리터럴 조인으로 사용된 것을 의미한다.

### 10.3.2.10 UNCACHEABLE SUBQUERY
하나의 쿼리 문장에 서브쿼리가 하나만 있어도 실제 그 서브쿼리가 한 번만 실행되는 것이 아니다.
→ 그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.

```ad-note
- SUBQUERY: 바깥쪽의 영향을 받지 않으므로, 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
- DEPENDENT SUBQUERY: 의존하는 바깥쪽 쿼리의 컬럼의 값 단위로 캐시해두고 사용한다.
```

select_type이 SUBQUERY인 경우와 UNCACHEABLE SUBQUERY는 캐시를 사용할 수 있느냐 없느냐에 차이가 있다.
→ 캐시를 사용하지 못하게 하는 요소로는 다음과 같은 것들이 있다.
- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
- UUID() 나 RAND() 와 같이 결괏값이 호출될 때마다 달라지는 함수가 서브쿼리에 사용된 경우

### 10.3.2.11 UNCACHEABLE UNION
UNCACHEABLE UNION이란 이 두 개 키워드의 속성이 혼합된 select_type을 의미한다.

### 10.3.2.12 MATERIALIZED
MySQL 5.6 버전부터 도입된 select_type으로, 주로 FROM 절이나 IN (subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
→ select_type에 사용된 MATERIALIZED 키워드는 DERIVED와 비슷하게 쿼리의 내용을 임시 테이블로 생성한다는 것을 의미한다는 정도만 이해하자

## 10.3.3 table 컬럼
MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.
→ 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.

table 컬럼에 \<derived N\> 또는  \<union M,N\> 과 같이 “<>” 로 둘러싸인 이름이 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미한다.
→ 또한 “<>” 안에 항상 표시되는 숫자는 단위 SELECT 쿼리의 id 값을 의미한다.

## 10.3.4 partitions 컬럼
MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록은 `EXPLAIN PARTITION` 명령을 이용해 확인 가능했지만 MySQL 8.0 버전부터는 `EXPLAIN` 명령으로 파티션 관련 실행 계획까지 모두 확인할 수 있게 변경됐다.

파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 푸르닝(Partition Pruning)이라고 한다.
→ 파티션을 참조하는 쿼리(파티션 키 컬럼을 WHERE 조건으로 가진)의 경우, 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 `partitions` 컬럼에 표시해준다.

MySQL 포함한 대부분의 RDBMS에서 지원하는 파티션은 물리적으로 개별 테이블처럼 별도의 저장 공간을 가지기 때문에 파티션 테이블의 일부만 읽을 수 있다.
→ 이는 실행 계획의 type이 ALL로 나타날 수 있다. 즉 풀 테이블 스캔으로 처리될 수 있는 점이다.

## 10.3.5 type 컬럼
쿼리의 실행 계획에서 type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
→ 즉, 인덱스를 이용해 읽었는지 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지 등을 의미한다.
→ 일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 type 컬럼은 반드시 체크해야 할 중요한 정보이다.

실행 계획의 type 컬럼에 표시될 수 있는 값은 현재 많이 사용되는 대부분의 버전에서 거의 차이 없이 다음과 같이 표시된다.
- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subqeury
- index_subquery
- range
- index_merge
- index
- ALL

> 12개의 접근 방법 중에서 ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.
> ALL은 인덱스를 사용하지 않는 풀 테이블 스캔 접근 방법을 의미한다.

### 10.3.5.1 system
레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라고 한다.
→ 이 방법은 InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.

> system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있는 접근 방법이므로 실제 어플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.

### 10.3.5.2 const
테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 처리 방식을 const 라고 한다.
→ 다른 DBMS에서는 이를 유니크 인덱스 스캔(UNIQUE INDEX SCAN)이라고도 표현한다.

다중 컬럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다.
→ 이렇게 프라이머리 키의 일부만 조건으로 사용할 떄는 type 컬럼에 const가 아닌 ref로 표시된다.

### 10.3.5.3 eq_ref
eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
→ 조인에서 처음 읽은 테이블의 컬럼값을, 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 떄를 가리켜 eq_ref라고 한다.
→ 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.

### 10.3.5.4 ref
ref 접근 방법은 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다.
인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용된다.
→ 반환되는 레코드가 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다.

```ad-note
- const: 조인의 순서와 관계없이 프라이머리 키나 유니크 키의 모든 컬럼에 대해 동등 조건으로 검색 (반드시 1건의 레코드만 반환)
- eq_ref: 조인에서 첫 번째 읽은 테이블의 컬럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색 (두 번째 테이블은 반드시 1건의 레코드 반환)
- ref: 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색 (1건의 레코드만 반환한다는 보장이 없어도 됨)
```

### 10.3.5.5 fulltext
fulltext 접근 방법은 MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.
→ 전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.

MySQL 서버에서 전문 검색 조건은 우선순위가 상당히 높다.
→ 쿼리에서 전문 검색 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방법이 const나 eq_ref, ref가 아니면 일반적으로 MySQL은 전문 인덱스를 사용하는 조건을 선택해서 처리한다.

> 저자의 경험상으로 전문 검색 인덱스를 이용하는 fulltext보다 일반 인덱스를 이용하는 range 접근이 더 빨리 처리되는 경우가 많았다.
> 전문 검색 쿼리를 사용할 때는 조건별로 성능을 확인해 보는 것이 좋다.

### 10.3.5.6 ref_or_null
ref_or_null은 ref 접근 방법과 같은데, NULL 비교가 추가된 형태이다. 
→ 접근 방법의 이름 그대로 ref 방식 또는 NULL 비교(IS NULL) 접근 방법을 의미한다.
→ 실제 업무에서 많이 활용되진 않지만, 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억해도 된다.

### 10.3.5.7 unique_subquery
unique_subquery는 WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
→ 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

### 10.3.5.8 index_subquery
IN 연산자 특성상 IN(subquery) 또는 IN(상수 나열) 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다.
→ 만약 서브쿼리의 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.
- unique_subquery: IN(subquery) 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음
- index_subquery: IN(subquery) 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음

### 10.3.5.9 range
range는 익히 알고 있는 인덱스 레인지 스캔 형태의 접근 방법이다.
→ range는 인덱스를 하나의 값이 아니라, 범위로 검색하는 경우를 의미하는데, 주로 “<, >, IS NULL, BETWEEN, IN, LIKE” 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.

일반적으로 어플리케이션의 쿼리가 가장 많이 사용하는 접근 방법인데, 소개하는 접근 방법의 순서상 MySQL 서버가 가지고 있는 접근 방법 중에서 상당히 우선순위가 낮다.
→ 하지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.

### 10.3.5.10 index_merge
index_merge 접근 방법은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 변합해서 처리하는 방식이다.
→ 하지만 index_merge 접근 방법이 사용되는 경우를 생각해보면 그렇게 효율적으로 작동하진 않는다.
- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에, 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

> MySQL 메뉴얼에서 index_merge 접근 방법의 우선순위는 ref_or_null 바로 다음에 있다.

### 10.3.5.11 index
index 접근 방법은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.
→ 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다.
→ 하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔시 풀 테이블의 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있다.

index 접근 방법은 다음 조건 가운에 (첫 번째 + 두 번째) 조건을 충족하거나 (첫 번째 + 세 번째) 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.
1. range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
2. 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우 (데이터 파일을 읽지 않아도 되는 경우)
3. 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (별도의 정렬 작업을 피할 수 있는 경우)


### 10.3.5.12 ALL
ALL은 흔히 알고 있는 풀 테이블 스캔을 의미하는 접근 방법이다.
→ 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환한다.
→ 풀 테이블 스캔은 지금까지 설명한 접근 방법으로는 처리할 수 없을 때 가장 마지막에 선택하는 가장 비효율적인 방법이다.

```ad-info
다른 DBMS와 같이 InnoDB도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O를 유발하는 작업을 위해 한꺼번에 읽어 들이는 기능을 제공한다.
→ InnoDB 에서는 이 기능을 리드 어헤드라고 하며, 한 번에 여러 페이지를 읽어서 처리할 수 있다.
```

일반적으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내야 하는 웹 서비스 등과 같은 온라인 트랜잭션 처리 환경에서는 적합하지 않다.

## 10.3.6 possible_keys 컬럼
MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다.
→ 그런데 possible_keys 컬럼에 있는 내용은 옵티마이저가 최적의 실행 계획을 만들기 위해 후로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이다.
→ 즉, “사용될 법했던 인덱스의 목록” 이다.

> possible_keys 컬럼에 인덱스 이름이 나열됐다고 해서 그 인덱스를 사용한다고 판단하지 않도록 하자.

## 10.3.7 key 컬럼
key 컬럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.
→ 그러므로 쿼리를 튜닝할 떄는 key 컬럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.

실행 계획의 type 컬럼이 index_merge가 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용할 수 있다.
→ 하지만 index_merge 실행 계획이 사용될 때는 2개 이상의 인덱스가 사용되는데, 이때는 key 컬럼에 여러 개의 인덱스가 “.”로 구분되어 표시된다.
→ 실행 계획의 type이 ALL일 떄와 같이 인덱스를 전혀 사용하지 못하면 key 컬럼은 NULL로 표시된다.

## 10.3.8 key_len 컬럼
key_len 컬럼은 사용자가 무시하는 정보지만 사실은 매우 중요한 정보 중 하나이다.
→ 실행 계획의 key_len 컬럼은 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 우리에게 알려준다.
→ 정확하게는, 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.

## 10.3.9 ref 컬럼
접근 방법이 ref면 참조 조건으로 어떤 값이 제공됐는지 보여준다.
→ 상숫값을 지정했다면 ref 컬럼의 값은 const로 표시되고, 다른 테이블의 컬럼값이면 그 테이블과 컬럼명이 표시된다.

가끔 쿼리의 실행 계획에서 ref 컬럼 값이 func라고 표시될 떄가 있는데, 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.
→ 사용자가 명시적으로 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환할 때도 ref 컬럼에는 func가 표시된다.

## 10.3.10 rows 컬럼
MySQL 실행 계획의 rows 컬럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.
→ 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 **정확하지는 않다.**
→ 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미

> 실행 계획의 rows 컬럼에 출력되는 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다.

## 10.3.11 filtered 컬럼
filtered 컬럼 값은 필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.
→ filtered 컬럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 달라질 수 있다.

> MySQL 8.0에서는 filtered 컬럼의 값을 더 정확히 예측할 수 있도록 히스토그램 기능이 도입됐다.


