---
title: 10.3.12 Extra 컬럼

categories:
- study

tags:
- database

toc: true
toc_sticky: true
toc_label: Contents
---

쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 `Extra` 컬럼에 자주 표시된다.
→ Extra 컬럼에는 주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많다.

## 10.3.12.1 const row not found
쿼리의 실행 계획에서 const 접근 방법으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면 `const row not found` 가 표시된다.
→ 해당 메시지가 표시되는 경우에는 테이블에 적절히 테스트용 데이터를 저장하고 다시 한번 실행 계획을 확인해보는 것이 좋다.

## 10.3.12.2 Deleting all rows
스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우(MyISAM 같은 경우) 표시된다.
→ `Deleting all rows` 문구는 WHERE 조건절이 없는 DELETE 문장의 실행 계획에서 자주 표시된다.
→ 이는 테이블의 모든 레코드를 삭제하는 핸들러 기능(API)을 한번 호출함으로써 처리됐다는 것을 의미한다.

## 10.3.12.3 Distinct
해당 표시는, 쿼리의 `DISTNCT`를 처리하기 위해 조인하지 않아도 되는 항목을 무시하고 꼭 필요한 것만 조회하려 할 때 나타나는 키워드이다.

## 10.3.12.4 FirstMatch
세미 조인의 여러 최적화 중에서 FirstMatch 전략이 사용되면 MySQL 옵티마이저는 실행 계획의 Extra 컬럼에 `FirstMatch(table_name)` 가  표시된다.

## 10.3.12.5 Full scan on NULL key
이 처리는 `col 1 IN (SELECT col2 FROM ...)` 과 같은 조건을 가진 쿼리에서 자주 발생할 수 있다.
→ MySQL 서버가 쿼리를 실행 하는 중 col1이 NULL을 만나면 차선택으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드이다.
→ col1 값이 NULL 이 된다면 결과적으로 조인은 `NULL IN (SELECT col2 FROM ...)` 과 같이 바뀐다.
- 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
- 서브쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE

→ 만약 col1이 NOT NULL로 정의된다면 이 방법은 풀 테이블 스캔을 사용하지 않으며 Extra 컬럼에도 표시되지 않는다.
```sql
SELECT *
FROM tb_test1
WHERE col1 IS NOT NULL
	AND col1 IN (SELECT col2 FROM tb_test2);
```

## 10.3.12.6 Impossible HAVING
쿼리에 사용된 HAVING  절의 조건을 만족하는 레코드가 없을 때 실행 계획의 Extra 컬럼에는 해당 키워드가 표시된다.
→ 어플리케이션의 쿼리 중에서 실행 계획의 Extra 컬럼에 Impossible Having 메시지가 출력된다면 쿼리가 제대로 작성되지 못한 경우가 대부분이다.

## 10.3.12.7 Impossible WHERE
WHERE 조건이 항상 FALSE가 될 수밖에 없는 경우 Impossible WHERE가 표시된다.

## 10.3.12.8 LooseScan
세미 조인 최적화 중에서 LooseScan 최적화 전략이 사용되면 실행 계획의 Extra 컬럼에는 해당 문구가 표시된다.

## 10.3.12.9 No Matching min/max row
`MIN()` 이나 `MAX()` 와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한건도 없을 때 해당 문구가 표시되며 그 결과로 NULL이 반환된다.

## 10.3.12.10 no matching row in const table
조인에 사용된 테이블에서 const  방법으로 접근할때 일치하는 레코드가 없다면 표시되는 문구이다.

## 10.3.12.11 No matching rows after partition pruning
파티션된 테이블에 대한 UPDATE 또는 DELETE 명령의 실행 계획에서 표시될 수 있는데, 해당 파티션에서 UPDATE 혹은 DELETE 할 대상 레코드가 없을 때 표시된다.
→ 이는 단순히 삭제할 레코드가 없음을 의미하는 것이 아닌, 대상 파티션이 없다는 것을 의미한다.

## 10.3.12.12 No tables used
FROM 절이 없는 쿼리 문장이나 FROM DUAL (컬럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블) 형태의 쿼리 실행 계획에서는 Extra 컬럼에 No tables used 라는 메시지가 출력된다.

```ad-tip
다른 RDBMS와 달리 MySQL 서버는 FROM  절이 없는 쿼리도 허용된다.
```

## 10.3.12.13 Not exists
해당 메시지는 옵티마이저가 테이블을 안티 조인(혹은, 아우터 조인)할 때 레코드가 존재하는지 아닌지만 판단하는 것을 의미한다.
→ 테이블에 조인 조건에 일치하는 레코드가 여러 건이 있다고 하더라도 딱 1건만 조회해보고 처리를 완료하는 최적화를 의미한다.

## 10.3.12.14 Plan isn’t ready yet
`EXPLAIN FOR CONNECTION` 명령을 실행했을 때 Extra 컬럼에 Plan is not ready yet 이라는 메시지가 표시될 때가 있는데, 해당 커넥션에서 아직 쿼리의 실행 계획을 수립하지 못한 상태에서 `EXPLAIN FOR CONNECTION` 명령이 실행된 것을 의미한다.
→ 이 경우에는 대상 커넥션의 쿼리가 실행 계획을 수립할 여유 시간을 좀 더 주고, 다시 명령을 실행하면 된다.

```ad-note
EXPLAIN FOR CONNECTION 명령은 MySQL 옵티마이저가 의도된 인덱스를 사용하지 못해서 풀 스캔을 한다던가 실행 계획을 선택한 것이 아닌지 확인할 때 유용하게 사용할 수 있는 명령이다.
```

## 10.3.12.15 Range checked for each record (index map: N)
해당 키워드는 간단하게, 레코드마다 인덱스 레인지 스캔을 체크하여 최적화를 했다는 표시이다.

```sql
EXPLAIN
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```
- e1.emp_no이 작을 때는 e2 테이블을 풀테이블 스캔으로 접근하는 것이 최적이다
- e1.emp_no이 클 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 최적이다.

## 10.3.12.16 Recursive
MySQL 8.0 버전부터는 CTE(Common Table Expression)을 이용해 재귀 쿼리를 처리를 작성할 수 있게 되었다.

```sql
WITH RESURSIVE cte (n) AS
(
	SELECT 1
	UNION ALL
	SELECT n+1 FROM cte WHERE n < 5
)
SELECT * FROM cte;
```
- n이라는 컬럼 하나를 가진 cte라는 이름의 내부 임시 테이블을 생성
- n컬럼의 값이 1부터 5까지 1씩 증가하게 해서 레코드 5건을 만들어서 cte 내부 임시 테이블에 저장

그리고 WITH 절 다음의 SELECT 쿼리에서 WITH 절에서 생성된 내부 임시 테이블을 풀 스캔해서 결과를 반환한다.
→ 이렇게 CTE를 이용한 재귀 쿼리의 실행 계획은 Extra 컬럼에 Recursive 구문이 표시된다.

## 10.3.12.17 Rematerialize
MySQL 8.0 버전부터는 래터럴 조인 기능이 추가되었는데, 래터럴로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시테이블에 저장한다.
→ 이 과정을 Rematerializing 이라고 한다. (11장에서 배울 예정)
→ 임시 테이블이 반복적으로 새로 생성되는 경우 Rematerialize 문구가 표시된다.

## 10.3.12.18 Select tables optimized away
`MIN()` 또는 `MAX()`만 SELECT 절에 사용되거나 GROUP BY로 `MIN()`, `MAX()`를 조회하는 쿼리가 인덱스를 오름차순 혹은 내림차순으로 1건만 읽는 형태의 최적화가 적용된다면 “Select tables optimized way” 가 표시된다.
→ 또한, MyISAM 테이블에 대해서는 GROUP BY 없이 `COUNT(*)` 만 SELECT할 때도 이런 형태의 최적화가 적용된다.

```sql
MyISAM 테이블은 전체 레코드 건수를 별도로 관리하기 때문에 인덱스나 데이터를 읽지 않고도 전체 건수를 빠르게 조회할 수 있다.
하지만, WHERE 조건절이 있는 쿼리는 이런 최적화를 사용하지 못한다.
```

## 10.3.12.19 Start temporary, End temporary
세미 조인 최적화 중에서 Duplicate Weed-out 최적화 전략이 사용되면 MySQL 옵티마이저는 실행 계획이 “Start emporary” 와 “End temporary” 문구를 표시하게 된다.
→ Duplicate Weed-out 최적화 전략은 불필요한 중복 건을 제거하기 위해서 내부 임시 테이블을 사용하는데, 이때 조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 “Start emporary” 문구를 보여주고 조인이 끝나느 부분에 “End temporary” 문구를 표시한다.

## 10.3.12.20 unique row not found
두 개의 테이블이 각각 유니크(프라이머리 키 포함) 컬럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 unique row not found가 표시된다.

## 10.3.12.21 Using filesort
ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는 MySQL 서버가 조회된 레코드를 다시 한번 정렬해야 하는데, ORDER BY 처리가 인덱스를 사용하지 못할 떄만 실행 계획에 “Using filesort” 코멘트가 표시된다.
→ 이는 조회된 레코드를 정렬용 메모리 버터에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미이다.

```ad-note
Using filesort 코멘트는 ORDER BY가 사용된 실행 계획에서만 나타날 수 있다.

실행 계획에 Using filesort가 출력되는 쿼리는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.
```

## 10.3.12.22 Using index (커버링 인덱스)
데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 모두 처리할 수 있을 때 “Using index” 가 표시된다.

```ad-info
인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 차지하는 부분은 인덱스 검색에서 일치하는 키 값들의 레코드를 읽기 위해 데이터 파일을 검색하는 작업이다.
최악의 경우에는 인덱스를 통해 검색된 결과 레코드를 한 건 한 건마다 디스크를 한 번씩 읽어야 할 수도 있다.
```

→InnoDB의 세컨더리 인덱스에서는 데이터 레코드를 찾아가기 위한 주소로 사용하기 위해 프라이머리 키를 저장해두는 것이지만, 추가 컬럼을 하나 더 가지는 인덱스의 효과를 동시에 얻을 수 있다.

쿼리를 커버링 인덱스로 처리할 수 있을 때와 그렇지 못할 때의 성능 차이는 수십 배에서 수백 배까지 날 수 있다.
→ 하지만 무조건 커버링 인덱스로 처리하려고 인덱스에 많은 컬럼을 추가하면 더 위험한 상황이 초래 될 수 있다.
→ 과도하게 인덱스의 컬럼이 많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지고 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있다.

접근 방법이 eq_ref, ref, range, index_merge, index 등과 같이 인덱스를 사용하는 실행 계획에서는 모두 Using index가 표시될 수 있다.
→ 즉, 인덱스 레인지 스캔을 사용할 때만 커버링 인덱스로 처리되는 것은 아니다.
→ 인덱스 풀 스캔을 실행할 때도 커버링 인덱스로 처리될 수 있는데, 이때도 똑같은 인덱스 풀 스캔의 접근 방법이라면 커버링 인덱스가 아닌 경우보다 훨씬 빠르게 처리된다.

## 10.3.12.23 Using index condition
MySQL 옵티마이저가 인덱스 컨디션 푸시 다운 (Index condition pushdown) 최적화를 사용하면 Using index condition 메시지가 표시된다.

## 10.3.12.24 Using index for group-by
GROUP BY 처리가 인덱스를 이용할 때 쿼리의 실행 계획에서 Using index for group-by 메시지가 표시된다.
→ GROUP BY 처리를 위해 인덱스를 읽는 방법을 ”루스 인덱스 스캔”이라고 한다.

```ad-info
GROUP BY 처리를 위해 MySQL 서버는 그루핑 기준 컬럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그루핑하는 형태의 고부하 작업을 필요로 한다.
하지만 GROUP BY 처리가 인덱스를 이용하면 정렬된 인덱스 컬럼을 순서대로 읽으면서 그루핑 작업만 수행한다.
-> 이럴 경우, 레코드의 정렬이 필요하지 않고 인덱스의 필요한 부분만 읽으면 되기 때문에 상당히 효율적이고 빠르게 처리된다.
```

### 10.3.12.24.1 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리
인덱스를 이용해 GROUP BY 절을 처리할 수 있더라도 `AVG()`, `SUM()`, `COUNT()` 처럼 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성듬성 읽을 수 없다.
→ 이러한 쿼리는 단순히 GROUP BY를 위해 인덱스를 사용하긴 하지만, 이를 루스 인덱스 스캔이라고 하지는 않는다.
→ 또한, 이러한 쿼리의 실행 계획에는 Using index for group-by 메시지가 출력되지 않는다.

### 10.3.12.24.2 루스 인덱스 스캔을 통한 GROUP BY 처리
단일 컬럼으로 구성된 인덱스에서는 그루핑 컬럼 말고는 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다.
그리고 다중 컬럼으로 만들어진 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 함을 물론이고 `MIN()`, `MAX()` 같이 조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리는 “루스 인덱스 스캔”이 사용될 수 있다.
→ 이 떄는 인덱스를 듬성듬성하게 필요한 부분만 읽는다.

GROUP BY에서 인덱스를 사용하려면 우선 GROUP BY 조건에서 인덱스를 사용할 수 있는 요건이 갖춰져야 한다.
→ 그 전에 WHERE 절에서 사용하는 인덱스에 의해서도 GROUP BY 절의 인덱스 사용 여부가 영향을 받는다는 사실이 중요한다.
- **WHERE 조건절이 없는 경우**
	- WHERE 절의 조건이 전혀 없는 쿼리는 GROUP BY 절의 컬럼과 SELECT 로 가져오는 컬럼이 “루스 인덱스 스캔”을 사용할 수 있는 조건만 갖추면 된다.
	- 그렇지 못한 쿼리는 타이트 인덱스 스캔이나 별도의 정렬 과정을 통해 처리된다.
- **WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우**
	- GROUP BY 절은 인덱스를 사용할 수 있지만 WHERE 조건절이 인덱스를 사용하지 못할 때는 먼저 GROUP BY를 위해 인덱스를 읽은 후 WHERE 조건의 비교를 위해 데이터 레코드를 읽어야만 한다.
	- 이 경우도 루스 인덱스 스캔을 이용할 수 없으며, 타이트 인덱스 스캔 과정을 통해 GROUP BY가 처리된다.
- **WHERE 절의 조건이 있고, 검색을 위해 인덱스를 사용하는 경우**
	- 하나의 단위 쿼리가 실행되는 경우에 index_merge 이외의 접근 방법에서는 단 하나의 인덱스만 사용할 수 있다.
	- 그래서 WHERE 절의 조건이 인덱스를 사용할 수 있으면 GROUP BY가 인덱스를 사용할 수 있는 조건이 더 까다로워진다.
	- *WHERE 절의 조건과 GROUP BY 처리가 똑같은 인덱스를 공통으로 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있다.*

## 10.3.12.25 Using index for skip scan
MySQL 옵티마이저가 인덱스 스킵 스캔 최적화를 사용하면 Using index for skip scan 메시지를 표시한다.

## 10.3.12.26 Using join buffer (Block Nested Loop), Using Join buffer (Batched Key Access), Using join buffer (hash Join)
조인이 수행 될 때 드리븐 테이블의 조인 컬럼에 적절한 인덱스가 있다면 아무런 문제가 되지 않지만, 드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면 MySQL 서버는 블록 네스티드 루프 조인이나 해시 조인을 사용한다.
→ 블록 네스티드 루프 조인이나, 해시 조인을 사용하면 MySQL 서버는 조인 버퍼를 사용한다.
→ 조인 버퍼가 사용되는 실행 계획에서는 Using join buffer라는 메시지가 표시된다.

```ad-tip
사용자는 join_buffer_size라는 시스템 변수에 최대로 할당 가능한 조인 버퍼 크기를 설정할 수 있다.
조인되는 컬럼에 인덱스가 적절하게 준비돼 있다면 조인 버퍼는 크게 신경 쓰지 않아도 되지만, 조인 버퍼를 너무 부족하거나 과다하게 사용되지 않게 적절히 설정하는 것이 좋다.
```

## 10.3.12.27 Using MRR
```ad-note
MySQL 엔진은 실행 계획을 수립하고 그 실행 계획에 맞게 스토리지 엔진 API를 호출해서 쿼리를 처리한다.
InnoDB를 포함한 스토리지 엔진 레벨에서는 쿼리 실행의 전체적인 부분을 알지 못하기 때문에 최적화에 한계가 있다.

이러한 MySQL의 단점을 보완하기 위해 MRR (Multi Range Read)라는 최적화를 도입했다.
```

MySQL 엔진은 려어 개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화한다.
→ MRR이 도입되면서 각 스토리지 엔진은 디스크 접근을 최소화할 수 있게 된다.

## 10.3.12.28 Using sort_union(…), Using union(…), Using inersect(…)
쿼리가 index_merge 접근 방법으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있다.
→ 이때 실행 계획의 Extra 컬럼에는 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명하기 위해 다음 3개 중에서 하나의 메시지를 선택적으로 출력한다.
- Using intersect(…) : 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미
- Using union(…) : 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미
- Using sort_union(…) : Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우, 이 방식으로 처리한다.
	- Using sort_union과 Using union의 차이점은 Using sort_union은 프라이머리 키만 먼저 읽어서 정렬하고 병합한 이후 비로소 레코드를 읽어서 반환할 수 있다는 것이다.

Using union()은 대체로 동등 비교처럼 일치하는 레코드 건수가 많지 않을 경우 사용되고, 각 조건이 크다 또는 작다와 같이 상대적으로 많은 레코드에 일치하는 조건이 사용되는 경우는 Using sort_union()이 사용된다.

## 10.3.12.29 Using temporary
MySQL 서버에서 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용한다.
→ 임시 테이블은 메모리상에 생성될 수도 있고, 디스크 상에 생성될 수도 있다.
→ 실행 계획에서 Using temporary 키워드가 표시되면 임시 테이블을 사용한 것인데, 임시 테이블이 메모리에 생성됐는지 디스크에 생성됐는지는 실행 계획만으로는 알 수 없다.

## 10.3.12.30 Using where
MySQL 서버는 내부적으로 크게 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눠볼 수 있다.
- 스토리지 엔진: 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할
- MySQL 엔진: 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행

→ MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 Using where 코멘트가 표시된다.

실행 계획의 Extra 컬럼에 표시되는 Using where가 성능상의 문제를 일으킬지 아닐지를 적절히 선별하는 능력이 필요한데, MySQL 8.0에서는 실행 계획에 filtered 컬럼이 같이 표시되므로 성능상의 이슈가 잇는지 없는지를 알아낼 수 있다.

## 10.3.12.31 Zero limit
때로는 MySQL 서버에서 데이터 값이 아닌 쿼리 결괏값의 메타데이터만 필요한 경우도 있다.
→ 즉, 쿼리의 결과가 몇 개의 컬럼을 가지고 각 컬럼의 타입은 무엇인지 등의 정보만 필요한 경우가 있다.
이런 경우에는 쿼리의 마지막에 `LIMIT 0` 을 사용하면 되는데, 실제 테이블의 레코드는 전혀 읽지 않고 결괏값의 메타정보만 반환한다.
→ 이 경우 실행 계획의 Extra 컬럼에는 Zero limit 메시지가 표시된다.