---
title: 11.6 UPDATE와 DELETE

categories:
- study

tags:
- database

toc: true
toc_sticky: true
toc_label: Contents
---

## 11.6.1 UPDATE … ORDERED BY … LIMIT n
MySQL에서는 UPDATE나 DELETE 문장에 ORDER BY 절과 LIMIT 절을 동시에 사용해 특정 컬럼으로 정렬해서 상위 몇 건만 변경 및 삭제하는 것도 가능하다.
→ 한 번에 많은 레코드를 변경 및 삭제하는 작업은 MySQL 서버에 과부하를 유발하거나 다른 커넥션의 쿼리 처리를 방해할 수도 있다. 이때 LIMIT을 이용해 조금씩 잘라서 변경하거나 삭제하는 방식을 손쉽게 구현할 수 있다.

> ORDER BY에 의해 정렬되더라도 중복된 값의 순서가 복제 소스 서버와 레플리카 서버가 달라져서 경고가 발생할 수도 있다.
> 그렇기에, 복제가 구축된 MySQL 서버에서 ORDER BY가 포함된 UPDATE나 DELETE 문장을 사용할 때는 주의하자.

## 11.6.2 JOIN UPDATE
두 개 이상의 테이블을 조인해 조인된 결과 레코드를 변경 및 삭제하는 쿼리를 JOIN UPDATE라고 한다.
→ 조인된 테이블 중에서 특정 테이블의 컬럼값을 다른 테이블의 컬럼에 업데이트해야 할 때 주로 조인 업데이트를 사용한다.
→ 또는 꼭 다른 테이블의 컬럼값을 참조하지 않더라도 조인되는 양쪽 테이블에 공통으로 존재하는 레코드만 찾아서 업데이트하는 용도로도 사용할 수 있다.

JOIN UPDATE 쿼리도 2개 이상의 테이블을 먼저 조인해야 하는 경우가 있으므로, 테이블의 조인 순서에 따라 UPDATE 문장의 성능이 달라질 수 있다.
→ JOIN UPDATE 문장도 사용하기 전에 실행 계획을 확인하는 것이 좋다.

JOIN UPDATE 문장에서는 GROUP BY, ORDER BY 절을 사용할 수 없다.
→ 필요한 경우가 있다면 *서브쿼리를 이용한 파생 테이블*을 이용하자

## 11.6.3 여러 레코드 UPDATE
하나의 UPDATE 문장으로 여러 개의 레코드를 업데이트하는 경우, 아래와 같이 모든 레코드를 동일한 값으로만 업데이트 할 수 있다.
```sql
UPDATE departments SET emp_count=10;
UPDATE departments SET emp_count + 10;
```

MySQL 8.0 버전부터는 레코드 생성(Row Constructor) 문법을 이용해 레코드별로 서로 다른 값을 업데이트할 수 있게 됐다.
→ `VALUES ROW(...), ROW(...), ...` 문법을 사용하면 SQL 문장 내에서 임시 테이블을 생성하는 효과를 낼 수 있다.
```sql
UPDATE user_level ul
INNER JOIN (VALUES ROW(1, 1),
				   ROW(2, 4)) new_user_level (user_id, user_lv)
								ON new_user_level.user_id=ul.user_id
					SET ul.user_lv=ul.user_lv + new_user_level.user_lv;
```

## 11.6.4  JOIN DELETE
JOIN DELETE 문장은 단일 테이블의 DELETE 문장과는 조금 다른 문법으로 쿼리를 작성해야 한다.
→ 일반적으로 삭제는, `DELETE FROM table ...` 과 같은 문법으로 사용하지만, JOIN DELETE 문장에서는 DELETE와 FROM 절 사이에 삭제할 테이블을 명시해야 한다.
```sql
DELETE e
FROM employees e, dept_emp de, departments d
WHERE e.emp_no=de.emp_no AND de.dept_no=d.dept_no AND d.dept_no='d001';
```

→ JOIN DELETE 문장으로 하나의 테이블에서만 레코드를 삭제하는 것이 아닌, 여러 테이블의 레코드를 동시에 삭제할 수도 있다.

