---
title: 11.5 INSERT

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

일반적으로 온라인 트랜잭션 서비스에서 INSERT 문장은 대부분은 1건 또는 소량의 레코드를 INSERT하는 형태이므로 그다지 성능에 대해서 고려할 부분이 많지 않다.
→ 많은 INSERT 문장이 동시에 실행되는 경우 **INSERT 문장 자체보다는 테이블의 구조가 성능에 더 큰 영향**을 미친다.

많은 경우 INSERT의 성능과 SELECT 성능을 동시에 빠르게 만들 수 있는 테이블 구조는 없고, 서로 성능을 어느정도 타협하면서 테이블 구조를 설계해야 한다.

## 11.5.1 고급 옵션
### 11.5.1.1 INSERT IGNORE
INSERT 문장의 IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 컬럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 컬럼이 테이블의 컬럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해준다.
→ 주로 해당 옵션은 여러 레코드를 하나의 INSERT 문장으로 처리하는 경우 유용하다.

IGNORE를 사용하지 않으면, INSERT 되는 레코드의 값이 이미 테이블에 존재할 때 해당 레코드는 에러가 발생한다.
→ 하지만 MySQL에 IGNORE 옵션이 있는 경우, 에러를 경고 수준의 메시지로 바꾸고 나머지 레코드의 INSERT를 계속 진행한다.
→ INSERT 하는 테이블이 프라이머리 키와 유니크 인덱스를 동시에 가지고 있는 경우, INSERT IGNORE는 두 인덱스 중 하나라도 중복이 발생하는 레코드에 대해서는 INSERT를 무시한다.

INSERT IGNORE 옵션은 단순히 유니크 인덱스의 중복뿐만 아니라 데이터 타입이 일치하지 않아서 INSERT를 할 수 없는 경우에도 컬럼의 기본 값으로 INSERT를 하도록 만들기도 한다.
```sql
-- IGNORE 키워드가 없으면 INSERT가 실패
INSERT INTO salaries VALUES (NULL, NULL, NULL, NULL);

-- IGNORE 키워드가 있으면 각 타입별 기본 값을 저장
INSERT IGNORE INTO salaries VALUES (NULL, NULL, NULL, NULL);
```

### 11.5.1.2 INSERT … ON DUPLICATE KEY UPDATE
INSERT IGNORE 문장은 중복이나 에러 발생 건에 대해서 모두 무시하지만, INSERT … ON DUPLICATE KEY UPDATE 문장은 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해준다.
```ad-tip
MySQL 서버의 REPLACE 문장도 비슷한 역할을 하지만 내부적으로는 DELETE와 INSERT 조합으로 작동한다.
```

```sql
INSERT INTO daily_statistic (target_date, stat_name, stat_value)
VALEUS (DATE(NOW(), 'VISIT', 1))
ON DUPLICATE KEY UPDATE stat_value=stat_value+1;
```
- stat_name이 최초로 저장되는 경우에는 INSERT문만 실행
- 해당 날짜의 집계 레코드가 존재한다면 ON DUPLICATE KEY UPDATE 절 실행

## 11.5.2 LOAD DATA 명령 주의 사항
일반적으로 RDBMS에서 데이터를 빠르게 적재할 수 있는 방법으로 `LOAD DATA` 명령이 자주 소개된다.
→ MySQL 서버의 LOAD DATA 명령도 내부적으로 MySQL 엔진과 스토리지 엔진의 호출 횟수를 최소화하고 스토리지 엔진이 직접 데이터를 적재하기 때문에 일반적인 INSERT 명령과 비교했을 때 매우 빠르다고 할 수 있다.
→ 하지만 MySQL 서버의 LOAD DATA 명령은 다음과 같은 단점이 있다.
- **단일 스레드로 실행**
	- 단일 스레드로 실행되기에 적재해야 할 데이터 파일이 크다면 시간이 매우 길어질 수 있다.
	- 테이블에 여러 인덱스가 있다면 레코드를 INSERT하고 인덱스 키 값도 INSERT 해야 하는데, 단일 스레드로 실행된다면 시간이 지날수록 INSERT 속도는 현저히 떨어진다.
- **단일 트랜잭션으로 실행**
	- LOAD DATA 문장은 하나의 트랜잭션으로 처리되기 때문에 해당 문장이 실행된 시점부터 언두 로그가 삭제되지 못하고 유지되어야 한다. 그러면 언두 로그를 디스크로 저장해야 하는 부하를 만들기도 한다.
	- 또한 언두 로그가 많이 쌓이면 쿼리들이 필요한 레코드를 찾는 데 더 많은 오버헤드를 만들어 내기도 한다.
	- 가능하다면 LOAD DATA 문장으로 적재할 데이터 파일은 하나보다는 여러 개의 파일로 준비해서 여러 트랜잭션으로 나눠 실행되게 하는 것이 좋다.

```ad-tip
테이블 간 데이터 복사 작업이라면 LOAD DATA 문장보다는 INSERT … SELECT … 문장으로 WHERE 조건절에서 데이터를 부분적으로 잘라서 효율적으로 INSERT할 수 있게 해주는 것이 좋다.
```

## 11.5.3 성능을 위한 구조

### 11.5.3.1 대량 INSERT 설능
하나의 INSERT 문장으로 수백 건, 수천 건의 레코드를 INSERT 한다면 INSERT될 레코드들을 프라이머리 키값 기준으로 이미 정렬해서 INSERT 문장을 구성하는 것이 성능에 좋을 수 있다.

테이블의 세컨더리 인덱스는 SELECT 성능을 높이지만, 반대로 INSERT 성능은 떨어진다.
→ 테이블에 세컨더리 인덱스가 많을수록, 그리고 테이블이 클수록 INSERT 성능을 떨어진다.
→ 하지만 세컨더리 인덱스도 정렬된 순서대로 INSERT 될 수 있다면 더 빠른 성능을 얻을 수 있다.

### 11.5.3.2 프라이머리 키 선정
InnoDB 스토리지 엔진을 사용하는 테이블의 프라이머리 키는 클러스터링 키인데, 이는 세컨더리 인덱스를 이용하는 쿼리보다 프라이머리 키를 이용하는 쿼리의 성능이 훨씬 빨라지는 효과를 낸다.
→ 그래서 프라이머리 키는 단순히 INSERT 성능만을 위해 설계해서는 안 된다.

대부분 온라인 트랜잭션 처리를 하는 테이블들은 쓰기보다는 읽기 쿼리의 비율이 압도적으로 높다.
→ SELECT는 거의 실행되지 않고 INSERT가 매우 많이 실행되는 테이블이라면 테이블의 프라이머리 키를 단조 증가 또는 단조 감소하는 패턴의 값을 선택하는 것이 좋다.

SELECT가 많지 않고 INSERT가 많은 테이블에 대해서는 인덱스의 개수를 최소화하는 것이 좋다.
→ 반대의 경우에는 쿼리에 맞게 필요한 인덱스들을 추가해도 시스템 전반적으로 영향도가 크지 않다.

## 11.5.3.3 Auto-Increment 컬럼
InnoDB 스토리지 엔진을 사용하는 테이블은 자동으로 프라이머리 키로 클러스터링된다.
→ 즉, 프라이머리 키로 클러스터링 되지 않게 InnoDB 테이블을 생성할 수 없다.
→ 하지만 자동 증가 컬럼을 이용하면 클러스터링되지 않는 테이블의 효과를 얻을 수 있다.

자동 증가 값을 프라이머리 키로 해서 테이블을 생성하는 것은 MySQL 서버에서 가장 빠른 INSERT를 보장하는 방법이다.
→ 거기에 세컨더리 인덱스가 하나도 없는 테이블이라면 최고이다.

MySQL 서버에서는 자동 증가 값의 채번을 위해서는 잠금이 필요한데, 이를 **AUTO-INC 잠금** 이라고 한다.
→ 이 잠금을 사용하는 방식을 변경할 수 있게, `innodb_autoinc_lock_mode` 라는 시스템 변수를 제공한다.
- innodb_autoinc_lock_mode = 0
	- 항상 AUTO-INC 잠금을 걸고 한 번에 1씩만 증가된 값을 가져온다.
	- 이는 MySQL 5.1 버전의 자동 증가 값 채번 방식인데, 이전 버전의 호환성 및 성능 비교 테스트 용도로만 사용하기 위해 남겨둔 것이다.
	- 서비스용 MySQL 서버에서는 이 방식을 사용할 필요가 없다.
- innodb_autoinc_lock_mode = 1
	- 단순히 레코드 한 건씩 INSERT 하는 쿼리에서는 잠금을 사용하지 않고 뮤텍스를 이용해 더 가볍고 빠르게 처리한다.
	- 하지만 여러 레코드를 하나의 INSERT 문장으로 하거나 LOAD DATA 명령으로 INSERT 하는 쿼리에서는 AUTO-INC 잠금을 걸고 필요한 만큼의 자동 증가 값을 한번에 가져와 사용한다.
	- 이 방식은 INSERT 순번대로 채번된 자동 증가 값은 일관되고, 자동 증가 값은 연속된 번호를 갖게 된다.
- innodb_autoinc_lock_mode = 2
	- LOAD DATA나 벌크 INSERT를 포함한 INSERT 계열의 문장을 실행할 때 더 이상 AUTO-INC 잠금을 사용하지 않는다.
	- 이때 자동 증가 값을 적당히 미리 할당받아서 처리할 수 있으므로 가장 빠른 방식이다.
	- 이 모드에서 채번된 번호는 단조 증가하는 유니크한 번호까지만 보장하며, INSERT 순서와 채번된 번호의 연속성은 보장하지 않는다.

MySQL 5.7 버전까지는 `innodb_autoinc_lock_mode` 의 기본값은 1이었지만, MySQL 8.0 버전부터는 기본값이 2로 변경됐다.
→ 이는 8.0 버전부터 복제의 바이너리 로그 포맷 기본값이 STATEMENT 에서 ROW로 변경됐기 때문이다.

자동 증가 값이 반드시 연속이어야 한다면 `innodb_autoinc_lock_mode`를 2보다는 1로 설정하는 것이 좋다.
→ 그러나, 0 혹은 1로 설정하더라도 시간이 지나면서 연속된 값에 빈 공간이 생길 가능성이 높다 (연속적인 것에 집착하지 말자.)