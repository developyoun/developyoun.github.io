---
title: 11.7 스키마 조작

categories:
- study

tags:
- database

toc: true
toc_sticky: true
toc_label: Contents
---

DBMS 서버의 모든 오브젝트를 생성하거나 변경하는 쿼리를 DDL (Data Definition Language)이라고 한다.
→ 스토어드 프로시저나 함수, DB나 테이블 등을 생성하거나 변경하는 대부분의 명령이 DDL에 해당한다.

## 11.7.1 온라인 DDL
MySQL 5.5 이전 버전까지는 서버에서 테이블의 구조를 변경하는 동안에는 다른 커넥션에서 DML을 실행할 수 없었다.
→ MySQL 8.0 버전으로 업그레이드되면서 대부분의 스키마 변경 작업은 MySQL 서버에 내장된 온라인 DDL 기능으로 처리가 가능해졌다.

### 11.7.1.1 온라인 DDL 알고리즘
온라인 DDL은 스키마를 변경하는 작업 도중에도 다른 커넥션에서 해당 테이블의 데이터를 변경하거나 조회하는 작업을 가능하게 해준다.
→ `ALGORITHM` 과 `LOCK` 옵션을 이용해 어떤 모드로 스키마 변경을 실행할지를 결정할 수 있다.

MySQL 서버에서는 `old_alter_table` 시스템 변수를 이용해 ALTER TABLE 명령이 온라인 DDL로 작동할지, 아니면 예전 방식으로 처리할지를 결정할 수 있다.
> 예전 방식이란, 테이블의 읽고 쓰기를 막고 스키마를 변경하는 방식을 의미한다.

→ MySQL 8.0 버전에서는 old_alter_table 시스템 변수를 기본값이 OFF로 설정돼 있기 때문에 자동으로 온라인 DDL이 활성화된다.
→ ALTER TABLE 명령을 실행하면 다음과 같은 순서로 스키마 변경에 적합한 알고리즘을 찾는다.
1. ALGORITHM=INSTANT 로 스키마 변경이 가능한지 확인 후, 가능하다면 선택
2. ALGORITHM=INPLACE 로 스키마 변경이 가능한지 확인 후, 가능다하면 선택
3. ALGORITHM=COPY 알고리즘 선택

스키마 변경 알고리즘의 우선순위가 낮을수록 MySQL 서버는 스키마 변경을 위해서 더 큰 잠금과 많은 작업을 필요로 하고 서버의 부하도 많이 발생시킨다.
- INSTANT
	- 테이블의 데이터는 전혀 변경하지 않고, 메타데이터만 변경하고 작업을 완료한다.
	- 테이블이 가진 레코드 건수와 무관하게 작업시간은 매우 짧다
	- 스키마 변경 도중 테이블의 읽고 쓰기는 대기하게 되지만 스키마 변경 시간이 매우 짧기 때문에 다른 커넥션의 쿼리 처리에는 크게 영향을 미치지 않는다.
- INPLACE
	- 임시 테이블로 데이터를 복사하지 않고 스키마 변경을 실행한다.
	- 내부적으로는 테이블의 리빌드를 실행할 수도 있다.
	- 레코드의 복사 작업은 없지만 테이블의 모든 레코드를 리빌드해야 하기 때문에 테이블의 크기에 따라 많은 시간이 소요될 수도 있다.
	- 스키마 변경 중에도 테이블의 읽기와 쓰기 모두 가능하다
	- 스키마가 변경되는 경우에도 최초 시작 시점과 마지막 종료 시점에는 테이블의 읽고 쓰기가 불가능하다.
	- 하지만 이 시간은 매우 짧기 때문에 다른 커넥션의 쿼리 처리에 대한 영향도는 높지 않다.
- COPY
	- 변경된 스키마를 적용한 임시 테이블을 생성하고, 테이블의 레코드를 모두 임시 테이블로 복사한 후 최종적으로 임시 테이블을 RENAME해서 스키마 변경을 완료한다.
	- 테이블 읽기만 가능하고 DML (INSERT, UPDATE, DELETE)은 실행할 수 없다.

온라인 DDL 명령은 알고리즘과 함께 잠금 수준도 함께 명시할 수 있다.
→ ALGORITHM과 LOCK 옵션이 명시되지 않으면 MySQL 서버가 적절한 수준의 알고리즘과 잠금 수준을 선택하게 된다.

온라인 DDL에서 INSTANT 알고리즘은 테이블의 메타데이터만 변경하기 때문에 매우 짧은 시간 동안의 메타데이터 잠금만 필요로 한다.
→ 그래서 INSTANT 알고리즘을 사용하는 경우에는 LOCK 옵션은 명시할 수 없다.
→ INPLACE나 COPY 알고리즘을 사용하는 경우 LOCK은 다음 3가지 중 하나를 명시할 수 있다.
- NONE: 아무런 잠금을 걸지 않음
- SHARED: 읽기 잠금을 걸고 스키마 변경을 실행하기 때문에 스키마 변경 중 읽기는 가능하지만, 쓰기는 불가함
- EXCLUSIVE: 쓰기 잠금을 걸고 스키마 변경을 실행하기 때문에 테이블의 읽고 쓰기는 불가함

INPLACE 알고리즘을 사용하는 경우 다음과 같이 구분할 수 있다.
- 데이터 재구성(테이블 리빌드)이 필요한 경우
	- 잠금을 필요로 하지 않기 때문에 읽고 쓰기는 가능하지만 여전히 테이블의 레코드 건수에 따라 상당히 많은 시간이 소요될 수 있다.
- 데이터 재구성(테이블 리빌드)이 필요치 않은 경우
	- INPLACE 알고리즘을 사용하지만 INSTANT 알고리즘과 비슷하게 매우 빨리 작업이 완료될 수 있다.

MySQL 서버의 온라인 DDL 기능은 버전별로 많은 차이가 있다.
→ 사용 중인 MySQL 서버의 버전이 8.0이 아니라면 사용 중인 버전의 MySQL 메뉴얼을 살펴보고 테이블 리빌드가 필요한지 확인 후 진행하는 것이 좋다.


### 11.7.1.2 온라인 처리 가능한 스키마 변경
MySQL 서버의 모든 스키마 변경 작업이 온라인으로 가능한 것이 아니기 때문에 필요한 스키마 변경 작업의 형태가 온라인으로 처리될 수 있는지, 아니면 테이블의 읽고 쓰기가 대기하게 되는지 확인한 후 실행하는 것이 좋다.
→ 변경 작업에 대한 가능한 작업은 p.169 ~ p.171 에서 확인 가능하다.

MySQL 서버에서 사용할 수 있는 스키마 변경 작업은 매우 다양하다
→ 이러한 경우에 `ALTER TABLE` 문장에 LOCK과 ALGORITHM 절을 명시해서 온라인 스키마 변경의 처리 알고리즘을 강제 할 수 있다.
→ 온라인 DDL 알고리즘을 강제한다고 해서 무조건 그 알고리즘으로 처리되는 것은 아니지만, 명시된 알고리즘으로 DDL이 처리되지 못한다면 단순히 에러만 발생시키고 스키마 변경 작업은 시작되지 않는다. (의도하지 않은 잠금과 대기는 발생하지 않음)

### 11.7.1.3 INPLACE 알고리즘
INPLACE 알고리즘은 임시 테이블로 레코드를 복사하지는 않더라도 내부적으로 테이블의 모든 레코드를 리빌드해야 하는 경우가 많다
→ 이런 경우 MySQL 서버는 다음과 같은 과정을 거치게 된다.
1. INPLACE 스키마 변경이 지원되는 스토리지 엔진의 테이블인지 확인
2. INPLACE 스키마 변경 준비 (스키마 변경에 대한 정보를 준비해서 온라인 DDL 작업 동안 변경되는 데이터를 추적할 준비)
3. 테이블 스키마 변경 및 새로운 DML 로깅
4. 로그 적용
5. INPLACE 스키마 변경 완료 (COMMIT)

INPLACE 알고리즘으로 온라인 스키마 변경이 진행되는 동안 새로 유입된 DML 쿼리들에 의해 변경되는 데이터를 “온라인 변경 로그” 라는 메모리 공간에 쌓아둔다
→ 온라인 스키마 변경이 완료되면 로그의 내용을 실제 테이블로 일괄 적용하게 된다.
→ 이때, 온라인 변경 로그는 디스크가 아니라 메모리에만 생성된다
→ 이 메모리 공간의 크기는 `innodb_online_alter_log_max_size` 시스템 변수에 의해 결정된다.

### 11.7.1.4 온라인 DDL의 실패 케이스
온라인 DDL이 INSTANT 알고리즘을 사용하는 경우 겅의 시작과 동시에 작업이 완료되기 때문에 작업 도중 실패할 가능성은 거의 없다.
그러나 INPLACE 알고리즘으로 실행되는 경우 내부적으로 테이블 리빌드 과정이 필요하고 최종 로그 적용 과정이 필요해서 중간 과정에서 실패할 가능성이 상대적으로 높은 편이다.
→ 온라인 DDL 명령은 다음과 같은 이유로 실패할수도 있다.
- ALTER TABLE 명령이 장시간 실행되고 동시에 다른 커넥션에서 DML이 많이 실행되는 경우이거나 온라인 변경 로그의 공간이 부족한 경우, 온라인 스키마 변경 작업은 실패
- ALTER TALBE 명령이 실행되는 동안 ALTER TABLE 이전 버전의 테이블 구조에서는 아무런 문제가 안 되지만 ALTER TABLE 이후의 테이블 구조에는 적합하지 않은 레코드가 INSERT 되거나 UPDATE되었다면 온라인 스키마 변경 작업은 마지막 과정에서 실패
- 스키마 변경을 위해서 필요한 잠금 수준보다 낮은 잠금 옵션이 사용된 경우
- 온라인 스키마 변경은 LOCK=NONE으로 실행된다고 하더라도 변경 작업의 처음과 마지막 과정에서 잠금이 필요한데, 이 잠금을 획득하지 못하고 타음 아웃이 발생하면 실패
- 온라인으로 인덱스를 생성하는 작업의 경우 정렬을 위해 tmpdir 시스템 변수에 설정된 디스크의 임시 디렉터리를 사용하는데, 이 공간이 부족한 경우 또한 로안인 변경은 실패함

### 11.7.1.5 온라인 DDL 진행 상황 모니터링
온라인 DDL을 포함한 모든 ALTER TABLE 명령은 MySQL 서버의 `performance_schema`를 통해 진행 상황을 모니터링 할 수 있다.
→ performance_schema를 이용해 ALTER TABLE의 진행 상황을 모니터링하려면 performance_schema 옵션이 활성화돼야 한다.
```sql
SET GLOBAL performance_schema=ON;
```

스키마 변경 작업의 진행 상황은 performance_schema.events_stages_current 테이블을 통해 확인할 수 있다.

## 11.7.2 데이터베이스 변경
MySQL에서 하나의 인스턴스는 1개 이상의 데이터베이스를 가질 수 있다.
→ 다른 RDBMS에서는 스키마와 데이터베이스를 구분해서 관리하지만, MySQL 서버에서는 스키마와 데이터베이스는 동격의 개념이다.

### 11.7.2.1 데이터베이스 생성
```sql
-- 1
CREATE DATABASE [IF NOT EXISTS] employees;
-- 2
CREATE DATABSAE [IF NOT EXISTS] employees CHARACTER SET utf8mb4;
-- 3
CREATE DATABASE [IF NOT EXISTS] employees CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
```
- 첫 번째 명령은 기본 문자 집합과 콜레이션으로 데이터베이스를 생성한다.
	- 여기서 기본은 MySQL 서버의 character_set_server 시스템 변수에 정의된 문자 집합을 사용한다는 의미다.
- 두 번째와 세 번째 명령은 별도의 문자 집합과 콜레이션이 지정된 데이터베이스를 생성한다.

### 11.7.2.2 데이터베이스 목록
```sql
SHOW DATABASES;
SHOW DATABASES LIKE '%emp%';
```
접속된 MySQL 서버가 가지고 있는 데이터베이스의 목록을 나열한다.
→ 단, 권한을 가지고 있는 데이터베이스의 목록만 표시하며, 이 명령을 실행하려면 `SHOW DATASES` 권한이 있어야 한다.

### 11.7.2.3 데이터베이스 선택
```sql
USE employees;
```
기본 데이터베이스를 선택하는 명령이다.
→ SQL 문장에서 별도로 데이터베이스를 명시하지 않고 테이블 이름이나 프로시저의 이름만 명시하면 MySQL 서버는 현재 커넥션의 기본 데이터베이스에서 주어진 테이블이나 프로시저를 검색한다.
→ 기본 데이터베이스에 존재하지 않는 테이블이나 프로시저를 사용하려면 다음과 같이 테이블이나 프로시저의 이름 앞에 데이터베이스 이름을 반드시 명시해야 한다.
```sql
SELECT * FROM employees.departments;
```

### 11.7.2.4 데이터베이스 속성 변경
```sql
ALTER DATABASE employees CHARACTER SET=euckr;
ALTER DATABASE employees CHARACTER SET=euckr COLLATE=euckr_korean_ci;
```
데이터베이스를 생성할 때 지정한 문자 집합이나 콜레이션을 변경한다.

### 11.7.2.5 데이터베이스 삭제
```sql
DROP DATABASE [IF EXISTS] employees;
```
데이터베이스를 삭제한다.

## 11.7.3 테이블 스페이스 변경
MySQL 서버에는 전통적으로 테이블별로 전용의 테이블 스페이스를 사용했었다.
→ InnoDB 스토리지 엔진의 시스템 테이블 스페이스만 제너럴 테이블스페이스를 사용했다.
→ 제너럴 테이블스페이스는 여러 테이블의 데이터를 한꺼번에 저장하는 테이블스페이스를 의미한다.

MySQL 8.0 버전이 되면서 MySQL 서버에서도 사용자 테이블을 제너럴 테이블스페이스로 저장하는 기능이 추가되고 테이블스페이스를 관리하는 DDL 명령등이 추가됐다.
→ 그러나, MySQL 8.0에서도 제너럴 테이블스페이스는 여러 가지 제약 사항을 가진다.
- 파티션 테이블은 제너럴 테이블스페이스를 사용하지 못함
- 복제 소스와 레플리카 서버가 동일 호스트에서 실행되는 경우 ADD DATAFILE 문장은 사용 불가
- 테이블 암호화(TDE)는 테이블스페이스 단위로 설정됨
- 테이블 압축 기능 여부는 테이블스페이스의 블록 사이즈와 InnoDB 페이지 사이즈에 의해 결정됨
- 특정 테이블을 삭제(DROP TABLE)해도 디스크 공간이 운영체제로 반납되지 않음

하지만 MySQL 8.0에서 사용자 테이블이 제너럴 테이블스페이스를 이용할 수 있게 개선된 것은 다음과 같은 장점이 있다.
- 제너럴 테이블스페이스를 사용하면 파일 핸들러(Open file descriptor)를 최소화
- 테이블스페이스 관리에 필요한 메모리 공간을 최소화

제너럴 테이블스페이스가 가진 장점은 테이블의 개수가 매우 많은 경우에 유용하다.
→ 하지만 아직 일반적인 환경에서 제너럴 테이블스페이스의 장점은 취하기가 어렵다.
→ MySQL 서버에서 테이블이 개별 테이블스페이스를 사용할지 아니면 제너럴 테이블스페이스를 사용할지는 `innodb_file_per_table` 시스템 변수로 제어할 수 있음
→ 해당 시스템 변수의 기본값이 ON 이므로 테이블은 자동으로 개별 테이블스페이스를 사용한다.

## 11.7.4 테이블 변경

### 11.7.4.1 테이블 생성
테이블을 생성은 `CREATE TABLE` 로 가능하며, `TEMPORARY` 키워드를 사용하면 래당 데이터베이스 서넥션에서만 사용 가능한 임시 테이블을 생성한다.
→ 테이블 생성시 이미 같은 이름의 테이블이 있으면 에러가 발생하는데, `IF NOT EXISTS` 옵션을 사용하면 에러를 무시한다.
→ MySQL은 `ENGINE` 이라는 키워드로 사용할 스토리지 엔진을 결정할 수 있다. (기본은 InnoDB)
→ 각 컬럼은 “컬럼명 + 컬럼타입 + 타입별 옵션 + NULL 여부 + 기본값” 순서로 명시하며 타입별로 옵션을 추가로 사용할 수 있다.
- 모든 컬럼은 공통적으로 컬럼의 초깃값을 설정하는 DEFAULT 절과 컬럼이 NULL을 가질 수 있는지 여부를 설정하기 위해 NULL 또는 NOT NULL 제약을 명시할 수 있다.
- 문자열 타입은 타입 뒤에 반드시 컬럼에 최대한 저장할 수 있는 문자 수를 명시해야 한다.
- 숫자 타입은 선택적으로 길이를 가질 수 있지만, 이는 단순히 값을 표시할 때 보여줄 길이를 지정하는 것이다.
- MySQL 5.6 버전부터 DATE와 DATETIME 그리고 TIMESTAMP 타입 모두 값이 자동으로 현재 시간으로 업데이트되도록 기본 값을 명시할 수 있다.
- ENUM 또는 SET 타입은 이름 귀에 해당 컬럼이 가질 수 있는 값을 괄호로 정의해야 한다.

### 11.7.4.2 테이블 구조 조회
MySQL에서 테이블의 구조를 확인하는 방법은 `SHOW CREATE TABLE` 명령과 `DESC` 명령으로 구 가지가 있다.
- **SHOW CREATE TABLE**
	- 해당 명령을 사용하면 테이블의 CREATE TABLE 문장을 표시
	- 하지만, 명령의 결과가 최초 테이블을 생성할 때 사용자가 실행한 내용을 그대로 보여주는 것이 아닌, 테이블의 메타 정보를 읽어서 CREATE TABLE 명령으로 재작성해서 보여주는 것
	- 이 명령은 특별한 수정 없이 바로 사용할 수 있기에 상당히 유용하다.
	- 명령 실행시, 컬럼의 목록과 인덱스, 외래키 정보를 동시에 보여주기 때문에 SQL을 튜닝하거나 테이블의 구조를 확인할 때 주로 이 명령을 사용한다.
- **DESC**
	- DESCRIBE의 약어 형태의 명령으로 둘 모두 같은 결과를 보여준다.
	- 테이블의 컬럼 정보를 보기 편한 표 형태로 표시해준다.
	- 하지만 인덱스 컬럼의 순서나 외래키, 테이블 자체의 속성을 보여주지는 않으므로 테이블의 전체적인 구조를 한 번에 확인하기는 어렵다.

### 11.7.4.3 테이블 구조 변경
테이블의 구조를 변경하려면 ALTER TABLE 명령을 사용한다.
→ ALTER TABLE 명령은 테이블 자체의 속성을 변경할 수 있을뿐만 아니라 인덱스의 추가 삭제나 컬럼을 추가/삭제하는 용도로도 사용된다.
→ 해당 명령은 테이블 자체 옵션과 컬럼, 인덱스 등 거의 대부분의 스키마를 변경하는 작업에 사용된다.

```ad-tip
책에 예제를 통해서 테이블 구조 변경하는 과정을 확인할 수 있다.
```

### 11.7.4.4 테이블 명 변경
MySQL 서버에서 테이블명을 변경하려면 `RENAME TABLE` 명령을 이용하면 된다.
→ RENAME TABLE 명령은 단순히 테이블의 이름 변경뿐만 아니라 다른 데이터베이스로 테이블을 이동할 때도 사용할 수 있다.

```sql
-- 1
RENAME TABLE table1 TO table2;
RENAME TABLE db1.table1 TO db2.table2;
```
- 첫 번째 명령과 같이 동일 데이터베이스 내에서 테이블의 이름만 변경하는 작업은 단순히 메타 정보만 변경하기 때문에 매우 빠르게 처리된다.
- 두 번째 명령과 같이 데이터베이스를 변경하는 경우에는 메타 정보뿐만 아니라 테이블 저장된 파일까지 다른 디렉토리로 이동해야 한다.
	- 여기서 db1에서 db2로 이동할 때 서로 다른 운영체제의 파일 시스템을 사용하고 있다면 데이터 파일의 복사 작업이 필요하기 때문에 데이터 파일의 크기에 비례해서 시간이 소요될 것이다.

MySQL 서버의 RENAME TABLE 명령은 여러 테이블의 RENAME 명령을 하나의 문장으로 묶어서 실행할 수 있다.
```sql
RENAME TABLE batch TO batch_old, batch_new TO batch;
```
- 여러 테이블의 RENAME 명령을 하나의 문장으로 묶으면 MySQL 서버는 RENAME TABLE 명령에 명시된 모든 테이블에 대해 잠금을 걸고 테이블의 이름 변경 작업을 실행한다.

### 11.7.4.5 테이블 상태 조회
MySQL의 모든 테이블은 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기 등의 정보를 가지고 있다.
→ 이러한 정보를 조회할 수 있나는 명령어로 `SHOW TABLE STATUS ...` 가 있다.
→ SHOW TABLE STATUS 명령은 "LIKE 패턴" 과 같은 조건을 사용해 특정 테이블의 상태만 조회하는 것도 가능하다.

테이블 상태 정보를 알 수 있는 또다른 방법은 SELECT 쿼리를 이용하는 방법이다.
```sql
SELECT * FROM information_schema.TABLES
WHERE TABLE_SCHEMA='employees' AND TABLE_NAME='employees' \G
```
- information_schema 데이터베이스에는 MySQL 서버가 가진 스키마들에 대한 메타 정보를 가진 딕셔너리 테이블이 관리된다.
- information_schema에 존재하는 테이블들은 실제로 존재하는 테이블이 아닌, MySQL 서버가 시작되면서 다양한 메타 정보를 수집하여 메모리에 모아두고 사용자가 참조할 수 있는 테이블이다.

### 11.7.4.6 테이블 구조 복사
테이블의 구조는 같지만 이름만 다른 테이블을 생성할 때는 `SHOW CREATE TABLE` 명령을 이용해 테이블의 생성 DDL을 조회한 후에 조금 변경해서 만들 수도 있다.
→ 그러나 해당 명령을 사용하면 내용을 조금 변경해야 할 수도 있다.

`CREATE TABLE ... AS SELECT ... LIMIT 0` 명령으로 테이블을 생성할 수도 있다.
→ 하지만 인덱스가 생성되지 않는 다는 단점이 있다.

데이터는 복사하지 않고 테이블의 구조만 동일하게 복사하는 명령으로 `CREATE TABLE ... LIKE` 를 사용하면 구조가 같은 테이블을 손쉽게 생성할 수 있다.
```sql
CREATE TABLE temp_employees LIKE employees;
```

만약 데이터까지 복사하려면 다음과 같은 명령을 사용할 수 있다.
```sql
INSERT INTO temp_employees SELECT * FROM employees;
```

### 11.7.4.7 테이블 삭제
일반적으로 MySQL에서 레코드가 많지 않은 테이블을 삭제하는 작업은 서비스 도중이라고 하더라도 문제가 되지 않는다.
→ MySQL 8.0 버전에서는 특정  테이블을 삭제하는 작업이 다른 테이블의 DML이나 쿼리를 직접 방해하지는 않는다.
```sql
DROP TABLE [IF EXIST] table1;
```

하지만 용량이 매우 큰 테이블을 삭제하는 작업은 상당히 부하가 큰 작업에 속한다.
→ 테이블이 삭제되려면 MySQL 서버는 해당 테이블이 사용하던 데이터 파일을 삭제해야 한다
→ 이 파일의 크기가 매우 크고 디스크에서 파일의 조각들이 너무 분산되어 저장돼 있다면 디스크 읽고 쓰기 작업이 필요하다.
→ 디스크 읽고 쓰기 부하가 높아지면 다른 커넥션의 쿼리 처리 성능이 떨어질 수도 있다.
→ 결론적으로, 테이블이 크다면 서비스 도중에 삭제 작업은 수행하지 않는 것이 좋다.

테이블 삭제에서 한 가지 더 주의해야 하는 것은 InnoDB 스토리지 엔진의 어댑티브 해시 인덱스이다.
→ 어댑티브 해시 인덱스는 InnoDB 버퍼 풀의 각 페이지가 가진 레코드에 대한 해시  인덱스 기능을 제공하는데, 오댑티브 해시 인덱스가 활성화 되어 있는 경우 테이블이 삭제되면 어댑치브 해시 인덱스 정보도 모두 삭제해야 한다.

## 11.7.5 컬럼  변경
### 11.7.5.1 컬럼 추가
MySQL 8.0 버전으로 업그레이드되면서 테이블의 컬럼 추가 작업은 대부분 INPLACE 알고리즘을 사용하는 온라인 DDL로 처리가 가능하다.
→ 컬럼을 테이블의 제일 마지막 컬럼으로 추가하는 경우에는  INSTANT 알고리즘으로 즉시 추가된다
```sql
-- 1
ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20), ALGORITHM=INSTANT
-- 2
ALTER TABLE employees ADD COLUMN emp_telno VARCHAR(20) AFTER emp_no, ALGORITHM=INPLACE, LOCK=NONE;
```
- 첫 번째 DDL 문장은 테이블의 마지막에 새로운 컬럼을 추가하므로 INSTANT 알고리즘으로 즉시 추가가 가능하다.
- 두 번째 DDL 문장은 기존 컬럼 중간에 새로 추가하기 때문에 테이블의 리빌드가 필요하다.

### 11.7.5.2 컬럼 삭제
컬럼을 삭제하는 작업은 항상 테이블의 리빌드를 필요로 하기 때문에 INSTANT 알고리즘을 사용할 수 없고, INPLACE 알고리즘으로만 삭제가 가능하다.
```sql
ALTER TABLE employees DROP COLUMN emp_telno, ALGORITHM=INPLACE, LOCK=NONE
```
- 위 문장에서 COLUMN 키워드는 입력하지 않아도 무방하다.

### 11.7.5.3 컬럼 이름 및 컬럼 타입 변경
```sql
-- 컬럼의 이름 변경
ALTER TABLE salaries CHANGE to_date end_date DATE NOT NULL, ALGORITHM=INPLACE, LOCK=NONE

-- INT 타입을 VARCHAR 타입으로 변경
ALTER TABLE salaries MODIFY salary VARCHAR(20), ALGORITHM=COPY, LOCK=SHARED

-- VARCHAR 타입의 길이 확장
ALTER TABLE employees MODIFY last_name VARCHAR(30) NOT NULL, ALGORITHM=INPLACE, LOCK=NONE

-- VARCHAR 타입의 길이 축소
ALTER TABLE employees MODIFY last_name VARCHAR(10) NOT NULL ALGORITHM=COPY, LOCK=SHARED;
```

아마도 컬럼의 타입을 변경하는 경우 중 가장 빈번한 경우가 VARCHAR나 VARBINARY 타입의 길이를 확장하는 것일 것이다.
→ 해당 타입의 최대 허용 사이즈는 메타데이터에 저장되지만 실제 컬럼이 가지는 값의 길이는 데이터 레코드의 컬럼 헤더에 저장된다.
→ 즉, 컬럼 값이 길이 저장용 공간은  컬럼의 값이 최대 가질 수 있는 바이트 수가 255이하인 경우 1바이트만 사용하며, 256 바이트 이상인 경우, 2바이트를 사용한다.

## 11.7.6 인덱스 변경
MySQL 8.0 버전에서는 대부분의 인덱스 변경 작업이 온라인 DDL로 처리 가능하도록 개선되었다.

### 11.7.6.1 인덱스 추가
전문 검색을 위한 인덱스와 공간 검색을 위한 인덱스는 INPLACE 알고리즘으로 인덱스 생성이 가능하지만, SHARED 잠금이 필요하다
나머지 B-Tree 자료 구조를 사용하는 인덱스의 추가는 프라이머리 키라고 하더라도 INPLACE 알고리즘에 잠금 없이 온라인으로 인덱스 생성이 가능하다.

### 11.7.6.2 인덱스 조회
MySQL 서버에서 인덱스의 목록을 조회할 때는 `SHOW INDEXES` 명령을 사용하거나 `SHOW CREATE TABLE` 명령으로 표시되는 테이블 생성 명령을 참조할 수 있다.
- **SHOW INDEXES**
	- 테이블의 인덱스만 표시하는 명령어
	- key_name: 인덱스 이름
	- seq_in_index: 인덱스에서 해당 컬럼의 위치
	- cardinality: 인덱스에서 해당 컬럼까지의 유니크한 값의 개수
- **SHOW CREATE TABLE**
	- 테이블의 생성 구문을 그대로 표시
	- 인덱스와 함께 테이블의 모든 컬럼을 표시하기 때문에 장황해 보일 수 있음
	- 인덱스별로 한 줄로 표시하기 때문에 어떤 인덱스가 있는지, 인덱스의 컬럼이 어떤 순서로 구성되어 있는 파악할 수 있음

### 11.7.6.3 인덱스 이름 변경
MySQL 5.6 버전까지 인덱스의 이름을 변경할 수 있는 방법은 없었다
→ 하지만 MySQL 5.7 버전부터는 인덱스의 이름을 변경할 수 있게 됐다.
```sql
ALTER TABLE salaries RENAME INDEX ix_salary TO ix_salary2,
ALGORITHM=INPLACE, LOCK=NONE;
```

인덱스의 이름을 변경하는 작업은 INPLACE 알고리즘을 사용하지만 실제 테이블 리빌드를 필요로 하지 않는다.
→ 응용 프로그램에서 힌트로 해당 인덱스의 이름을 사용 중이라고 하더라도 짧은 시간에 인덱스를 교체할 수 있게 됐다.

```sql
-- 1. index_new라는 이름으로 새로운 인덱스 생성
ALTER TABLE employees
ADD INDEX index_new (first_name, last_name),
ALGORITHM=INPLACE, LOCK=NONE;

-- 2. 기존 인덱스(ix_firstname)를 삭제하고, 동시에 새로운 인덱스(index_new)의 이름을 ix_firstname으로 변경
ALTER TABLE employees
DROP INDEX ix_firstname,
RENAME INDEX index_new TO ix_firstname,
ALGORITHM=INPLACE, LOCK=NONE;
```

### 11.7.6.4 인덱스 가시성 변경
MySQL 서버에서 인덱스를 삭제하는 작업은 `ALTER TABLE DROP INDEX` 명령으로 즉시 완료되지만, 한 번 삭제된 인덱스를 새로 생성하는 것은 매우 많은 시간이 걸릴 수도 있다.
→ 데이터베이스 서버의 인덱스는 한 번 생성되면 서의 삭제하지 못하는 경우가 많다.

MySQL 8.0 버전부터는 인덱스의 가시성을 제어할 수 있는 기능이 도입됐다.
> 인덱스의 가시성이란, MySQL 서버가 쿼리를 실행할 때 해당 인덱스를 사용할 수 있게 할지 말지를 결정하는 것.

```sql
-- 1. 특정 인덱스가 사용되지 못하게 함
ALTER TABLE employees ALTER INDEX ix_firstname INVISIBLE;

-- 2. 특정 인덱스를 사용할 수 있게 하꿈
ALTER TABLE employees ALTER INDEX ix_firstname INVISIBLE;
```

최초 인덱스를 생성할 때도 가시성을 설정할 수 있다.
```sql
ALTER TABLE employees ADD INDEX ix_firstname_lastname (first_name, last_name) INVISIBLE;
```

위의 조합을 적절히 사용하면, 인덱스를 생성하고 삭제하는 작업을 하지 않고도 쿼리가 인덱스를 사용할지 말지를 변경할 수 있다.

```ad-tip
MySQL 서버의 optimizer_switch 시스템 변수에 use_invisible_indexes 옵션이 ON으로 설정된 경우,
MySQL 옵티마이저는 쿼리가 INVISIBLE 상태의 인덱스도 사용할 수 있게 한다. (기본값은 OFF)
```

### 11.7.6.4 인덱스 삭제
`ALTER TABLE … DROP INDEX …` 명령으로 인덱스를 삭제할 수 있다
→ MySQL 서버의 인덱스 삭제는 일반적으로 매우 빨리 처리된다.
→ 세컨더리 인덱스 삭제 작업은 INPLACE 알고리즘을 사용하지만 실제 테이블 리빌드를 필요로 하지 않는다.
→ 프라이머리 키의 삭제 작업은 모든 세컨더리 인덱스의 리프 노드에 저장된 프라이머리 키를 삭제해야 하기 때문에 임시 테이블로 레코드를 복사해서 테이블을 재구축해야 한다.

```ad-note
- 프라이머리 키 삭제는 COPY 알고리즘을 사용해야 한다.
- PK 삭제 도중에는 쓰기 불가능한 SHARED 모드 잠금이 필요하다.
```

## 11.7.7 테이블 변경 묶음 실행
온라인 DDL로 빠르게 스키마 변경을 처리할 수 있다면 개별로 실행하는 것이 좋지만, 그렇지 않다면 모아서 실행하는 것이 효율적이다.
```sql
-- 1
ALTER TABLE employees ADD INDEX ix_lastname (last_name, first_name),
ALGORITHM=INPLACE, LOCK=NONE;

-- 2
ALTER TABLE employees ADD INDEX ix_brithdate (birth_date)
ALGORITHM=INPLACE, LOCK=NONE;
```
- 2개의 ALTER TABLE 명령으로 인덱스를 각각 생성하면 인덱스를 생성할 때마다 테이블의 레코드를 풀스캔해서 인덱스를 생성하게 된다.

```sql
ALTER TABLE employees
ADD INDEX ix_lastname (last_name, first_name),
ADD INDEX ix_birthdate (birth_date),
ALGORITHM=INPLACE, LOCK=NONE;
```
- 하나의 ALTER TABLE 명령으로 모아서 실행하면 MySQL 서버는 테이블의 레코드를 한 번만 풀 스캔해서 2개의 인덱스를 한꺼번에 생성할 수 있게 된다.

2개의 스키마 변경 작업이 하나는 INSTANT 알고리즘을 사용하고, 다른 하나는 INPLACE 알고리즘을 사용한다면 굳이 모아서 실행할 필요는 없다.
→ 가능하면 같은 알고리즘을 사용하는 스키마 변경 작업을 모아서 실행하는 것이 효율적이다.

## 11.7.8 프로세스 조회 및 강제 종료
MySQL 서버에 접속된 사용자의 목록이나 각 클라이언트 사용자가 어떤 쿼리를 실행하고 있는지는 `SHOW PROCESSLIST` 명령으로 확인할 수 있다.
- **Id**: MySQL 서버의 스레드 아이디, 쿼리나 커넥션을 강제 종료할 떄는 이 컬럼값을 식별자로 사용
- **User**: 클라이언트가 서버에 접속할 때 인증에 사용한 사용자 계정을 의미
- **Host**: 클라이언트의 호스트명이나 IP 주소 표시
- **db**: 클라이언트가 기본으로 사용하는 데이터베이스의 이름
- **Command**: 해당 스레드가 현재 어떤 작업을 처리하고 있는지 표시
- **Time**: Command 컬럼에 표시되는 작업이 얼마나 실행되고 있는지 표시
- **State**: 소분류 작업 내용을 표시, 이 컬럼에 표시될 수 있는 내용은 상당히 많음
- **Info**: 해당 스레드가 실행 중인 쿼리 문장을 표시

## 11.7.9 활성 트랜잭션 조회
MySQL 서버의 트랜잭션 목록은 `information_schema.innodb_trx` 테이블을 통해 확인할 수 있다.

장시간에 걸쳐 트랜잭션이 쿼리를 실행 중인 상태에서 그 쿼리만 강제 종료시키면 커넥션이나 트랜잭션은 여전히 활성 상태로 남아있게 된다.
→ 응용 프로그램에서 쿼리의 에러를 감지해서 트랜잭션을 롤백하게 돼 있다면 특정 쿼리만 종료하면 된다.

