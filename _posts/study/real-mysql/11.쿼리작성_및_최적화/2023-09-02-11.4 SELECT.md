---
title: 11.4 SELECT

categories:
- study

tags:
- database

toc: true
toc_sticky: true
toc_label: Contents
---

```ad-note
SELECT 쿼리는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 한다.
하나의 어플리케이션에서 사용되는 쿼리 중에서도 SELECT 쿼리의 비율은 높다.
```
## 11.4.1 SELECT 절의 처리 순서

```sql
SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt
FROM salaries s
	INNER JOIN employees e ON e.emp_no=s.emp_no
WHERE s.emp_no IN (100001, 100002)
GROUP BY s.emp_no
HAVING AVG(s.salary) > 1000
ORDER BY AVG(s.salary)
LIMIT 10;
```
- SELECT 절: `SELECT s.emp_no, COUNT (DISTINCT e.first_name AS cnt`
- FROM 절: `salaries s INNER JOIN employees e ON e.emp_no=s.emp_no`
- WHERE 절: `s.emp_no IN (10000, 100002)`
- GROUP BY 절: `GROUP BY s.emp_no`
- HAVING 절: `HAVING AVG (s.salary) > 1000`
- ORDER BY 절: `ORDER BY AVG(s.salary)`
- LIMIT 절: `LIMIT 10`

일반적으로 쿼리의 순서는 아래와 같다
```
드라이빙 테이블 -> 드리븐 테이블과 WHERE 적용 및 조인 실행 -> GROUP BY -> DISTINCT -> HAVING 조건 적용 -> ORDER BY -> LIMIT
```

예외적인 순서로 실행되는 순서도 있다. 주로 GROUP BY 절이 없이 ORDER BY 만 사용된 쿼리에서 볼 수 있다.
```
드라빙 테이블 -> WHERE 적용 -> ORDER BY -> 드리븐 테이블 조인 실행 -> LIMIT
```

만약 실행 순서를 벗어나는 쿼리가 필요하다면 서브쿼리로 작성된 *인라인 뷰(Inline View)* 를 사용해야 한다.

> MySQL의 LIMIT은 오라클의 ROWNUM과 조금 성격이 달라서 WHERE 조건으로 사용하지 않고 항상 모든 처리의 결과에 대해 레코드 건수를 제한하는 형태로 사용한다.

MySQL 8.0에 새로 도입된 `WITH` 절(CTE, Common Table Expression)은 항상 제일 먼저 실행되어 임시 테이블로 저장된다.
→ 또한 WITH 절로 만들어진 임시 테이블은 단독으로 조회되거나 조인되는 테이블로 활용된다.

## 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙
WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 기본적으로 인덱스된 컬럼의 값 자체를 변환하기 않고 그대로 사용한다는 조건을 만족해야 한다.
→ 즉, 인덱스가 salary 컬럼으로 만들어져 있는데, 다음과 같은 예제의 WHERE 절과 같이 salary 컬럼을 가공한 후 다른 상숫값과 비교한다면 이 쿼리는 인덱스를 적절히 이용하지 못한다.
```sql
SELECT * FROM salaries WHERE salary * 10 > 150000;
```

→ 하지만 다음과 같이 변경해서 검색하게 유도할 수 있지만, 옵티마이저에서는 인덱스를 최적으로 이용할 수 있게 표현식을 변환하지는 못한다.
```sql
SELECT * FROM salaries WHERE salary > 150000/10;
```

→ **결론적으로 인덱스의 컬럼을 변형해서 비교하는 경우에는 인덱스를 이용할 수 없게 된다.**

> 추가로, WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다.
> 만약, 타입이 다를 때는 옵티마이저가 내부적으로 문자열 타입을 강제적으로 변경해서 비교하는 작업을 처리하기 때문에 인덱스 풀 스캔으로 동작할 수 있다.

### 11.4.2.2 WHERE 절의 인덱스 사용
WHERE 조건이 인덱스를 사용하는 방법은 크게 *작업 범위 결정 조건*과 *체크 조건*의 두 가지 방식으로 구분할 수 있다.
→ WHERE 조건절에 나열된 순서가 인덱스와 다르더라도 MySQL 서버 올티마이저는 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 수행할 수 있다.

MySQL 8.0 이전 버전까지는 하나의 인덱스를 구성하는 각 컬럼의 정렬 순서가 혼합되어 사용할 수 없었다
MySQL 8.0 버전부터는 인덱스를 구성하는 컬럼별로 정순과 역순 정렬을 혼합해서 생성할 수 있게 개선되었다.
```sql
ALTER TABLE ... ADD INDEX ix_col1234 (col_1 ASC, col_2 DESC, col_3 ASC, col_4 ASC)
```

WHERE 조건이 OR 연산자로 이어져 있으면 처리 방법이 완전히 바뀐다.
```sql
SELECT *
FROM employees
WHERE first_name='Kebin' OR last_name='Poly'
```
- 위의 쿼리에서 first_name=‘Kebin’ 조건은 인덱스를 사용할 수 있지만 last_name=‘Poly’는 인덱스를 사용할 수 없다.
- OR 연산자로 연결됐기 때문에 옵티마이저는 풀 테이블 스캔을 선택할 수 밖에 없다. (풀테이블 스캔 + 인덱스 레인지 스캔 보다는 풀 테이블 스캔 한번이 빠르다)
- 만약 first_name과 last_name 컬럼에 각각 인덱스가 있다면 index_merge로 진행할 수 있다.

### 11.4.2.3 GROUP BY 절의 인덱스 사용
GROUP BY 절에 명시된 컬럼의 순서가 인덱스를 구성하는 컬럼의 순서와 같으면 GROUP BY 절은 일단 인덱스를 이용할 수 있다.
- GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 위치가 같아야 한다.
- 인덱스를 구성하는 컬럼 중에서 뒤쪽에 있는 컬럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 컬럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
- WHERE 조건절과는 달리 GROUP BY 절에 명시된 컬럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다.

### 11.4.2.4 ORDER BY 절의 인덱스 사용
MySQL에서 GROUP BY와 ORDER BY의 처리 방법은 상당히 비슷하고, 인덱스 사용 여부 또한 매우 흡사하다.
→ 그러나 ORDER BY 는 조건이 하나 더 있는데, 정렬되는 각 컬럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다는 것이다.
→ MySQL의 인덱스는 모든 컬럼이 오름차순으로만 정렬돼 있기 때문에 ORDER BY 절의 모든 컬럼이 오름차순이거나 내림차순일 때만 인덱스를 사용할 수 있다.

### 11.4.2.5 WHERE 조건과 ORDER BY(또는 GROUP BY) 절의 인덱스 사용
WHERE 절과 ORDER BY 절이 같이 사용된 하나의 쿼리 문장은 다음 3가지 중 한 가지 방법만으로만 인덱스를 이용한다.
- **WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용**
	- WHERE 절의 비교 조건에서 사용하는 컬럼과 ORDER BY 절의 정렬 대상 컬럼이 모두 하나의 인덱스에 연속해서 포함돼 있을 때 이 방식으로 인덱스를 사용할 수 있다.
	- 이 방법은 나머지 2가지 방식보다 훨씬 빠른 성능을 보이기 때문에 가능하다면 이 방식으로 처리할 수 있게 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.
- **WHERE 절만 인덱스를 이용**
	- ORDER BY 절은 인덱스를 이용한 정렬이 불가능하며, 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리 과정(Using Filesort)를 거쳐 정렬을 수행한다.
	- 주로 이 방법은 WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적인 방식이다.
- **ORDER BY 절만 인덱스를 이용**
	- ORDER BY 절은 인덱스를 이용해 처리하지만 WHERE 절은 인덱스를 이용하지 못한다.
	- 이 방식은 ORDER BY 절의 순서대로 인덱스를 읽으면 레코드 한 건씩 WHERE 절의 조건이 일치하는지 비교하고, 일치하지 않을 때는 버리는 형태로 처리한다.
	- 주로 아무 많은 레코드를 조회해서 정렬해야 할 때는 이런 형태로 튜닝하기도 한다.

WHERE 절에 동등 비교 조건으로 사용된 컬럼과 ORDER BY 절의 컬럼이 중첩되는 부분은 인덱스를 사용할 때 문제가 되지않지만, 중간에 빠지는 컬럼이 있으면 둘 다 인덱스를 사용할 수 없다.
→ 이때는 주로 WHERE 절만 인덱스를 이용할 수 있다.

> WHERE절과 ORDER BY이나 GROUP BY절의 조합에서 인덱스의 사용 여부를 판단하는 능력은 상당히 중요하므로 여러 가지 경우에 대해 직접 테스트해보는 것이 좋다.

### 11.4.2.6 GROUP BY 절과 ORDER BY 절의 인덱스 사용
GROUP BY와 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 두 절에 명시된 컬럼의 순서와 내용이 모두 같아야 한다.
→ 이 두개가 같이 사용된 쿼리에서 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다.

> MySQL 5.7 버전까지는 GROUP BY는 컬럼에 대한 정렬까지 함께 수행하는 것이 기본 작동 방식이었다.
> 그러나 MySQL 8.0 버전부터는 GROUP BY 절이 컬럼의 정렬까지는 보장하지 않는 형태로 바뀌었다.

### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
![](https://i.imgur.com/oFUNPyS.png)

## 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항
WHERE 절에 사용되는 비교 조건의 표현식은 상당히 중요하다
→ 쿼리가 최적으로 실행되려면 적합한 인덱스와 함께 WHERE 절에 사용되는 비교 조건의 표현식을 적절하게 사용해야 한다.

### 11.4.3.1 NULL 비교
MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다.
→ 이는 인덱스에서는 NULL을 하나의 값으로 인정해서 관리한다는 것을 의미한다.

SQL 표준에서 NULL의 정의는 비교할 수 할 수 없는 값이다.
→ 그래서 두 값이 모두 NULL을 가진다고 하더라도 이 두 값이 동등한지 비교하는 것이 불가능하다.
→ 연산이나 비교에서 한쪽이라도 NULL이면, 이 결과도 NULL이 반환된다.
→ 쿼리에서 NULL인지 비교하려면 `IS NULL` 또는 `<=>` 연산자를 사용해야 한다.

컬럼의 값이 NULL인지 확인할 떄는 `ISNULL()` 함수를 사용해도 된다.
→ 하지만 해당 함수를 WHERE 조건에서 사용할 떄는 주의사항이 있다.
```sql
SELECT * FROM titles WHERE to_date IS NULL; 
SELECT * FROM titles WHERE ISNULL(to_date);
SELECT * FROM titles WHERE ISNULL(to_date)=1;
SELECT * FROM titles WHERE ISNULL(to_date)=true;
```
- 첫 번째, 두 번째 쿼리에서는 인덱스를 레인지 스캔으로 사용할 수 있다.
- 세 번째, 네 번째 쿼리는 테이블 풀 스캔 형태로 처리된다.
- 그래서 가급 적이면 `IS NULL` 연산자를 권장한다.

### 11.4.3.2 문자열이나 숫자 비교
문자열 컬럼이나 숫자 컬럼을 비교할 떄는 반드시 그 타입에 맞는 상숫값을 사용할 것을 권장한다.
→ 비교 대상 컬럼이 문자열 컬럼이라면 문자열 리터럴을 사용하고, 숫자 타입이라면 숫자 리터럴을 이용하는 규칙만 지켜주면 된다.
- 컬럼의 타입과 비교하는 상숫값이 동일한 타입으로 사용하면 인덱스를 적절히 이용할 수 있다.
- 컬럼이 숫자 타입이고 비교 대상이 문자열 상숫값이면 상숫값을 숫자로 타입 변환해서 비교를 수행하므로 특별히 성능 저하는 발생하지 않는다.
- 컬럼이 문자열 타입이고 비교 대상이 숫자 타입 상숫값이면 우선 순위를 가지는 숫자 타입으로 비교를 수행하려고 실행 계획을 수행하려한다. 하지만 컬럼의 타입 변환이 필요하기 때문에 인덱스를 사용하지 못한다.

### 11.4.3.3 날짜 비교

**11.4.3.3.1 DATE 또는 DATETIME과 문자열 비교**
DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.
→ `STR_TO_DATE()` 함수를 이용해서 문자열을 DATE 타입으로 변환할 수 있지만, 이렇게 명시적인 함수로 변환하지 않아도 MySQL이 내부적으로 변환을 수행한다.

```sql
-- 1.
SELECT COUNT(*)
FROM employees
WHERE hire_date > STR_TO_DATE('2011-07-23', '%Y-%m-%d');

-- 2.
SELECT COUNT(*)
FROM employees
WHERE hire_date > '2011-07-23';
```
- 첫 번째 쿼리와 두 번째 쿼리는 동일한 결과를 낸다.
- 또한 모두 인덱스를 효율적으로 이용하기 때문에 성능을 고민하지 않아도 된다.
- DATE 말고도 DATETIME 타입 또한 동일하게 동작한다.

```sql
SELECT COUNT(*)
FROM employees
WHERE DATE_FORMAT(hire_date, '%Y-%m-%d') > '2011-07-23';
```
- 위와 같은 쿼리는 컬럼을 강제적으로 타입 변경하기 때문에 인덱스를 효율적으로 사용하지 못한다.
- 되도록 상수를 변경하는 형태로 조건을 사용하는 것이 좋다
- 또한 날짜 타입 컬럼의 값을 더하거나 빼는 함수로 변형한 후 비교해도 마찬가지로 인덱스를 이용할 수 없다. (DATE_ADD, DATE_SUB)

**11.4.3.3.2 DATE와 DATETIME의 비교**
DATETIME 타입의 값을 DATE 타입으로 만들지 않고 그냥 비교하면 MySQL 서버가 DATE 타입의 값을 DATETIME으로 변환해서 같은 타입을 만든 다음 비교를 수행한다.
→ 즉, ‘2011-06-30’ 과 ‘20211-06-30 00:00:01’ 비교하는 과정에서 ‘2011-06-30’ 은 ‘2011-06-30 00:00:00’으로 변환된다.
→ 만약 DATE 값으로 비교하고 싶다면 `DATE()` 함수를 사용하면 된다.
→ 두 타입의 비교에서 타입 변환은 인덱스의 사용 여부에 영향을 미치지 않기 때문에, 성능보다는 쿼리의 결과에 주의해서 사용하자.

**11.4.3.3.3 DATETIME과 TIMESTAMP의 비교**
DATE 나 DATETIME 타입의 값과 TIMESTAMP 값을 변도의 타입 변환 없이 비교하면 문제없이 작동하고 실제 실행 계획도 인덱스 레인지 스캔을 사용해서 동작하는 것처럼 보이지만 사실은 그렇지 않다.
→ 컬럼이 DATETIME 타입이라면 `FROM_UNIXTIME()` 함수를 이용해 TIMESTAMP 값을 DATETIME 타입으로 만들어서 비교해야 한다.
→ 컬럼이 TIMESTAMP 타입이라면 `UNIX_TIMESTAMP()` 함수를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교해야 한다.

### 11.4.3.4 Short-Circuit Evaluation
여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화를 *Short-Circuit Evalution* 이라고 한다.

MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evalution 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정한다.
→ 그런데, WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-circuit Evalution 과는 무관하게 MySQL 서버는 그 조건을 가장 최우선으로 사용한다.
→ 그래서, WHERE 조건절에 나열된 조건의 순서가 인덱스의 사용 여부를 결정하지는 않는다.

MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것이다.
→ 하지만 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 평가되기 때문에 고려하지 않아도 된다.

## 11.4.4 DISTINCT
특정 컬럼의 유니크한 값을 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다.
→ 많은 사용자가 조인을 하는 경우 레코드가 중복해서 출력되는 것을 막기 위해 DISTINCT를 남용하는 경향이 있는데, 이는 성능적인 문제도 있지만 쿼리의 결과 의도한 바와 달라질 수 있다.

## 11.4.5 LIMIT n
LIMIT은 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용한다.

```sql
SELECT * FROM employees
WHERE emp_no BETWEEN 10001 AND 10010
ORDER BY first_name
LIMIT 0, 5;
```
- 위의 쿼리는 아래와 같은 순서로 실행 된다.
	1. employees 테이블에서 WHERE 절의 검색 조건에 일치하는 레코드를 전부 읽어 온다.
	2. 1번에서 읽어온 레코드를 first_name 컬럼값에 따라 정렬한다.
	3. 정렬된 결과에서 상위 5건만 사용자에게 반환한다.

LIMIT의 중요한 특성은 LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다는 것이다.
→ 즉, 쿼리에서 레코드의 정렬이 완료되지 않았다고 하더라도 상위 5건까지만 정렬되면 작업을 멈춘다.
> 하지만, 정렬의 특성상 상당히 많은 작업이 완료돼야만 상위 5건을 가려낼 수 있기 때문에, LIMIT 절이 추가된다고해서 성능 향상에 효과가 크지 않은 것이 일반적이다.

GROUP BY 절이나 DISTINCT 등과 같이 LIMIT이 사용됐을 때 어떻게 작동하는지 다음의 쿼리로 조금 더 살펴본다.
```sql
-- 1.
SELECT * FROM employees LIMIT 0, 10;
-- 2.
SELECT first_name FROM employees GROUP BY first_name LIMIT 0, 10;
-- 3.
SELECT DISTINCT first_name FROM employees LIMIT 0, 10;
-- 4.
SELECT * FROM employees
WHERE emp_no BETWEEN 10001 AND 11000
ORDER BY first_name
LIMIT 0, 10;
```
- 첫 번째 쿼리: 
	- LIMIT이 없을 때는 employees 테이블을 처음부터 끝까지 읽은 풀 테이블 스캔을 실행한다.
	- 하지만 LIMIT 조건이 있기 때문에 풀 테이블 스캔을 실행하면서 MySQL이 스토리지 엔진으로부터 10개의 레코드를 읽어 들이는 순간 스토리지 엔진으로부터 읽기 작업을 멈춘다.
	- 정렬이나 그루핑 또는 DISTINCT가 없는 쿼리에서 LIMIT 조건을 사용하면 쿼리가 상당히 빨리 끝날 수 있다.
- 두 번째 쿼리:
	- GROUP BY가 있기 때문에 GROUP BY 처리가 완료되고 나서야 LIMIT 처리를 수행할 수 있다.
	- 인덱스를 사용하지 못하는 GROUP BY는 그루핑과 정렬의 특성을 모두 가지고 있기 때문에 일단 GROUP BY 작업이 모두 완료돼야만 LIMIT을 수행할 수 있다.
	- 결국 LIMIT이 GROUP BY와 함께 사용되는 경우에는 LIMIT 절이 있더라도 실질적인 서버의 작업 내용을 크게 줄여주지는 못한다.
- 세 번째 쿼리:
	- DISTINCT는 정렬에 대한 요건이 없이 유니크한 그룹만 만들어 내면 된다.
	- MySQL은 스토리지 엔진을 통해 풀 테이블 스캔 방식을 이용해 employee 테이블 레코드를 읽어 들임과 동시에 DISTINCT를 위한 중복 제거 작업을 진행한다. 이 작업을 반복적으로 처리하다가 유니크한 레코드가 LIMIT 건수만큼 채워지면 그 순간 쿼리를 멈춘다.
	- DISTINCT와 함께 사용된 LIMIT은 실질적인 중복 제거 작업의 범위를 줄이는 역할을 한다.
- 네 번째 쿼리:
	- employees 테이블로부터 WHERE 조건절에 일치하는 레코드를 읽은 후, first_name 컬럼의 값으로 정렬을 수행한다.
	- 정렬을 수행하면서 필요한 10건이 완성되는 순간, 나머지 작업을 멈추고 결과를 사용자에게 반환한다.
	- 정렬을 수행하기 전에 WHERE 조건에 일치하는 모든 레코드를 읽어 와야 하지만 읽어온 결과가 전부 정렬돼야 쿼리가 완료되는 것이 아니라, 필요한 만큼만 정렬되면 된다.
	- 하지만, 크게 작업량을 줄여주지는 못한다. (두 번째 쿼리와 비슷하게)

결론적으로, 쿼리 문장에 GROUP BY나 ORDER BY 같은 전체 범위 작업이 선행되더라도 LIMIT 절이 있다면 나름의 성능 향상은 볼 수 있다.
→ 만약 ORDER BY나 GROUP BY 또는 DISTINC가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어 주기 때문에 쿼리의 작업량을 상당히 줄여준다.  

LIMIT 절은 1개 또는 2개의 인자를 사용할 수 있는데
- 인자가 1개인 경우: 상위 n개의 레코드를 가져온다.
- 인자가 2개인 경우: 첫 번째 인자에 지정된 위치부터 두 번째 인자에 명시된 개수만큼의 레코드를 가져온다.

LIMIT의 제한 사항으로는 LIMIT의 인자로 표현식이나 별도의 서브쿼리를 사용할 수 없다는 점이 있다.
또한 아래와 같은 쿼리에서 문제가 발생할 수 있다.
```sql
SELECT * FROM salaries ORDER BY salary LIMIT n, m;
```
- n과 m이 작은 값이라면 문제가 되지 않지만 매우 큰 값이라면 상당히 오랜 시간이 걸린다.
- LIMIT 조건의 페이징이 처음 몇 개 페이지 조회로 끝나지 않을 가능성이 있다면 WHERE 조건절로 읽어야 할 위치를 찾고 그 위치에서 적은 수의 레코드를 조회하는 것이 좋다.

## 11.4.6 COUNT()
COUNT 함수는 결과 레코드의 건수를 반환하는 함수이다.
→ COUNT 함수는 컬럼이나 표현식을 인자로 받으며, 특별한 형태로 * 를 사용할 수도 있다.
→ COUNT(1), COUNT(프라이머리 키 컬럼), COUNT(\*) 라고 해도 모두 동일한 처리 성능을 보인다.

→MyISAM 스토리지 엔진을 사용하는 테이블은 항상 테이블의 메타 정보에 전체 레코드 건수를 관리하므로, 실제 레코드 건수를 세어 보지 않아도 바로 결과를 반환하기 때문에 빠르게 처리된다.
→ 하지만, WHERE 조건이 있는 COUNT(\*) 쿼리는 그 조건에 일치하는 레코드를 읽어 보지 않는 이상 알 수 없으므로 일반적인 RDBMS와 같이 처리된다.
→ InnoDB 스토리지 엔진을 사용하는 테이블에서는 WHERE 조건이 없는 COUNT(\*) 쿼리라고 하더라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가져올 수 있기 때문에 큰 테이블에서 COUNT 함수를 쓰는 작업은 주의해야 한다.

COUNT(\*) 쿼리에서 ORDER BY 절은 어떤 경우에도 필요치 않다.
→ 또한 LEFT JOIN 또한 레코드 건수의 변화가 없거나 아우터 테이블에서 별도의 체크를 하지 않아도 되는 경우에는 모두 제거하는 것이 성능상 좋다.

```ad-tip
MySQL 8.0 버전부터는 SELECT COUNT(*) 쿼리에 사용된 ORDER BY 절은 옵티마이저가 무시하도록 개선됐다.
```

많은 사용자가 일반적으로 컬럼의 값을 SELECT 하는 쿼리보다 COUNT 쿼리가 훨씬 빠르게 실행될 것으로 생각한다.
하지만 인덱스를 제대로 사용하도록 튜닝되지 못한 COUNT 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 몇 배 몇십 배 더 느리게 실행될 수도 있다.

COUNT() 함수에 컬럼명이나 표현식이 인자로 사용되면 그 컬럼이나 표현식의 결과가 NULL이 아닌 레코드 건수만 반환한다.
→ 그래서 NULL이 될 수 있는 컬럼을 COUNT() 함수에 사용할 때는 의도대로 쿼리가 작동하는지 확인하는 것이 좋다.

## 11.4.7 JOIN

### 11.4.7.1 JOIN 순서와 인덱스
인덱스 레인지 스캔은 인덱스를 탐색하는 단계와 인덱스를 스캔하는 과정으로 구분해 볼 수 있다.
→ 일반적으로 인덱스를 이용해서 쿼리하는 작업에서는 가져오는 레코드의 건수가 소량이기 때문에 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편이다.

드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다.
→ 그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.

```sql
SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no=de.emp_no;
```
- **두 컬럼 모두 각각 인덱스가 있는 경우**
	- 어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블의 검색 작업을 빠르게 처리할 수 있다.
	- 이럴 때, 옵티마이저가 통계 정보를 이용해 적절히 드라이빙 테이블을 선택하게 된다.
	- 각 테이블의 통계 정보에 있는 레코드 건수에 따라 employees가 드라이빙 테이블이 될 수 있고, dept_emp 테이블이 드라이빙 테이블로 선택될 수도 있다.
	- 보통의 경우 어느 쪽 테이블이 드라이빙 테이블이 되든 옵티마이저가 선택하는 방법이 최적일 때가 많다.
- **employees.emp_no에만 인덱스가 있는 경우**
	- dept_emp 테이블이 드리븐 테이블로 선택된다면 employees 테이블의 레코드 건수만큼 dept_emp 테이블을 풀 스캔해야만 조건에 일치하는 레코드를 찾을 수 있다.
	- 이 경우, 옵티마이저는 항상 dept_emp 테이블을 드라이빙 테이블로 선택하고 employees 테이블을 드리븐 테이블로 선택한다.
	- 이때는 employees 테이블을 아주 효율적으로 접근할 수 있는 조건이 있더라도 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택하지 않을 가능성이 높다.
- **dept_emp.emp_no에만 인덱스가 있는 경우**
	- 위의 경우와는 반대로 처리된다.
	- 이 경우, employees 테이블의 반복된 풀 스캔을 피하기 위해 employees 테이블을 드라이빙 테이블로 선택하고 dept_emp 테이블을 드리븐 테이블로 조인을 수행하게 실행계획을 수립한다.
- **두 컬럼 모두 인덱스가 없는 경우**
	- 어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 풀 스캔은 발생하기 때문에 옵티마이저가 적절히 드라이빙 테이블을 선택한다.
	- 단, 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다.
	- 조인 조건을 빠르게 처리할 인덱스가 없는 경우 MySQL 8.0.18 이전까지는 블록 네스티드 루프 조인을 사용했지만 이후 버전에서는 해시 조인으로 처리된다.

### 11.4.7.2 JOIN 컬럼의 데이터 타입
조인 컬럼 간의 비교에서 각 컬럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 사용할 수 없다.

```ad-tip
옵티마이저는 드리븐 테이블이 인덱스 레인지 스캔을 사용하지 못하고, 드리븐 테이블의 풀 테이블 스캔이 필요한 것을 알고 조금이라도 빨리 실행되도록 조인 버퍼를 활용한 해시 조인을 사용한다.
```

인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR - VARCHAR 타입, INT - BIGINT 타입, DATE - DATETIME 타입 간에는 발생하지 않는다.
→ 하지만 아래와 같은 비교 패턴은 문제가 될 가능성이 높다.
- CHAR 타입과 INT 타입의 비교와 같이 데이터 타입의 종류가 완전히 다른 경우
- 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 다른 경우
- 같은 INT 타입더라도 부호(Sign)의 존재 여부가 다른 경우

### 11.4.7.3 OUTER JOIN의 성능과 주의사항
MySQL 옵티마이저는 절대 아우터로 조인되는 테이블을 드라이빙 테이블로 선택하지 못하기 때문에 풀 스캔이 필요한 테이블을 드라이빙 테이블로 선택한다.

이너 조인으로 사용해도 되는 쿼리를 아우터 조인으로 작성하면 MySQL 옵티마이저가 조인 순서를 변경하면서 수행할 수 있는 최적화의 기회를 빼앗아버리는 결과가 된다.
→ 필요한 데이터와 조인되는 테이블 간의 관계를 정확히 파악해서 꼭 필요한 경우가 아니라면 이너 조인을 사용하는 것이 업무 요건을 정확히 구현함과 동시에 쿼리의 성능도 향상시킬 수 있다.

아우터 조인 쿼리를 작성하면서 많이하는 또 다른 실수는 아우터로 조인되는 테이블에 대한 조건을 WHERE 절에 명시하는 것이다.
```sql
SELECT *
FROM employees e
	LEFT JOIN dept_manager mgr ON mgr.emp_no=e.emp_no
WHERE mgr.dept_no='d001';
```
위의 LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문에 MySQL 옵티마이저가 LEFT JOIN을 INNER JOIN으로 변환해서 실행해버린다.
```sql
SELECT *
FROM employees e
	INNER JOIN dept_manager mgr ON mgr.emp_no=e.emp_no
WHERE mgr.depth_no='d001';
```

정상적인 아우터 조인이 되게 만들려면 WHERE 절의 `mgr.dept_no='d001'` 조건을 LEFT JOIN의 ON 절로 옮겨야 한다.

> 예외적으로 OUTER JOIN으로 연결되는 테이블의 컬럼에 대한 조건을 WHERE 절에 사용해야 하는 경우가 있는데, 안티 조인 효과를 기대하는 경우가 그렇다.

### 11.4.7.4 JOIN과 외래키 (FOREIGN KEY)
외래키는 조인과 아무런 연관이 없다. 
→ 외래키를 생성하는 주목적은 데이터의 무결성을 보장하기 위해서다.
→ 외래키와 연관된 무결성을 참조 무결성이라고 표현한다.

SQL로 테이블 간의 조인을 수행하는 것은 전혀 무관한 컬럼을 조인 조건으로 사용해도 문법적으로는 문제가 되지 않는다.
→ 데이터 모델링을 할 때는 각 테이블 간의 관계를 필수적으로 그려 넣어야 하지만, 그 데이터 모델을 데이터베이스에 생성할 때는 그 테이블 간의 관계는 외래키로 생성하지 않을 떄가 많다.
→ 하지만, 테이블 간의 조인을 사용하기 위해 외래키가 필요한 것은 아니다.

### 11.4.7.5 지연된 조인 (Delayed Join)
조인은 대체로 실행되면 될수록 결과 레코드 건수가 늘어난다.
→ 그래서 조인의 결과를 GROUP BY하거나 ORDER BY하면 조인을 실행하기 전의 레코드에 GROUP BY 혹은 ORDER BY를 수행하는 것보다 많은 레코드를 처리해야 한다.
→ 여기서, 지연된 조인은 조인이 실행되기전에 GROUP BY 혹은 ORDER BY를 처리하는 방식을 의미한다.
→ 지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다.

지연된 쿼리의 원리를 정확히 이해하지 못한 상태로 지연된 쿼리를 작성하면 오히려 역효과가 날 수도 있다.
→ 하지만 잘 튜닝된 지연된 쿼리는 원래의 쿼리보다 몇십 배, 몇백 배 더 나은 성능을 보일 수도 있다.

지연된 조인은 경우에 따라 상당한 성능 향상을 가져올 수 있지만, 모든 쿼리를 지연된 조인 형태로 개선할 수 있는 것이다.
→ OUTER JOIN과 INNER JOIN에 대해 다음과 같은 조건이 갖춰져야만 지연된 쿼리로 변경해서 사용할수 있다.
- LEFT OUTER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 혹은 M:1 관계여야 한다.
- INNER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계임과 동시에 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야 한다.

### 11.4.7.6 래터럴 조인
MySQL 8.0 버전부터는 래터럴 조인이라는 기능을 이용해 특정 그룹별로 서브쿼리를 실행해서 그 결과와 조인하는 것이 가능해졌다.
→ 래터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리에서 외부 쿼리의 FROM 절에 정의된 테이블의 컬럼을 참조할 수 있다는 것이다.
→ 이렇게 FROM 사용된 서브쿼리가 외부 쿼리의 컬럼을 참조하기 위해서는 `LATERAL` 키워드가 명시돼야 한다.
→ LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만 사용해야 한다.

### 11.4.7.7 실행 계획으로 인한 정렬 흐트러짐
MySQL 8.0 이전 버전까지는 네스티드-루프 방식의 조인만 가능했지만 MySQL 8.0 버전부터는 해시 조인 방식이 도입됐다.
→ 네스티드-루프 조인은 알고리즘 특성상 드라이빙 테이블에서 읽은 레코드의 순서가 다른 테이블이 모두 조인돼도 그대로 유지된다.
→ 해시 조인이 사용되면 쿼리 결과의 레코드 정렬 순서가 달라진다.
→ 해시 조인 뿐만 아니라, MySQL 8.0 이전 버전에서 사용되던 블록 네스티드 루프 조인이 사용되는 경우도 동일하게 쿼리 결과의 정렬 순서가 드라이빙 테이블을 읽는 순서와 다르게 출력됐다.

실행 계획은 MySQL 옵티마이저에 의해 그때그때 상황에 따라 달라질 수 있다.
→ 정렬된 결과가 필요한 경우라면 드라이빙 테이블의 순서와 의존하지 말고 ORDER BY 절을 명시적으로 사용하는 것이 좋다.

---

## 11.4.8 GROUP BY
GROUP BY는 특정 컬럼의 값으로 레코드를 그루핑하고, 그룹별로 집계된 결과를 하나의 레코드로 조회할 때 사용한다.

### 11.4.8.1 WITH ROLLUP
GROUP BY가 사용된 쿼리에서는 그루핑된 그룹별로 소계를 가져올 수 있는 롤업 기능을 사용할 수 있다.
→ ROLL UP으로 출력되는 소계는 최종 합만 가져오는 것이 아니라 GROUP BY에 사용된 컬럼의 개수에 따라 소계의 레벨이 달라진다.
> MySQL의 GROUP BY … ROLLUP 쿼리는 엑셀의 피벗 테이블과 거의 동일한 기능으로 생각하면 된다.

소계 레코드의 컬럼값은 항상 NULL로 표시되는 점에 주의 해야 한다.

MySQL 8.0 버전부터는 그룹 레코드에 표시되는 NULL을 사용자가 변경할 수 있게 `GROUPING()` 함수를 지원한다.
```sql
SELECT
IF (GROUPING(first_name), 'ALL first_name', first_name) AS first_name,
IF (GROUPING(last_name), 'ALL last_name', last_name) AS last_name,
COUNT(*)
FROM employees
GROUP BY first_name, last_name WITH ROLLUP;
```
- GROUPING() 함수의 사용 결과에서는 더이상 NULL로 표시되지 않고, 주어진 문자열이 표시되는 것을 확인할 수 있다.

### 11.4.8.2 레코드를 컬럼으로 변환해서 조회
GROUP BY나 집합 함수를 통해 레코드를 그루핑할 수 있지만, 하나의 레코드를 여러 개의 컬럼으로 나누거나 변환하는 SQL 문법은 없다.
→ 하지만, `SUM()` 이나 `COUNT()` 같은 집합 함수와 `CASE WHEN … END` 구문을 이용해 레코들르 컬럼으로 변환하거나 하나의 컬럼을 조건으로 구분해서 2개 이상의 컬럼으로 변환하는 것은 가능하다.
> 레코드를 컬럼으로 변환한다는 것은 엑셀의 피봇 테이블을 만드는 것과 동일한 개념이다.

**11.4.8.2.1 레코드를 컬럼으로 변환**
```sql
SELECT dept_no, COUNT(*) AS emp_count
FROM dept_emp
GROUP BY dept_no;
```
- 이 쿼리는 부서 번호와 사원 수를 그루핑한 결과가 만들어진다.
- 여기서 레코드를 컬럼으로 변환해야 한다면 쿼리의 결과를 `SUM(CASE WHEN …)` 구문을 사용하면 된다.

```sql
SELECT 
SUM (CASE WHEN dept_no='d001' THEN emp_count ELSE 0 END) AS count_d001,
SUM (CASE WHEN dept_no='d002' THEN emp_count ELSE 0 END) AS count_d002,
SUM (CASE WHEN dept_no='d003' THEN emp_count ELSE 0 END) AS count_d003,
SUM (CASE WHEN dept_no='d004' THEN emp_count ELSE 0 END) AS count_d004,
...
SUM (CASE WHEN dept_no='d008' THEN emp_count ELSE 0 END) AS count_d008,
SUM (CASE WHEN dept_no='d009' THEN emp_count ELSE 0 END) AS count_d009,
SUM(emp_count) AS count_total
FROM (
	SELECT dept_no, COUNT(*) AS emp_count FROM dept_emp GROUP BY dept_no
) tb_derived;
```
- 위의 쿼리는 9개의 레코드를 1건의 레코드로 변환했다.
- 부서 번호의 순서대로 CASE WHEN 구문을 이용해 각 컬럼에서 필요한 값만 선별해서 `SUM()` 을 했다.

레코드를 컬럼으로 변환하는 작업을 할 때는 목적이나 용도에 맞게 COUNT, MIN, MAX, AVG, SUM 등의 집합 함수를 이용하면 된다.
→ 다만, 쿼리의 특성에 따라 단점이 존재할 수 있는데, 이는 동적으로 쿼리를 생성하는 방법으로 보완하면 된다.

**11.4.8.2.2 하나의 컬럼을 여러 컬럼으로 분리**
```sql
SELECT de.dept_no,
SUM(CASE WHEN e.hire_date BETWEEN '1980-01-01' AND '1989-12-31' THEN 1 ELSE 0 END) AS cnt_1980,
SUM(CASE WHEN e.hire_date BETWEEN '1990-01-01' AND '1999-12-31' THEN 1 ELSE 0 END) AS cnt_1990,
SUM(CASE WHEN e.hire_date BETWEEN '2000-01-01' AND '2009-12-31' THEN 1 ELSE 0 END) AS cnt_2000,
COUNT(*) AS cnt_total
FROM dept_emp de, employees e
WHERE e.emp_no=de.emp_no
GROUP BY de.dept_no;
```
- dept_emp 테이블은 employees 테이블과 조인했으며 그 결과를 dept_no별로 GROUP BY를 실행했다.
- 그루핑된 부서별 사원의 정보에서 CASE WHEN으로 사원의 입사 연도를 구분해서 연도별로 합계를 실행하면 원하는 결과를 얻을 수 있다.

> 이러한 형태의 쿼리에 WITH ROLLUP 기능을 함께 사용한다면 더 유용한 결과를 만들어 낼 수 있다.

## 11.4.9 ORDER BY
ORDER BY는 검색된 레코드를 어떤 순서로 정렬할지 결정한다.
- 인덱스를 사용한 SELECT의 경우에는 인덱스에 정렬된 순서대로 레코드를 가져온다.
- 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행하는 SELECT
	- MyISAM 테이블은 테이블에 저장된 순서대로 가져오며, 이 순서가 정확히 INSERT된 순서는 아닐 수도 있다.
	- 일반적으로 테이블의 레코드가 삭제되면 빈 공간이 생기고, INSERT는 빈 공간에 저장되기 때문이다.
	- InnoDB의 경우에는 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에는 기본적으로 프라이머리 키 순서대로 레코드를 가져온다.
- SELECT 쿼리가 임시 테이블을 거쳐 처리되면 조회되는 레코드의 순서를 예측하기는 어렵다.

ORDER BY 절이 없는 SELECT 쿼리 결과의 순서는 처리 절차에 따라 달라질 수 있다.
→ 어떤 DBMS도 ORDER BY 절이 명시되지 않은 쿼리에 대해서는 어떠한 정렬도 보장하지 않는다.
→ 항상 정렬이 필요한 곳에서는 ORDER BY 절을 사용해야 한다.

ORDER BY에서 인덱스를 사용하지 못할 때는 추가 정렬 작업이 수행된다.
→ 이때 쿼리 실행 계획에 있는 Extra 컬럼에 “Using filesort”라는 코멘트가 표시된다.
> filesort라는 단어에 포함된 file은 디스크의 파일을 이용해 정렬을 수행한다는 의미가 아니라, 쿼리를 수행하는 도중에 MySQL 서버가 명시적으로 정렬 알고리즘을 수행했다는 의미로 이해하면 된다.

→ 정렬 대상이 많은 경우에는 여러 부분으로 나눠서 처리하는데, 정렬된 결과를 임시로 디스크나 메모리에 저장해 둔다.
→ 실제로 메모리만 이용해 정렬이 수행됐는지 디스크의 파일을 이용했는지는 실행 계획을 통해서는 알 수 없지만, MySQL 서버의 상태 값을 확인해보면 알 수 있다.

```sql
SHOW STATUS LIKE 'Sort_%';
```
- Sort_merge_passes: 메모리의 버퍼와 디스크에 저장된 레코드를 몇 번이나 병합했는지 보여준다. (0보다 크다면 정렬용 버퍼보다 커서 디스크를 시용했다는 것을 의미한다.)
- Sort_range: 인덱스 레인지 스캔을 통해서 읽은 레코드를 정렬한 횟수
- Sort_scan: 풀 테이블 스캔을 통해서 읽은 레코드를 정렬한 횟수
- Sort_rows: 정렬을 수행했던 전체 레코드 건수의 누적된 값

### 11.4.9.1 ORDER BY 사용법 및 주의 사항
일반적으로 정렬할 대상은 컬럼명이나 표현식으로 명시하지만, SELECT되는 컬럼의 순번을 명시할 수도 있다.
→ 즉, `ORDER BY 2` 라고 명시하면 SELECT되는 컬럼 중에서 2번째 컬럼으로 정렬하라는 의미가 된다.
→ 하지만, ORDER BY 뒤에 숫자 값이 아닌 문자열 상수를 사용하는 경우에는 옵티마이저가 ORDER BY절 자체를 무시한다.
→ 컬럼명이라 하더라도 따옴표를 이용해 문자 리터럴로 표시하면 상숫값으로 정렬하라는 의미가 된다.

> 다른 DBMS에서 쌍따옴표는 식별자를 표현하기 위해 사용하지만 MySQL에서 쌍따옴표는 문자열 리터럴을 표현하는 데 사용한다.

### 11.4.9.2 여러 방향으로 동시 정렬
MySQL 8.0 이전 버전까지는 여러 개의 컬럼을 조합해서 정렬할 때 각 컬럼의 정렬 순서가 오름차순과 내림차순이 혼용되면 인덱스를 이용할 수 없다.
→ 하지만 MySQL 8.0 버전부터는 오름차순과 내림차순을 혼용해서 인덱스를 생성할 수 있게 개선됐다.
```sql
ALTER TABLE salaries ADD INDEX ix_salary_fromdate (salary DESC, from_date ASC);
```

### 11.4.9.3 함수나 표현식을 이용한 정렬
하나 또는 여러 컬럼의 연산 결과를 이용해 정려하는 것도 가능하다.
→ MySQL 8.0 이전까지는 연산의 결과를 기준으로 정렬하기 위해서는 가상 컬럼을 추가하고 인덱스를 생성하는 방법을 사용해야 했다
→ MySQL 8.0  버전부터는 함수 기반의 인덱스를 지원하기 시작했다.
```sql
SELECT *
FROM salaries
ORDER BY COS(salary);
```

## 11.4.10 서브쿼리
쿼리를 작성할 때 서브쿼리를 이용하면 단위 처리별로 쿼리를 독립적으로 작성할 수 있다.
→ 조인처럼 여러 테이블을 섞어 두는 형태가 아니어서 쿼리의 가독성이 높아지며 복잡한 쿼리도 손쉽게 작성할 수 있다.

서브쿼리는 쿼리의 여러 위치에서 사용될 수 있는데, 대표적으로 SELECT 절과 FROM절, WHERE절에 사용될 수 있다.

### 11.4.10.1 SELECT 절에 사용된 서브쿼리
SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지 않기 때문에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의 사항은 없다.

일반적으로 SELECT 절에 서브쿼리를 사용하면 그 서브쿼리는 항상 컬럼과 레코드가 하나인 결과를 반환해야 한다.
→ 그 값이 NULL이든 아니든 관계없이 레코드가 1건이 존재해야 한다는 것인데, MySQL에서는 체크 조건이 조금은 느슨하다.
```sql
-- 1
SELECT emp_no, (SELECT dept_name FROM departments WHERE dept_name='Sales1')
FROM dept_emp LIMIT 10;

-- 2 (ERROR)
SELECT emp_no, (SELECT dept_name FROM departments)
FROM dept_emp LIMIT 10;

-- 3 (ERROR)
SELECT emp_no, (SELECT dept_no, dept_name FROM departments WHERE dept_nmae='Sales1')
FROM dept_emp LIMIT 10;
```
- 첫 번째 쿼리에서의 서브쿼리는 항상 결과가 0이다. 하지만 에러는 발생하지 않고 서브쿼리의 결과는 NULL로 채워져서 반환한다.
- 두 번째 쿼리의 서브쿼리가 2건 이상의 레코드를 반환하는 경우에는 에러가 나면서 쿼리가 종료된다.
- 세 번째 쿼리와 같이 SELECT 절에 사용된 서브쿼리가 2개 이상의 컬럼의 가져오려고 할 때도 에러가 발생한다.

SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리에서만 사용할 수 있다.

```ad-tip
서브쿼리를 만들어 내는 결과에 따라, 스칼라 서브쿼리와 로우 서브쿼리로 구분할 수 있다.
- 스칼라 서브쿼리는 레코드의 컬럼이 각각 하나인 결과를 만들어내는 서브쿼리
- 로우 서브쿼리는 레코드 건수가 많거나 컬럼 수가 많은 결과를 만들어 내는 서브쿼리
```

가끔 조인으로 처리해도 되는 쿼리를 SELECT 절의 서브쿼리를 사용해서 작성할 떄도 있다.
→ 하지만 서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성하는 것이 좋다.

### 11.4.10.2 FROM 절에 사용된 서브쿼리
이전 버전의 MySQL 서버에서는 FROM절에 서브쿼리가 사용되면 항상 서브쿼리의 결과를 임시 테이블로 저장하고, 필요할 때 다시 임시 테이블을 읽는 방식으로 처리했다.
→ MySQL 5.7 버전부터는 옵티마이저가 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선됐다.
> 서브쿼리의 외부 병합은 꼭 FROM 절의 서브쿼리에 대해서만 적용되는 최적화는 아니고, FROM 절에 사용된 뷰의 경우에도 MySQL 옵티마이저는 뷰 쿼리와 외부 쿼리를 병합해서 최적화된 실행 계획을 사용한다.

FROM 절의 모든 서브쿼리를 외부 쿼리로 병합할 수 있는 것은 아니다.
→ 다음과 같은 같은 기능이 서브쿼리에 사용되면 FROM 절의 서브쿼리는 외부 쿼리로 병합되지 못한다.
- 집합 함수 사용 (SUM(), MIN(), COUNT() 등)
- DISTINCT
- GROUP BY 또는 HAVING
- LIMIT 
- UNION(UNION DISTINCT) 또는 UNION ALL
- SELECT 절에 서브쿼리가 사용된 경우
- 사용자 변수 사용 (사용자 변수에 값이 할당되는 경우)

외부 쿼리와 병합되는 FROM 절의 서브쿼리가 ORDER BY 절을 가진 경우에는 외부 쿼리가 GROUP BY나 DISTINCT 같은 기능을 사용하지 않는다면 서브쿼리의 정렬 조건을 외부 쿼리로 같이 병합한다.
→ 외부 쿼리에서 GROUP BY나 DISTINCT 와 같은 기능이 사용되고 있다면, 서브쿼리의 정렬 작업은 무의미하기 때문에 서브쿼리의 ORDER BY 절은 무시된다.

> MySQL 서버에서 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화는 optimizer_switch 시스템 변수로 제어할 수 있다.

### 11.4.10.3 WHERE 절에 사용된 서브쿼리
WHERE 절의 서브쿼리는 SELECT 절이나 FROM 절보다는 다양한 형태로 사용될 수 있는데, 크게 3가지로 구분한다.
- 동등 또는 크다 작다 비교 (= (subquery))
- IN 비교 (IN (subquery))
- NOT IN 비교 (NOT IN (subquery))

**11.4.10.3.1 동등 또는 크다 작다 비교**
MySQL 5.5 이전 버전까지는 서브쿼리 외부의 조건으로 쿼리를 실행하고, 최종적으로 서브쿼리를 체크 조건을 사용했다.
→ 이러한 처리 방식의 경우 풀 테이블 스캔이 필요한 경우가 많아서 성능 저하가 심각했다.

MySQL 5.5 버전부터는 쿼리의 실행 계획이, 이전 버전과는 정반대로 실행되도록 개선되었다.
→ 서브쿼리를 먼저 실행한 후 상수로 변환한다.
→ 상숫값으로 서브쿼리를 대체해서 나머지 쿼리 부분을 처리한다.

> 해당 실행 계획은 동등 비교, 크다 또는 작다 비교가 사용되어도 동일하게 나타난다.

하지만 단일값 비교가 아닌 튜플 비교 방식이 사용되면 서브쿼리가 먼저 처리되어 상수화되긴 하지만 외부 쿼리는 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행한다.
→ MySQL 8.0 버전이라고 하더라도 튜플 형태의 비교는 주의해서 사용해야 한다.

**11.4.10.3.2 IN 비교 (IN (subquery))**
실제 조인은 아니지만, 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지를 체크하는 형태를 세미 조인이라고 한다.
→ WHERE 절에 사용된 IN (subquery) 형태의 조건을 조인의 한 방식인 세미 조인이라고 보는 것이다.
```sql
SELECT *
FROM employees e
WHERE e.emp_no IN
(SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01')
```

MySQL 5.5 버전까지는 세미 조인의 최적화가 부족해서 대부분 풀 테이블 스캔을 했다.
→ 하지만, MySQL 5.6 버전부터 MySQL 8.0 버전까지 세미 조인의 최적화가 많이 개선되었다.

MySQL 서버의 세미 조인 최적화는 쿼리 특성이나 조인 관계에 맞게 다음과 같이 5개의 최적화 전략을 선택적으로 사용한다.
- 테이블 풀-아웃 (Table Pull-out)
- 퍼스트 매치 (Firstmatch)
- 루스 스캔 (Loosescan)
- 구체화 (Materialization)
- 중복 제거 (Duplicated Weed-out)

> MySQL 8.0을 사용한다면 세미 조인 최적화에 익숙해져야 한다.
> 전처럼 불필요하게 쿼리를 여러 조각으로 분리해서 실행하는 습관은 버리고 MySQL 8.0의 기능을 적극적으로 활용해 개발 생산성을 높이는 방향을 추천한다.

**11.4.10.3.3 NOT IN 비교 (NOT IN (subquery))**
IN (subquery)와 비슷한 형태지만 이 경우를 안티 세미 조인이라고 명명한다.
→ 일반적인 RDBMS에서 Not-Equal 비교는 인덱스를 제대로 활용할 수 없듯이 안티 세미 조인 또한 최적화할 수 있는 방법이 많지 않다.
→ MySQL 옵티마이저는 안티 세미 조인 쿼리가 사용되면 다음 두 가지 방법으로 최적화를 수행한다.
- NOT EXISTS
- 구체화 (Materialization)

하지만, 두 가지 최적화 모두 그다지 성능 향상에 도움이 되지 않는 방법이므로 쿼리가 최대한 다른 조건을 활용해서 데이터 검색 범위를 좁힐 수 있게 하는 것이 좋다.
> WHERE 절에 단독으로 안티 세미 조인 조건만 있다면 풀 테이블 스캔을 피할 수 없으니 주의하자.

## 11.4.11 CTE (Common Table Eexpression)
CTE는 이름을 가지는 임시 테이블로서, SQL 문장 내에서 한 번 이상 사용될 수 있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제된다.
→ CTE는 재귀적 반복 실행 여부를 기준으로 *Non-recursive*와 *Recursive* CTE로 구분된다.
→ MySQL 서버의 CTE는 재귀 여부에 관계없이 다양한 SQL 문장에서 사용할 수 있다.
- SELECT, UPDATE, DELETE 문장의 제일 앞쪽
- 서브쿼리의 제일 앞쪽
- SELECT 절의 바로 앞쪽

### 11.4.11.1 비 재귀적 CTE (NON-Recursive CTE)
MySQL 서버에서는 ANSI 표준을 그대로 이용해서 WITH 절을 이용해 CTE를 정의한다.
```sql
WITH cte1 AS (SELECT * FROM departments)
SELECT * FROM CTE1;
```
- CTE 쿼리는 WITH 절로 정의하고, CTE 쿼리로 생성되는 임시 테이블의 이름은 WITH 바로 뒤에 “cte1”로 정의된다.
- cte1 임시 테이블은 한 번만 사용되기 때문에 다음 쿼리처럼 FRO 절의 서브쿼리로 바꿔 사용할 수 있다.

CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 다음의 3가지 장점이 있다.
- CTE 임시 테이블은 재사용 가능하므로 FROM 절의 서브쿼리보다 효율적이다.
- CTE로 선언된 임시 테이블은 다른 CTE 쿼리에서 참조할 수 있다.
- CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높다

### 11.4.11.2 재귀적 CTE (Recursive CTE)
MySQL 8.0 버전에서야 비로소 CTE를 사용한 재귀 쿼리가 가능해졌다.
```sql
WITH RECURSIVE cte (no) AS (
	SELECT 1
	UNION ALL
	SELECT (no + 1) FROM cte WHERE no < 5
)
SELECT * FROM cte;
```
1. CTE 쿼리의 비 재귀적 파트의 쿼리를 실행
2. 1번의 결과를 이용해 cte라는 이름의 임시 테이블 생성
3. 1번의 결과를 cte라는 임시 테이블에 저장
4. 1번의 결과를 입력으로 사용해 CTE 쿼리의 재귀적 파트의 쿼리를 실행
5. 4번의 결과를 cte라는 임시 테이블에 저장 (이때 UNION 또는 UNON DISTINCT의 경우 중복 제거를 실행)
6. 전 단계의 결과를 입력으로 사용해 CTE 쿼리의 재귀적 파트 쿼리를 실행
7. 6번 단계에서 쿼리 결과가 없으면 CTE 쿼리를 종료
8. 6번의 결과를 cte라는 임시 테이블에 저장
9. 6번으로 돌아가서 반복 실행

→ 1번 과정에서 매우 중요한 부분이 결정되는데, CTE 임시 테이블의 구조는 CTE 쿼리의 비 재귀적 쿼리 파트의 결과로 결정된다.

재귀적 CTE 쿼리는 비 재귀적 쿼리 파트와 재귀적 파트로 구분되며, 이 둘을 UNION(UNION DISTNCT) 또는 UNION ALL로 연결하는 형태로 반드시 쿼리를 작성해야 한다.
→ 비 재귀적 파트는 처음 한 번만 실행되지만 재귀적 파트는 쿼리 결과가 없어 질 때까지 반복 실행된다.

재귀적 쿼리 파트를 실행할 때는 지금까지의 모든 단계에서 만들어진 결과 셋이 아니라, 직전 단계의 결과만 재귀 쿼리의 입력으로 사용된다.

재귀적으로 실행되는 CTE에서 하나 더 주의할 것은 반복 실행의 종료 조건이다.
→ 실제 재귀 쿼리가 반복을 멈추는 조건은 재귀 파트 쿼리의 결과가 0건일 때까지이다.
> 실제 응용 프로그램의 쿼리에서 사용하는 데이터는 몇 단계까지 재귀적으로 실행돼야 할지 알 수 없는 경우가 더 많다.
> 데이터의 오류나 쿼리 작성자의 실수로 재귀적 CTE가 종료 조건을 만족하지 못해서 무한 반복하는 경우도 발생할 수 있다.

무한 반복하는 재귀 오류를 막기 위해서 MySQL 서버는 `cte_max_recursion_depth` 시스템 변수를 이용해 최대 반복 횟수를 제한할 수 있다.
→ 기본값은 1000인데, 단순히 1부터 시작하는 시리얼 번호를 가지는 임시 테이블을 생설하는 경우를 제외하면 너무 큰 값이다.
→ 가능하면 해당 시스템 변수의 값을 적절히 낮추고, SET_VAR 힌트를 이용해 해당 쿼리에서만 반복 호출 횟수를 늘리는 방법을 권고한다.

### 11.4.11.3 재귀적 CTE(Recursive CTE) 활용
```ad-tip
p.122 ~ 125 의 예제를 보는 것이 좋음
```
재귀적 쿼리를 활용할 수 있는 업무 요건은 상당히 많다.
→ 재귀적 쿼리 파트는 조금은 혼란스러울 수 있는데, 작동 원리만 이해하면 어렵지 않게 자유자재로 쿼리를 작성할 수 있을 것이다.

---

## 11.4.12 윈도우 함수
윈도우 함수는 조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행한다.
→ 집계 함수는 주어진 그룹별로 하나의 레코드로 묶어서 출력한다.
→ 그러나 윈도우 하뭇는 조건에 일치하는 레코드 건수는 변하지 않고, 그대로 유지한다.

일반적인 SQL 문장에서 하나의 레코드를 연산할 때 다른 레코드의 값을 참조할 수 없다. (예외적으로 GROUP BY 또는 집계 함수는 다른 레코드의 컬럼값을 참조할 수 있다.)
→ GROUP BY 또는 집계 함수를 사용하면 결과 집합의 모양이 바뀐다.
→ 윈도우 함수는 결과 집합을 그대로 유지하면서 하나의 레코드 연산에 다른 레코드의 컬럼값을 참조할 수 있다.

### 11.4.12.1 쿼리 각 절의 실행 순서
윈도우 함수를 사용하는 쿼리의 결과에 보여지는 레코드는 FROM 절과 WHERE 절, GROUP BY와 HAVING 절에 의해 결정되고, 그 이후 윈도우 함수가 실행된다.
그리고 마지막으로 SELECT 절과 ORDER BY 절, LIMIT 절이 실행되어 최종 결과가 반환된다.
→ 만약, 이 순서를 벗어나는 쿼리를 작성하고자 한다면 FROM 절의 서브쿼리를 사용해야 한다.

### 11.4.12.2 윈도우 함수 기본 사용법
윈도우 함수의 기본 사용법은 다음과 같다.
```sql
AGGREGATE_FUNC() OVER (<partition> <order>) AS window_func_column
```

윈도우 함수는 용도별로 다양한 함수들을 사용할 수 있는데, 집계 함수와는 달리 함수 뒤에 OVER 절을 이용해 연산 대상을 파티션하기 위한 옵션을 명시할 수 있다.
→ OVER 절에 의해 만들어진 그룹을 *파티션* 또는 *윈도우* 라고 한다.

소그룹 파티션이나 정렬이 필요치 않은 경우, PARTITION이나 ORDER BY 없이 비어 있는 OVER() 절을 사용하면 된다.

윈도우 함수의 각 파티션 안에서도 연산 대상 레코드별로 연산을 수행할 소그룹이 사용되는데, 이를 *프레임* 이라고 한다.
→ 윈도우 함수에서 프레임을 명시적으로 지정하지 않아도 MySQL 서버는 상황에 맞게 프레임을 묵시적으로 선택한다.
→ 프레임은 레코드의 순서대로 현재 레코드 기준 앞뒤 몇 건을 연산 범위로 제한하는 역할을 한다.

```sql
AGGREGATE_FUNC() OVER(<partition> <order> <frame>) AS window_func_column

frame:
	{ROWS | RANGE} {frame_start | frame_between}

frame_between:
	BETWEEN frame_start AND frame_end

frame_start, frame_end: {
	CURRENT ROW
	| UNBOUNDED PRECEDING
	| UNBOUNDED FOLLOWING
	| expr PRECEDING
	| expr FOLLOWING
}
```

프레임을 만드는 기준으로 ROWS와 RANGE 중 하나를 선택할 수 있다.
- ROWS: 레코드의 위치를 기준으로 프레임을 생성
- RANGE: ORDER BY 절에 명시된 컬럼을 기준으로 값의 범위로 프레임 생성

프레임의 시작과 끝을 의미하는 키워드 의미는 다음과 같다
- CURRENT ROW: 헌재 레코드
- UNBOUNDED PRECEDING: 파티션의 첫 번째 레코드
- UNBOUNDED FOLLOWING: 파티션의 마지막 레코드
- expr PRECEDING: 현재 레코드로부터 n번째 이전 레코드
- expr FOLLOWING: 현재 레코드로부터 n번째 이후 레코드

프레임이 ROWS로 구분되면 expr에는 레코드의 위치를 명시하고, RANGE로 구분되면 expr에는 컬럼과 비교할 값이 설정돼야 한다.
→ 그래서 그레임의 시작과 끝이 expr을 가지는 경우는 다음과 같이 사용될 수 있다.
- 10 PRECEDING: 현재 레코드로부터 10건 이전부터
- INTERVAL 5 DAYS PRECEING: 현재 레코드의 ORDER BY 컬럼값보다 5일 이전 레코드로부터
- 5 FOLLOWING: 현재 레코드로부터 5건 이후까지
- INTERVAL ‘2:30’ MINUTE_SECOND FOLLOWING: 현재 레코드의 ORDER BY 컬럼값보다 2분 30초 이후까지

\<frame\> 절에 대한 간단한 예제는 아래와 같다
- ROWS UNBOUNDED PRECEDING: 파이션의 첫 번째 레코드로부터 현재 레코드까지
- ROWS BETWEEN UNBOUND AND CURRENT ROW: 파티션의 첫 번째 레코드로부터 현재 레코드까지
- ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING: 파티션에서 현재 레코드를 기준으로 앞 레코드부터 뒤 레코드까지
- RANGE INTERVAL 5 DAY PRECEDING: ORDER BY에 명시된 컬럼의 값이 5일 전인 레코드부터 현재 레코드까지
- RANGE BETWEEN 1 DAY PRECEDING AND 1 DAY FOLLOWING: ORDER BY에 명시된 컬럼의 값이 1일 전인 레코드부터 1일 이후인 레코드까지

일부 윈도우 함수들은 프레임이 미리 고정돼 있고, SQL 문장에서 프레임을 별도로 명시하더라도 이러한 윈도우 함수에서는 사용자가 정의한 프레임은 모두 무시된다.
→ 다음 윈도우 함수들은 자동으로 프레임이 파티션의 전체 레코드로 설정된다.
- CUME_DIST()
- DENSE_RANK()
- LAG()
- LEAD()
- NTILE()
- PERCENT_RANG()
- RANK()
- ROW_NUMBER()

### 11.4.12.3 윈도우 함수
MySQL 서버의 윈도우 함수에는 집계 함수와 비 집계 함수를 모두 사용할 수 있다.
→ 집계 함수는 GROUP BY 절과 함께 사용할 수 있는 함수들을 의미하는데, 집계 함수는 OVER() 절 없이 단독으로도 사용될 수 있고, OVER()절을 가진 윈도우 함수도로 사용될 수 있다.
→ 비 집계 함수는 OVER()절을 하지고 있어야 하며 함수로만 사용될 수 있다.

```ad-tip
집계 함수와 비 집계 함수들의 예시는 교재 p.133 ~ 134 에서 확인할 수 있음.
```

**11.4.12.3.1 DENSE_RANK() 와 RANK(), ROW_NUMBER()**
DENSE_RANK() 함수와 RANK() 함수는 모두 ORDER BY 기준으로 매겨진 순위를 반환한다.
→ RANK() 함수는 동점인 레코드가 두 건 이상인 경우, 그다음 레코드를 동점인 레코드 수만큼 증가시킨 순위를 반환한다.
→ DENSE_RANK() 함수는 동점인 레코드를 1건으로 가정하고 순위를 매기기 때문에 연속된 순위를 가진다.
→ ROW_NUMBER() 함수는 똑같이 순위를 매기지만, ROW_NUMBER() 함수는 이름 그대로 각 레코드의 고유한 순번을 반환한다. 그래서 동점에 대한 고려 없이 정렬된 순서대로 레코드 번호를 부여한다.

**11.4.12.3.2 LAG()와 LEAD()**
→ LAG() 함수는 파티션 내에서 현재 레코드를 기준으로 n번째 이전 레코드를 반환한다.
→ LEAD() 함수는 반대로 n번째 이후 레코드를 반환한다.
→ LAG() 함수와 LEAD() 함수는 3개의 파라미터를 필요로 하는데, 첫 번째와 두 번째 파라미터는 필수이며 세 번째 파라미터는 선택 사항이다.

> 첫 번쨰 파라미터는 대상 컬럼, 두 번째 파라미터는 n번째 값, 세 번째 파라미터는 기본값(default)를 의미한다.

### 11.4.12.4 윈도우 함수와 성능
MySQL 서버의 윈도우 함수는 8.0 버전에 처음 도입됐으며, 아직 인덱스를 이용한 최적화가 부족한 부분도 있다.

```sql
-- 1. 윈도우 함수를 이용한 방식
SELECT MAX(from_date) OVER (PARTITION BY emp_no) AS max_from_date
FROM salaries;

-- 2 GROUP BY를 이용한 방식
SELECT MAX(from_date) FROM salaries GROUP BY emp_no;
```
- 이 둘은 근본적으로 차이가 있어서 서로 다른 실행 계획을 보인다.
	- 윈도우 함수
		- 인덱스 풀 스캔을 시도한다.
		- Using filesort가 나타라는 것으로, 정렬 작업까지 수행한다.
	- GROUP BY
		- 별도의 정렬 작업 없이 루스 인덱스 스캔으로 MAX(from_date) 값을 찾아낸다.
- 윈도우 함수는 salaries 테이블의 모든 레코드 건수만큼의 결과를 만들어야 하지만 GROUP BY 절을 사용하는 쿼리는 유니크한 emp_no 별로 레코드 1건씩만 결과를 만들면 된다.

윈도우 함수를 이용한 쿼리는 프라이머리 키(emp_no, from_date)를 충분히 활용할 법한 쿼리지만 윈도우 함수 부분은 이 인덱스를 전혀 활용하지 못했다.
→ 인덱스 풀 스캔을 하긴 했지만, 이는 윈도우 함수 처리를 위한 것이 아니라 ix_salary 인덱스에 쿼리 처리에 필요한 컬럼이 모두 포함돼 있으면서 프라이머리 키보다 크기가 작기 때문에 활용했을 뿐이다.

쿼리 요건에 따라 GROUP BY나 다른 기존 기능으로는 윈도우 함수를 대체할 수 없겠지만, 가능하다면 윈도우 함수에 너무 의존하지 않는 것이 좋다.
→ 배치 프로그램이라면 윈도우 함수를 사용해도 무방하다.
→ 온라인 트랜잭션 처리에서는 많은 레코드에 대해 윈도우 함수를 적용하는 것은 가능하면 피하는 것이 좋다.
→ 소량의 레코드에 대해서라면 윈도우 함수를 사용해도 메모리에서 빠르게 처리될 것이므로 특별히 성능에 대해 고민하지 않아도 된다.

## 11.4.13 잠금을 사용하는 SELECT 
> InnoDB 테이블에 대해서는 레코드를 SELECT 할 때 레코드에 아무런 잠금도 걸지 않는데, 이를 잠금 없는 읽기(Non Locking Consistent Read) 라고 한다.

SELECT 쿼리를 이용해 읽은 레코드의 컬럼 값을 어플리케이션에서 가동해서 다시 업데이트하고자 할 때는 SELECT가 실행된 후 다른 트랜잭션이 그 컬럼의 값을 변경하지 못하게 해야 한다.
→ 이럴 때는 레코드를 읽으면서 강제로 잠금을 걸어 둘 필요가 있다.
→ 이때 사용하는 옵션이 `FOR SHARE` 와 `FOR UPDATE` 절이다.
- FOR SHARE:SELECT 쿼리로 읽은 레코드에 대해서는 읽기 잠금을 건다
- FOR UPDATE: SELECT 쿼리가 읽은 레코드에 대해서 쓰기 잠금을 건다.

두 가지 잠금 옵션은 모두 자동 커밋이 비활성화된 상태 또는 BEGIN 명령이나 START TRANSACTION 명령으로 트랜잭션이 시작된 상태에서만 잠금이 유지된다.
- FOR SHARE:
	- SELECT된 레코드에 대해 읽기 잠금(공유 잠금, Shared lock)을 설정
	- 다른 세션에서 해당 레코드를 변경하지 못하게 한다.
	- 다른 세션에서 잠금이 걸린 레코드를 읽는 것은 가능하다.
- FOR UPDATE:
	- 쓰기 잠금(배타 잠금, Exclusive lock)을 설정
	- 다른 트랜잭션에서는 그 레코드를 변경하는 것뿐 아니라 읽기도 수행할 수 없다.

InnoDB 스토리지 엔진을 사용하는 테이블에서는 잠금 없는 읽기가 지원되기 때문에 특정 레코드가 `SELECT ... FOR UPDATE` 쿼리에 의해 잠겨진 상태라도 단순 SELECT 쿼리는 아무런 대기 없이 실행된다.

### 11.4.13.1 잠금 테이블 선택
MySQL 8.0 이전 버전에서는 선택적으로 잠금을 걸 수 있는 옵션이 없었지만, MySQL 8.0 버전부터는 잠금을 걸 수 있는 테이블을 선택할 수 있는 기능이 개선됐다.
```sql
SELECT *
FROM employees e
INNER JOIN dept_emp de ON de.emp_no=e.emp_no
INNER JOIN departments ON dept_no=de.dept_no
WHERE e.emp_no=10001
FOR UPDATE OF e;   -- 잠금을 걸 특정 테이블 선택
```
- FOR UPDATE 뒤에 `OF 테이블` 절을 추가하면 해당 테이블에 대해서만 잠금을 걸게 된다.

### 11.4.13.2 NOWAIT & SKIP LOCKED
MySQL 8.0 버전부터는 `NOWAIT` 와 `SKIP LOCKED` 옵션을 사용할 수 있게 기능이 추가됐다.
```sql
-- 1. NOWAIT
SELECT * FROM employees
WHERE emp_no=10001
FOR UPDATE NOWAIT;

-- 2. SKIP LOCKED
SELECT * FROM salaries 
WHERE emp_no=10001
FOR UPDATE SKIP LOCKED;
```

- NOWAIT
	- **특정 레코드가 잠겨 있을 때 에러를 반환한다**. 그로 인해 어플리케이션 환경에서 다른 처리를 수행하거나 다시 트랜잭션을 시작할 수 있도록 해준다.
	- 해당 옵션을 사용하면 SELECT 쿼리가 해당 레코드에 대해 즉시 잠금을 획득 했다면 NOWAIT 옵션이 없을 때와 동일하게 실행된다.
	- 하지만 해당 레코드가 다른 트랜잭션에 의해서 잠겨진 상태라면 에러를 반환하면서 쿼리가 즉시 종료된다.
- SKIP LOCKED
	- SELECT하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면 에러를 반환하지 않고 **잠긴 레코드를 무시하고 잠금이 걸리지 않은 레코드만 가져온다.**
	- 이런 이유로 SKIP LOCKED 절을 가진 SELECT 구분은 확정적이지 않은 (NOT-DETERMINISTIC) 쿼리가 된다.

NOWAIT과 SKIP LOCKED 절은 SELECT … FOR UPDATE 구문에서만 사용할 수 있으며, UPDATE나 DELETE 쿼리에서는 사용할 수 없다.
→ NOWAIT나 SKIP LOCKED 절은 쿼리 자체를 비확정적으로 만들기 때문에 UPDATE나 DELETE 문장에서 사용된다면 실행될 때마다 데이터베이스의 상태를 다른 결과로 만들게 된다.
