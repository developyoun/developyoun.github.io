---
title: 9.3 고급 최적화

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

옵티마이저 옵션은 크게 **조인과 관련된 옵티마이저** 옵션과 **옵티마이저 스위치**로 구분할 수 있다.

## 9.3.1 옵티마이저 스위치 옵션
옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수로 이용해서 제어한다.
→ 해당 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용한다.

```ad-tip
여러 개의 옵션들을 책 p.318 ~ 319 에서 확인할 수 있다.
```

옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이기에 커넥션 별로 설정할 수 있다.
```sql
-- MySQL 서버 전체적으로 옵티마이저 스위치 설정
SET GLOBAL optimizer_switch='index_merge-on,index_merge_union=on,...';

-- 현재 커넥션의 옵티마이저 스위치만 설정
SET SESSION optimizer_switch='index_merge_on,index_merge_union=on,....'
```

`SET_VAR` 옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수도 있다.
```sql
SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off)'*/
...
FROM ...
```

### 9.3.1.1 MRR과 배치 키 엑세스 (mrr & batched_key_access)
MRR은 Multi-Range Read 의 줄임말이다.
MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리하지만, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다.
→ 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 수행할 수가 없다.
→ 이러한 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인 버퍼에 버퍼링한다.
→ **즉, 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링하는 것이다.**
→ 조인 버퍼에 레코드가 가득 차면 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다.
```ad-note
데이터 페이지가 메모리(InnoDB 버퍼 풀)에 있다고 하더라도, 버퍼 풀의 접근을 최소화할 수 있다.
```

위와 같은 읽기 방식을 MRR이라고 하며, MRR을 응용해서 실행되는 조인 방식을 *BKA(Batched Key Access)* 조인이라고 한다.
→ BKA는 기본적으로 비활성화 되어 있는데, 이는 쿼리의 특성에 따라 BKA 조인이 부가적인 정렬 작업이 필요해지면서 성능에 안좋은 영향을 미치는 경우를 고려한 것이다.

### 9.3.1.2 블록 네스티드 루프 조인 (block nested loop)

```ad-info
- MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인(Nested Loop Join)인데, 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.

- 조인 알고리즘에서 "Block" 이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용되었다는 것을 의미한다.
조인 쿼리의 실행 계획에서 Extra컬럼에 Using Join Buffer라는 문구가 보이면 그 실행 계획은 조인 버퍼를 사용한다는 것을 의미한다.
```
네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 자이는 **조인 버퍼가 사용되는 여부**와 **조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐** 이다.

조인은 드라이빙 테이블에서 일차하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리되는데, 이는 곧 드라이빙 테이블은 한 번에 쭉 읽지만 드리븐 테이블은 여러 번 읽는다는 것을 의미한다.
→ 만약 드리븐 테이블이 인덱스를 사용할 수 없다면 풀 테이블 스캔을 해야한다.
→ 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리한다.
→ 이때 사용되는 메모리의 캐시를 조인 버퍼라고 한다.
→ 조인 버퍼는 `join_buffer_size` 라는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제된다.

블록 네스티드 루프 조인은, **실제 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에 일치하는 레코드를 찾는 방식으로 처리된다.**
→ 조인을 수행한 후, 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 **정렬 순서가 흐트러질 수 있다.**

### 9.3.1.3 인덱스 컨디션 푸시다운 (index_condition_pushdown)
```ad-note
인덱스 컨디션 푸시다운 기능은 옵티마이저 스위치의 'index_condition_pushdown' 설정을 통해 설정할 수 있다.
```

MySQL 5.5 인덱스를 범위 제한 조건으로 사용하지 못하는 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달해주지 않았다.
→ 그래서 스토리지 엔진에서는 불필요한 테이블 읽기를 수행하는 경우가 발생했다.

MySQL 5.6 버전부터는 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스가 포함된 컬럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선되었다.
> 인덱스 컨디션 푸시다운 기능은 고도의 기술력을 필요로하진 않지만, 쿼이의 성능이 몇 배에서 몇십 배로 향상될 수도 있는 중요한 기능이다.

### 9.3.1.4 인덱스 확장 (use_index_extensions)
`use_index_extenstions` 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.

### 9.3.1.5 인덱스 머지 (index_merge)
인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립하지만,
**인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.**
→ 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

인덱스 머지 실행 계획은 3개의 세부 실행 계획으로 나누어 볼 수 있다.
- index_merge_intersection
- index_merge_sort_union
- index_merge_union

### 9.3.1.6 인덱스 머지 - 교집합 (index_merge_intersection)
```sql
EXPLAIN SELECT *
FROM employees
WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
```

예제로, employees 테이블의 *first_name* 컬럼과 *emp_no* 컬럼 모두 각각의 인덱스를 가지고 있을 때, 2개 중에서 어떤 조건을 사용하더라도 인덱스를 사용할 수 있다.
그래서 옵티마이저는 해당 키들을 모두 사용해서 쿼리를 처리하기로 결정한다.
→ 실행 계획의 extra 컬럼에 “Using intersct” 라고 표현된 것은 이 쿼리가 여러개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 것을 의미한다.

```ad-info
각 조건들이 (first_name='Georgi') 254개, (10000 < emp_no < 20000) 10000개를 반환한다고 생각하고 두 조건을 모두 만족하는 결과는 고작 14개라고 가정했을 때,
옵티마이저는 각각 254-14인 240개가 불필요하며, 10000-14인 9986개가 불필요하다고 판단하고 교집합만 찾아 반환했다고 예상해볼 수 있다.
(다만, PK 컬럼인 부분을 고려하면 다른 최적화를 수행할 수도 있다)
```

만약, index_merge_instersection 최적화를, 서버 전체, 현재 커넥션, 현재 쿼리에 대해 각각 비활성화 하고 싶을 수 있다.
```sql
-- MySQL 서버 전체적으로 index_merge_intersction 최적화 비활성화
SET GLOBAL optimizer_switch='index_merge_intersection=off';

-- MySQL 서버 전체적으로 index_merge_intersction 최적화 비활성화
SET SESSION optimizer_switch='index_merge_intersection=off';

-- MySQL 서버 전체적으로 index_merge_intersction 최적화 비활성화
EXPLAIN SELECT /*+ SET_VAR(optimizer_switch='index_merge_instersection=off') */ 
FROM employees
WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
```

### 9.3.1.7 인덱스 머지 - 합집합 (index_merge_union)
인덱스 머지의 “Using union” 은 WHERE 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용되는 최적화이다.
→ 이 최적화는 실행 계획에 “Using union” 으로 출력된다.

만약, 합집합의 결과에서 중복된 값을 가지게 된다면 MySQL 서버는 **결과 집합을 정렬해서 중복 레코드를 제거한다.**
여기서 정렬은, MySQL 서버가 검색 결과들이 **프라이머리 키로 정렬되어 있음을** 알고 있고, 각각의 결과를 **우선순위 큐를 이용한 알고리즘으로** 중복 결과를 필터링한다.

### 9.3.1.8 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)
인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우에는 MySQL 서버가 인덱스 머지 최적화의 “Sort union” 알고리즘을 사용한다.

이런 케이스가 있을 수 있다, 여러 조건 중에서 하나의 컬럼이 정렬되지 못하는 상황에는 우선순위 큐 알고리즘을 적용할 수 없다. 
→ 이 상황에서 여러 집합 결과의 중복을 제거하기 위해 강제적으로 정렬을 시키고 중복제거를 수행한다.
→ 인덱스 머지 최적화에서 중복 제거를 위해 강제로 정렬을 수행해야 하는 경우에는 Extra 컬럼에 “Using sort_union” 문구가 표시된다.

### 9.3.1.9 세미 조인 (semi join)
다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건이 일치하는 레코드가 있는지 없는지 체크하는 형태의 쿼리를 세미 조인이라고 한다.
세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리는 최적화 방법이 조금 차이가 있다.

1. 세미 조인 쿼리:  `= (subquery)` 및 `IN (subquery)` 형태
	- 세미 조인 최적화
	- IN-to-EXISTS 최적화
	- MATERIALIZATION  최적화
2. 안티 세미 조인 쿼리: `<> (subquery)` 및 `NOT IN (subquery)` 형태
	- IN-to_EXISTS 최적화
	- MATERIALIZATION 최적화

MySQL 서버 메뉴얼에서는 아래 최적화 전략들을 모아서 세미 조인 최적화라고 부른다.
- Table Pull-out
- Duplicate Weed-out
- First Match
- Loose Scan
- Materialization
쿼리에 사용되는 테이블과 조인 조건의 특성에 따라 MySQL 옵티마이저는 사용 가능한 전략들을 선별적으로 사용한다.
- Table pull-out 전약은 사용 가능하면 항상 세미 조인보다는 좋은 성능을 내기 때문에 별도로 제어하는 옵티마이저 옵션은 없다.
- First Match와 Loose Scan 최적화 전략은, 각각 `firstmatch`와 `loosescan` 옵션으로 사용 여부를 결정할 수 있다.
- Duplicate Weed-out과 Materialization 최적화 전략은 `matericalization` 옵티마이저 스위치로 사용여부를 선택할 수 있다.
- `optimizer_switch` 시스템 변수의 `semijoin` 옵티마이저 옵션은 `firstmatch`, `loosescan`, `materialization` 옵티마이저 옵션을 한 번에 활성/비활성 할 때 사용한다.

### 9.3.1.10 테이블 풀-아웃 (Table Pull-out)
Table pullout 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화이다.

Table pullout  최적화는 별도로 실행 계획의 Extra 컬럼에 “Using table pullout” 과 같은 문구가 출력되지 않는다.
→ 그래서 해당 최적화가 사용됐는지는 실행 계획에서 해당 테이블들의 id 컬럼값이 같은지 다른지를 비교해보는 것이 가장 간단한 방법이다.
→ Table pullout 최적화가 사용됐는지 더 정확하게 확인하는 방법은 EXPAIN 명령을 실행한 직후 `SHOW WARNINGS` 명령으로 옵티마이저가 재작성한 쿼리를 살펴보는 것이다.

Table pullout 최적화는 모든 형태의 서브쿼리에서 사용될 수 있는 것은 아니다. 몇 가지 제한 사항과 특성을 살펴보자
- Table pullout 최적화는 세미 조인 서브쿼리에만 사용 가능하다.
- Table pullout 최적화는 서브쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.
- Table pullout이 적용된다고 하더라도 기존 쿼리에만 가능했던 최적화 방법이 사용 불가능한 것은 아니므로 MySQL에서는 가능하다면 Table pullout 최적화를 최대한 사용한다.
- Table pullout 최적화는 서브쿼리의 테이블을 아우터 쿼리로 가져와서 조인으로 풀어쓰는 최적화를 수행하는데, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다.
- MySQL에서는 “최대한 서브쿼리를 조인으로 풀어서 사용해라”라는 튜닝 가이드가 많은데, Table pullout 최적화는 이 가이드를 그대로 실행하는 것이다.
	- 서브쿼리를 조인으로 풀어서 사용할 필요가 없다.

### 9.3.1.11 퍼스트 매치 (firstmatch)
First Match 최적화 전략은 `IN (subquery)` 형태의 세미 조인을 `EXISTS (subquery)` 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
First Match 최적화는 MySQL 5.5 버전에서 수행한 IN-to-EXISTS 반환과 거의 비슷하지만, 그에 비해 다음과 같은 장점이 있다.
- 여러 테이블이 조인되는 경우 원래 쿼리에는 없던 동등 조건을 옵티마이저가 자동으로 추가하는 형태의 최적화가 실행되기도 한다.
	- IN-to-EXISTS 최적화에서는 동등 조건 전파가 서브쿼리 내에서만 가능했다.
	- FirstMatch에서는 조인 형태로 처리되기 때문에 서브쿼리뿐만 아니라, 아우터 쿼리의 테이블까지 전파될 수 있다.
- IN-to_EXISTS 변환 최적화 전략에서는 아무런 조건 없이 변환이 가능한 경우에는 무조건 그 최적화를 수행했다.
	- 하지만 FirstMatch 최적화에서는 서브쿼리의 모든 테이블에 대해 FirstMatch 최적화를 수행할지 아니면 일부 테이블에서만 수행할지 취사선택할 수 있는 장점이 있다.

FirstMatch 최적화에는 몇가지 제한 사항과 특성이 있다.
- FirstMatch 서브쿼리에서 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로이기 때문에, 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
- 실행 계획의 Extra 컬럼에는 “FirstMatch(table-N)” 문구가 표시된다.
- 상관 서브쿼리 (Correlated subquery)에서도 사용될 수 있다.
- GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.

FirstMath 최적화는 `optimizer_switch` 시스템 변수에 `semijoin` 옵션과 `firstmatch` 옵션이 모두 ON으로 활성화된 경우에만 사용할 수 있다.

### 9.3.1.12 루스 스캔 (loosescan)
세민 조인 서브쿼리 최적화의 LooseScan은 인덱스를 사용하는 `GROUP BY` 최적화 방법에서 살펴본 “Using index for group-by”의 루스 인덱스 스캔과 비슷한 읽기 방식을 사용한다.

LooseScan 최적화는 다음과 같은 특성을 가진다.
- 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다.
	- 그래서 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화이다.
- 루스 인덱스 스캔 최적화는 다음과 같은 형태의 서브쿼리들에서 사용할 수 있다.
	- `SELECT ... FROM ... WHERE expr IN (SELECT keypart1 FROM tab WHERE ... )`
	- `SELECT ... FROM ... WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1='상수' ... )`
- 루스 인덱스 스캔 최적화를 사용하면 Extra 컬럼에 “LooseScan” 문구가 표시된다.

옵티마이저가 LooseScan 최적화를 사용하지 못하게 비활성화하려면, `optimizer_switch` 시스템 변수에 `loosescan` 최적화 옵션을 off 로 설정하면 된다.

### 9.3.1.13 구체화 (Materialization)
Materialization 최적회는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미이다.
→ 쉽게 말해서, 구체화는 내부 임시 테이블을 생성한다는 것을 의미한다.

```sql
EXPLAIN 
SELECT * 
FROM employees e
WHERE e.emp_no IN (
	SELECT de.emp_no 
	FROM dept_emp de
	WHERE de.from_date='1996-01-01'
);
```
- 위 쿼리를 FirstMatch 최적화를 사용하면 employees 테이블에 대한 조건이 서브쿼리 이외에는 아무것도 없기에 employees 테이블을 풀스캔 할 것이다.
- 위와 같은 형태의 세미 조인에서는 FirstMatch 최적화가 성능 향상에 별로 도움이 되지 않는다.
- 옵티마이저는 이런 형태의 쿼리를 위해 서브쿼리 구체화라는 최적화를 도입했다.
	- 구체화를 이용하면 실행 계획에서 select_type 컬럼이 “MATERIALIZATION” 라고 표시된다.

Materialization 최적화가 사용될 수 있는 형태의 쿼리에도 몇 가지 제한 사항과 특성이 있다.
- `IN (subquery)` 에서 서브쿼리는 상관 서브쿼리가 아니어야 한다.
- 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
- 구제화가 사용된 경우에는 내부 임시 테이블이 사용된다.

### 9.3.1.14 중복 제거 (Duplicated Weed-out)
Duplicated Weedout은 세미 조인 서브쿼리를 일반적인 `INNER JOIN` 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.
→ 실제로 Duplicated Weedout 최적화 알고리즘은 원본 쿼리를 `INNER JOIN` + `GROUP BY` 절로 바꿔서 실행하는 것과 동일한 작업으로 처리한다.

Duplicated Weedout 최적화를 실행해도 실행 계획에서 별도의 “Duplicated Weedout” 이라는 문구가 표시되진 않는다.
→ Extra 컬럼에는 “Start temporay” 와 “End temporary” 문구가 별도로 표기된다.

Duplicated Weedout 최적화는 다음과 같은 장점과 제약 사항이 있다.
- 서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있는 최적화이다.
- 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
- Duplicated Weedout은 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

### 9.3.1.15 컨디션 팬아웃 (condition_fanout_filter)
조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다.
`condition_fanout_filter` 최적화는 MySQL 옵티마이저가 인덱스를 사용할 수 있는 컬럼 조건 이외의 나머지 조건에 대해서 얼마나 조건을 충족할지 고려한다.
→ 즉, condition_fanout_filter 최적화가 비활성화 된 경우에는 테이블이 모든 조건을 충족하는 레코드를 예측하지만, 활성화된 경우에는 나머지 조건을 고려하여 정확한 건수를 도출 해내는 것이다.
→ MySQL 옵티마이저가 조건을 만족하는 레코드 건수를 정확하게 예측할 수 있다면 더 빠른 실행 계획을 만들어 낼 수 있다.

condition_fanout_filter 최적화는 다음과 같은 조건을 만족하는 컬럼의 조건들에 대해 조건을 만족하는 레코드 비율을 계산할 수 있다.
- WHERE 조건절에 사용된 컬럼에 대해 인덱스가 있는 경우
- WHERE 조건절에 사용된 컬럼에 대해 히스토그램이 존재하는 경우

condition_fanout_filter 최적화 기능을 사용하면 옵티마이저는 더 정교한 계산을 거쳐서 실행 계획을 수립한다.
→ 그에 따라 쿼리의 실행 계획 수립에 더 많은 시간과 컴퓨팅 자원을 사용하게 된다.

### 9.3.1.16 파생 테이블 머지 (derived_merge)
derived 테이블은 MySQL 서버가 내부적으로 만든 임시 테이블이다.  MySQL 5.7 미만 버전에서는 다음과 같은 문제가 있었다.
→ 임시 테이블로 레코드를 복사하고 다시 읽는 과정은 오버헤드가 추가된다.
→ 또한, 임시 테이블은 처음에는 메모리에 생성되지만 임시 테이블이 저장될 레코드 건수가 많아지면 결국 디스크로 기록되어야 한다. 이 과정에서 성능이 저하 될 수 있다.

MySQL 5.7 버전부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입되었다.
→ 바로, `derived_merge` 최적화 옵션인데, 임시 테이블 최적화를 활성화할지 여부를 결정한다.
→ 이는 서브쿼리로 작성된 쿼리를 외부 쿼리로 병합시키는 최적화이다.

MySQL 옵티마이저는 서브쿼리를 외부 쿼리로 병합하여 처리 할 수 있게 되었지만, 모든 쿼리에 대해 그런 것은 아니다.
→ 아래와 같은 조건에서는 사용할 수 없기에, 가능하다면 서브쿼리는 외부 쿼리로 수동으로 병합해서 작성하는 것이 성능 향상에 도움이 된다.
- `SUM()` 또는 `MIN(),` `MAX()` 같은 집계 함수와 윈도우 함수가 사용된 서브쿼리
- `DISTINCT`가 사용된 서브쿼리
- `GROUP BY`나 `HAVING` 이 사용된 서브쿼리
- `LIMIT`이 사용된 서브쿼리
- `UNION` 또는 `UNION ALL` 을 포함하는 서브쿼리
- `SELECT` 절에 사용된 서브쿼리
- 값이 변경되는 사용자 변수가 사용된 서브쿼리

### 9.3.1.17 인비저블 인덱스 (use_invisible_indexes)
MySQL 8.0 버전부터는 인덱스의 가용 상태를 제어할 수 있는 기능이 추가됐다.
```sql
-- 옵티마이저가 ix_hiredate 인덱스를 사용하지 못하게 변경
ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE;

-- 옵티마이저가 ix_hiredate 인덱스를 사용할 수 있게 변경
ALTER TABLE employees ALTER INDEX ix_hiredate VISIBLE;
```
- `use_invisible_indexes` 옵티마이저 옵션을 이용하면 `INVISIBLE` 로 설정된 인덱스라 하더라도 옵티마이저가 사용하게 제어할 수 있다.

### 9.3.1.18 스킵 스캔 (skip_scan)
인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다.
→ 인덱스 스킵 스캔은 제한적이긴 하지만, 인덱스의 순서로 인한 제약 사항을 뛰어 넘을 수 있는 최적화 기법이다.

MySQL 8.0 버전부터는 인덱스 스킵 스캔 최적화가 도입됐으며, 인덱스 스킵 스캔 컬럼이 조건절에 사용되지 않더라도 후행 컬럼의 조건만으로 인덱스를 이용한 쿼리 성능 개선이 가능하다.
→ 하지만, 인덱스의 선행 컬럼이 매우 다양한 값을 가지는 경우에는 인덱스 스킵 스캔 최적화가 비효율적일 수 있다.
→ 그래서 MySQL 8.0 옵티마이저는 인덱스의 선행 컬럼이 소수의 유니크한 값을 가질때만 인덱스 스킵 스캔 최적화를 사용한다.

### 9.3.1.19 해시 조인 (hash_join)
해시 조인은 기존 네스티드 루프 조인과 종종 비교되는데, 많은 사용자들이 해시 조인이 더 빠르다고 얘기한다.
→ 그러나, 이는 항상이 옳은 것은 아니다.
- 해시 조인은 처음 레코드를 찾는데 시간이 많이 걸리지만, 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다.
	- 해시 조인은 최고 스루풋 전략에 적합하다.
	- 분석과 같은 서비스에서는 전체 처리 소요 시간이 중요하기 때문에, 전체 스루풋이 더 중요하다.
- 네스티드 루프 조인은 처음 레코드를 찾는데 상대적으로 빠르지만, 마지막 레코드를 찾는 데까지는 시간이 많이 걸린다.
	- 네스티드 루프 조인은 최고 응답 속도 전략에 적합하다.
	- 일반적인 웹 서비스에서는 온라인 트랜잭션 서비스이기 때문에, 응답 속도가 더 중요하다.

→ RDBMS는 온라인 트랜잭션 처리를 위한 데이터베이스를 주로 사용하고 있으며, 대용량 데이터 분석을 위해서 MySQL를 사용하진 않을 것이다.
→ 이런 이유로, MySQL 서버는 주로 조인 조건의 컬럼이 인덱스가 없다거나 조인 대상 테이블 중 일부의 레코드 건수가 매우 적은 경우 등에 대해서만 해시 조인 알고리즘을 사용하도록 설계되어있다.
→ 즉, 해시 조인 최적화는 네스티드 루프 조인이 사용됙에 적합하지 않은 경우를 위한 차선책 같은 기능으로 생각하는 것이 좋다.

일반적으로 해시 조인은 빌드 단계 (Build-Phase)와 프로브 단계 (Probe-phase)로 나뉘어 처리된다.
- **빌드 단계**
	- 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성하는 작업 수행
	- 이 단게에서 해시 테이블을 만들 때 사용되는 원 테이블을 빌드 테이블이라고 한다.
- **프로브 단계**
	- 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정
	- 이때 읽는 나머지 테이블을 프로브 테이블이라고 한다.

→ 하지만 실행 계획에서는 어느 테이블이 빌드 테이블이고 프로브 테이블인지 식별하기 어렵다.
→ 이런 경우에는 `EXPLAIN FORMAT=TREE` 명령 또는 `EXPLAIN ANALYZE` 명령을 사용하면 좀 더 쉽게 구분할 수 있다.

해시 테이블을 메모리에 저장할 때 MySQL 서버는 `join_buffer_size` 시스템 변수로 크기를 제어할 수 있는 조인 버퍼를 사용한다.
→ 조인 버퍼의 기본 크기는 256KB인데, 해시 테이블의 레코드 건수가 많아서 조인 버퍼의 공간이 부족할 수도 있다.
→ 이런 경우, 빌드 테이블과 프로브 테이블을 적당한 크기의 청크로 분리한 다음, 청크별로 해시 조인 (메모리에서 모두 처리가능한 경우)으로 처리한다. (클래식 해시 조인 알고리즘)
→ 해시 조인 1차 처리(메모리가 부족한 경우) 는 조인 버퍼보다 해시 테이블이 큰 경우 해시 조인이 실행된다. (그레이스 해시 조인 알고리즘)
→ 1차 조인이 완료되면 청크 단위로 조인을 수행하기 위해 2차 해시 함수를 이용해 빌드 테이블과 프로브 테이블을 동일 개수의 청크로 쪼개어 디스크로 저장한다.

### 9.3.1.20 인덱스 정렬 선호 (prefer_ordering_index)
MySQL 옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우, 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행된다.

→ MySQL 8.0.20 버전까지는 옵티마이저의 실수가 자주 발생하면 다른 실행 계획을 사용하게 하기 위해 특정 인덱스를 사용하지 못하도록 “IGNORE INDEX” 힌트를 사용하거나 했다.
→ MySQL 8.0.21 버전부터는 MySQL 서버 옵티마이저가 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 `prefer_ordering_index` 옵티마이저 옵션이 추가됐다.

## 9.3.2 조인 최적화 알고리즘
MySQL에서는 최적화된 조인 실행 계획 수립을 위한 2가지 알고리즘이 있다.

### 9.3.2.1 Exhaustive 조인 검색 알고리즘
Exhaustive 검색 알고리즘은 MySQL 5.0과 그 이전 버전에서 사용되던 조인 최적화 기법으로, FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.
→ 테이블이 20개라면 이 방법으로 처리했을 때, 가능한 조인 조합은 모두 20! (36288000)개가 된다.

### 9.3.2.2 Greedy 검색 알고리즘
greedy 검색 알고리즘은 Exhaustive 검색 알고리즘의 시간 소모적인 문제점을 해결하기 위해 MySQL 5.0부터 도입된 조인 최적화 기법이다.
greedy 검색 알고리즘은 조금 복잡한 형태로 최적의 조인 순서를 결정한다.
1. 전체 N개의 테이블 중에서 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
3. 2번에서 선정된 실행 계획의 첫 번째 테이블을 “부분 실행 계획”의 첫 번째 테이블로 선정
4. 전체 N-1개의 테이블 중에서 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 “부분 실행 계획”에 대입해 실행 비용을 계산
6. 5번의 비용 계산 결과, 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 “부분 실행 계획”의 두 번째 테이블로 선정
7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복 실행하면서 “부분 실행 계획”에 테이블의 조인 순서를 기록
8. 최종적으로 "부분 실행 계획"이 테이블의 조인 순서로 결정됨

greedy 검색 알고리즘은 `optimizer_search_depth` 시스템 변수에 설정된 값에 따라 조인 최적화의 비용이 상당히 줄어들 수 있다. (기본값은 62)

MySQL에서는 조인 최적화를 위한 시스템 변수로 `optimizer_prune_level`과 `optimizer_search_depth`가 제공된다.
- **optimizer_search_depth**
	- 검색 알고리즘 중에서 어떤 알고리즘을 사용할지 결정하는 시스템 변수
	- 0~62까지 정숫값을 설정할 수 있다
		- 1~62까지의 정숫값이 설정되면 gredy 검색 대상을 지정된 개수로 한정해서 최적의 실행 계획을 산출
		- 0으로 설정되면 greddy 검색을 위해 최적의 조인 검색 테이블의 개수를 옵티마이저가 자동으로 결정
	- 설정 값과 쿼리의 조인 테이블 개수에 따라 exhaustive 검색만 사용되거나, greedy 검색이 동시에 사용된다.
	- 조인에 사용된 테이블의 개수가 `optimizer_search_depth` 설정값보다 크다면 `optimizer_search_depth` 만큼의 테이블은 Exhaustive 검색이 사용된고 나머지 테이블은 greedy 검색이 사용된다.
	- 조인에 사용된 테이블의 개수가 `optimizer_search_depth` 설정 값보다 작다면 Exhaustive 검색만 사용된다.
	- 기본값은 62인데, 많은 테이블이 조인되는 쿼리에서는 상당히 부담될 수 있다.
		- `optimizer_prune_level` 시스템 변수가 0으로 설정된 경우에는 `optimizer_search_depth` 설정값이 쿼리의 성능에 심각한 영향을 미칠 수 있으니, `optimizer_search_depth`를 4~5 정도로 설정하는 것이 좋다.
- **optimizer_prune_level**
	- MySQL 5.0부터 추가된 Heuristic 검색이 작동하는 방식을 제어
	- Heuristic 검색의 가장 핵심적인 내용은 다양한 조인 순서의 비용을 계산하는 도중 이미 계산했던 조인 순서의 비용보다 큰 경우에는 언제든지 중간에 포기할 수 있다는 것.
	- 아우터 조인으로 연결되는 테이블은 우선순위에서 제거하는 등 경험 기반의 최적화도 Heuristic 검색 최적화에는 포함돼 있다.
	- 1로 설정되면 옵티마이저는 조인 순서 최적화에 경험 기반의 heuritic 알고리즘을 사용한다.
	- 0으로 설정되면 경험 기반의 heuritic 최적화가 적용되지 않는다.
