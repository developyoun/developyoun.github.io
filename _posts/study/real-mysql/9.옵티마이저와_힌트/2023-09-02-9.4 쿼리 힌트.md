---
title: 9.4 쿼리 힌트

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

일반적인 RDBMS에서는 쿼리의 실행 계획을 어떻게 수립해야 할지 알려주는 목적으로 힌트가 제공되며, MySQL에서도 다양한 옵티마이저 힌트를 제공한다.
→ MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같이 2가지로 구분할 수 있다.
- 인덱스 힌트
- 옵티마이저 힌트

## 9.4.1 인덱스 힌트

```ad-warning
인덱스 힌트들은 모두 SQL의 문법에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점이 있다.
가능하다면, 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 추천한다.
```

### 9.4.1.1 STRAIGHT_JOIN
`STRAIGHT_JOIN`은 옵티마이저 힌트인 동시에 조인 키워드이기도 하다.
→ STRAIGHT_JOIN은 SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.

일반적으로 조인을 하기 위한 컬럼들의 인덱스 여부로 조인의 순서가 결정되며, 조인 컬럼의 인덱스에 아무런 문제가 없는 경우에는 레코드가 적은 테이블을 드라이빙으로 선택한다.
→ 여기서 쿼리의 조인 순서를 변경하려는 경우에는 STRAIGHT_JOIN 힌트를 사용할 수 있다.
```sql
SELECT STRAIGHT_JOIN ...
FROM ...
WHERE ...
```
- 이러면 FROM 절에 명시된 테이블의 순서대로 조인을 수행하도록 유도한다.

주로 다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는 것이 좋다.
- 임시 테이블과 일반 테이블의 조인:
	- 거의 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
	- 일반 테이블의 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 쪽을 먼저 읽도록 드라이빙으로 선택하는 것이 좋다.
	- 대부분 옵티마이저가 적절한 조인 순서를 선택하기 때문에 쿼리를 작성할 때부터 힌트를 사용할 필요는 없다.
- 임시 테이블끼리 조인:
	- 임시 테이블은 항상 인덱스가 없기 때문에, 어느 테이블을 먼저 드라이빙으로 읽어도 무관하다.
	- 대신 크기가 작은 테이블을 드라이빙으로 선택해주는 것이 좋다.
- 일반 테이블끼리 조인:
	- 양쪽 테이블 모두 조인 컬럼에 있거나 양쪽 테이블 모두 조인 컬럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋다.
	- 그 이외의 경우에는 조인 컬럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋다.  

STRAIGHT_JOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트로는 다음과 같은 것들이 있다.
- `JOIN_FIXED_ORDER`
- `JOIN_ORDER`
- `JOIN_PREFIX`
- `JOIN_SUFFIX`

→ `JOIN_FIXED_ORDER` 옵티마이저 힌트는 STRAIGHT_JOIN 힌트와 동일한 효과를 낸다.
→ 나머지 3개의 옵티마이저 힌트는 일부 테이블의 조인 순서에 대해서만 제안하는 힌트이다.

### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX
이 힌트들은 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.
- **USE INDEX**
	- 가장 자주 사용되는 인덱스 힌트
	- MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용도록 권장하는 힌트
	- 대부분의 경우 인덱스 힌트가 주어지면 옵티마이저는 사용자의 힌트를 채택하지만 그 인덱스를 사용하는 것은 아니다.
- **FORCE INDEX**
	- USE INDEX보다 미치는 영향이 더 강한 힌트
	- 하지만, USE INDEX가 미치는 옵티마이저의 영향력이 충분히 크기 때문에 FORCE INDEX는 거의 사용할 필요가 없어 보인다.
- **IGNORE INDEX**
	- 특정 인덱스를 사용하지 못하게 하는 용도로 사용되는 힌트
	- 때로는 옵티마이저가 풀 테이블을 스캔을 유도하기 위해 해당 힌트를 사용할 수도 있다.

→ 위 3개의 힌트들 모두 용도를 명시해줄 수 있으며 선택사항이다. 특별히 인덱스 힌트에 용도가 명시되지 않으면 주어진 인덱스를 3가지 용도로 사용한다.
- USE INDEX FOR JOIN: 테이블 간의 조인 뿐만 아니라, 레코드를 검색하기 위한 용도까지 포함하는 용어
- USE INDEX FOR ORDER: 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한한다.
- USE INDEX FOR GROUP: 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한한다.

### 9.4.1.3 SQL_CALC_FOUND_ROWS
MySQL에서 LIMIT을 사용하는 경우, 조건을 만족하는 레코드가 LIMIT에 명시된 수보다 많다고 하더라도 LIMIT에 명시된 수만큼 만족하는 레코드를 찾으면 즉시 검색 작업을 멈춘다.
하지만 SQL_CALC_FOUND_ROWS 힌트가 포함된 쿼리의 경우에는 LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다.  
→ SQL_CALC_FOUND_ROWS 힌트가 사용된 쿼리가 실행된 경우에는 FOUND_ROWS() 함수를 이용해 LIMIT을 제외한 조건을 만족하는 레코드가 전체 몇 건이었는지를 알아낼 수 있다.

전기적 처리인 CPU의 연산 작업에 비해 기계적 처리인 디스크 작업이 얼마나 느린 작업인지를 고려하면 비교할 수도 없을 만큼 SQL_CALC_FOUND_ROWS를 사용하는 경우가 느리다.
→ SELECT 쿼리 문장이 UNION으로 연결된 경우에는 SQL_CALC_FOUND_ROWS 힌트를 사용해도 FOUND_ROWS() 함수로 정확한 레코드 건수를 가져올 수 없다는 것도 문제이다.
→ 인덱스나 쿼리의 튜닝이 제대로 됐다면, SQL_CALC_FOUND_ROWS를 사용하지 않는 방향으로 추천한다.

## 9.4.2 옵티마이저 힌트
MySQL 8.0 버전에서 사용 가능한 힌트는 종류가 매우 다양하며, 옵티마이저 힌트가 미치는 영향 범위도 매우 다양하낟.

### 9.4.2.1 옵티마이저 힌트 종류
- 인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- 테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- 쿼리 블록: 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트, 특정 쿼리 블록의 이름을 명시하지는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
- 글로벌: 전체 쿼리에 영향을 미치는 힌트

```ad-tip
다양한 옵티마이저 힌트들은 책 p.379 ~ 380 에서 확인 가능
```


> 하나의 SQL 문장에서 SELECT 키워드는 여러 번 사용될 수 있다. 
> 이때 각 SELECT 키워드로 시작하는 서브쿼리 영역을 쿼리 블록이라고 한다.

특정 쿼리 블록에 영향을 미치는 옵티마이저 힌트는 그 쿼리 블록 내에서 사용될 수도 있지만 외부 쿼리 블록에서도 사용할 수도 있다.
→ 이처럼 특정 쿼리 블록을 외부 쿼리 블록에서 사용하려면 `OB_NAME()` 힌트를 이용해 해당 쿼리 블록에 이름을 부여해야 한다.

### 9.4.2.2 MAX_EXECUTION_TIME
옵티마이저 힌트 중에서 유일하게 쿼리의 실행 계획에 영향을 미치지 않는 힌트이며, 단순히 쿼리의 최대 실행 시간을 설정하는 힌트.
→ `MAX_EXECUTION_TIME` 힌트에는 밀리초 단위의 시간을 설정하는데, 쿼리가 지정된 시간을 초과하면 실패하게 된다.

### 9.4.2.3 SET_VAR
MySQL 서버의 옵티아미저는 조인 버퍼의 공간이 충분하면 조인 버퍼를 활용하는 형태의 실행 계획을 선택할 수도 있으며 옵티마이저 힌트로 부족한 경우 optimizer_switch 시스템 변수를 제어해야할 수도 있는데, 이런 경우에는 `SET_VAR` 힌트를 사용할 수 있다.
→ SET_VAR 힌트는 실행 계획을 바꾸는 용도뿐만 아니라, 조인 버퍼나 정렬용 버퍼의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로 사용할 수 있다.
→ 다양한 형태의 시스템 변수 조정을 사용할 수 있으나, 모든 시스템 변수를 조정할 수는 없다는 것을 기억해야 한다.

### 9.4.2.4 SEMIJOIN & NO_SEMIJOIN
SEMIJOIN 힌트는 어떤 세부 전략을 사용하지를 제어하는 데 사용할 수 있다.

| 최적화 전략        | 힌트                      |
| ------------------ | ------------------------- |
| Duplicate Weed-out | SEMIJOIN(SUPSWEEDOUT)     |
| First Match        | SEMIJOIN(FIRSTMATCH)      |
| Loose Scan         | SEMINOIN(LOOSESCAN)       |
| Materialzation     | SEMIJOIN(MATERIALIZATION) |
| Table Pull-out     | 없음                      |

→ Table Pull-out 전략은 그 전략을 사용할 수 있다면 항상 더 나은 성능을 보장한다.
→ 다른 최적화 전략들은 상황에 따라 다른 최적화 전략으로 우회하는 것이 더 나은 성능을 낼 수도 있기 때문에 `NO_SEMIJOIUN` 힌트도 제공된다.

### 9.4.2.5 SUBQUERY
서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법으로, 2가지 형태로 최적화 할 수 있다.

| 최적화 방법     | 힌트                      |
| --------------- | ------------------------- |
| IN-to-EXISTS    | SUBQUERY(INTOEXISTS)      |
| Materialization | SUBQUERY(MATERIALIZATION) |

세미 조인 최적화는 주로 IN (subquery) 형태의 쿼리에 사용될 수 있지만 안티 세미 조인의 최적화에는 사용될 수 없다.
→ 주로 안티 세미 조인 최적화에는 위의 2가지 최적화가 사용된다.

### 9.4.2.6 BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
MySQL 8.0.18 버전부터 도입된 해시 조인 알고리즘이 MySQL 8.0.20 부터는 블록 네스티드 루프 조인까지 대체하도록 개선되었다.
BNL 힌트와 NO_BNL 힌트는 MySQL 8.0.20 버전과 이후에선 해시 조인을 사용하도록 변경됐다.
→ 대신 HASHJOIN과 NO_HASHJOIN 힌트는 MySQL 8.0.18 버전에서만 유효하며, 이후 버전에서는 효력이 없다.

### 9.4.2.7 JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
MySQL 서버는 조인의 순서를 결정하기 위해 `STRAIGHT_JOIN` 힌트를 사용했었지만, 아래와 같은 단점이 있다.
- FROM 절에 사용된 테이블의 조인 순서에 맞게 변경해야 된다
- 일부는 조인 순서를 강제하고 나머지는 옵티마이저에게 순서를 결정하게 맞기는 것이 불가능하다

이런 단점을 보완하기 위해 옵티마이저 힌트는 `STRAIGHT_JOIN`과 동일한 힌트까지 포함해서 4개의 힌트를 제공한다.
- **JOIN_FIXED_ORDER**: STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 실행하게 하는 힌트
- **JOIN_ORDER**: FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
- **JOIN_PREFIX**: 조인에서 드라이빙 테이블만 강제하는 힌트
- **JOIN_SUFFIX**: 조인에서 드리븐 테이블(가장 마지막에 조인돼야 할 테이블)만 강제하는 힌트

### 9.4.2.8 MERGE & NO_MERGE
FROM 절에 사용된 서브쿼리를 항상 내부 임시 테이블로 생성하는데, 이런 내부 임시 테이블을 파생 테이블이라고 한다.
→ 이는 불필요한 자원 소모를 유발한다. 그렇기에 MySQL 5.7과 8.0 버전에서는 가능하면 임시 테이블을 사용하지 않게 FROM 절의 **서브쿼리를 외부 쿼리와 병합하는 최적화**를 도입했다.
→ 만약 MySQL 옵티마이저가 최적의 방법을 선택하지 못한다면 `MERGE` 또는 `NO_MERGE` 옵티마이저 힌트를 사용하면 된다.

### 9.4.2.9 INDEX_MERGE & NO_INDEX_MERGE
MySQL 서버는 하나의 인덱스만으로 검색 대상 범위를 충분히 좁힐 수 없다면 MySQL 옵티마이저가 사용가능한 다른 인덱스를 이용하기도 한다.
→ 여러 인덱스를 통해 검색된 레코드로부터 교집합 또는 합집합만을 구해서 그 결과를 반환한다.
→ 이처럼 하나의 테이블에 대해 여러 개의 인덱스를 동시에 사용하는 것을 **인덱스 머지**라고 한다.
→ 인덱스 머지 실행 계획은 때로는 성능 향상에 도움이 되지만 항상 그렇지는 않다.
→  인덱스 머지 실행 계획의 사용 여부를 제어하고자 할 때 `INDEX_MERGE` 와 `NO_INDEX_MERGE` 옵티마이저 힌트를 사용하면 된다.

### 9.4.2.10 NO_ICP
인덱스 컨디션 푸시다운(Index Condition Pushdown) 최적화는 사용 가능하다면 성능 향상에 도움이 되므로 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행계획을 수립한다.
→ 그래서 옵티마이저에서는 ICP 힌트는 제공되지 않는다.
→ 하지만, 인덱스 컨디션 푸시다운으로 인해 여러 실행 계획의 비용 계산이 잘못된다면 결과적으로 잘못된 실행 계획을 수립하게 될 수도 있다.
→ 그렇기에 적절한 상황에 따라, 인덱스 컨디션 푸시다운 최적화를 제어하여 조금 더 유연하고 정확하게 실행 계획을 선택하는 것이 좋다.

### 9.4.2.11 SKIP_SCAN & NO_SKIP_SCAN
인덱스 스킵 스캔은 인덱스의 선행 컬럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사용할 수 있게하는 기능이다.
→ 하지만 조건이 누락된 선행 컬럼이 가지는 유니크한 값의 개수가 많아지면 성능은 오히려 더 떨어진다.
→ MySQL 옵티마이저가 유니크한 값의 개수를 제대로 분석하지 못하거나 잘못된 경로로 인해 비효율적인 인덱스 스킵 스캔을 선택하면 `NO_SKIP_SCAN` 옵티마이저 힌트를 이용해 인덱스 스킵 스캔을 사용하지 않게 할 수 있다.

### 9.4.2.12 INDEX & NO_INDEX
`INDEX`와 `NO_INDEX` 옵티마이저 힌트는 예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공된다.

| 인덱스 힌트               | 옵티마이저 힌트 |
| ------------------------- | --------------- |
| USE INDEX                 | INDEX           |
| USE INDEX FOR GROUP BY    | GROUP_INDEX     |
| USE INDEX FOR ORDER BY    | ORDER_INDEX     |
| IGNORE INDEX              | NO_INDEX        |
| IGNORE INDEX FOR GROUP BY | NO_GROUP_INDEX  |
| IGNORE INDEX FOR ORDER BY | NO_ORDER_INDEX  |


