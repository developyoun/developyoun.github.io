---
title: 8.2 인덱스란

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

> 많은 사람이 인덱스를 언급할 때 항상 책의 맨 끝에 있는 찾아보기로 설명한다.
> 찾아보기가 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있고, 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.

DBMS에서 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.
그래서, 컬럼(혹은 컬럼들)의 값과 해당 레코드가 저장된 주소를 **키와 값의 쌍(key-value pair)으로 삼아 인덱스**를 만들어두는 것이다.
또한 인덱스에서 중요한 점 한가지는 바로 **정렬**이다. 인덱스는 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

자료 구조 중 `SortedList` 와 `ArrayList` 는 많이 들어봤을 듯 한데, 
- `SortedList`는 DBMS의 **인덱스**와 같은 자료 구조이다. 
	- "SortedList"는 저장되는 값을 항상 정렬된 상태로 유지하는 자료 구조이다.
	- 인덱스도 저장되는 컬럼의 값을 이용해 항상 정렬된 상태를 유지한다.
- `ArrayList`는 **데이터 파일**과 같은 자료 구조를 사용한다.
	- "ArrayList"는 저장되는 순서 그대로 유지하는 자료 구조이다.
	- 데이터 파일은 저장된 순서대로 별도의 정렬 없이 그대로 저장 해둔다.

SortedList 의 장단점은 아래와 같다.
- 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다.
- 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.
DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 `INSERT`, `UPDATE`, `DELETE` 문장의 처리가 느려진다. 하지만 이미 정렬된 인덱스를 가지고 있기 때문에 `SELECT` 문장은 빠르게 처리할 수 있다.
> 결론적으로 DBMS에서 인덱스는  데이터의 저장 성능을 희생하고 대신, 데이터의 읽기 속도를 높이는 기능이다.
> 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는디, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.

인덱스는 데이터를 **관리하는 방식(알고리즘)** 과 **중복 값**의 허용 여부 등에 따라 여러 가지로 나눠볼 수 있다.
> 인덱스를 역할 별로 구분해 본다면 프라이머리 키와 보조 키로 구분할 수 있다.
> - 프라이머리 키는 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미한다.
> 	- 이 컬럼은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 *식별자*라고도 부른다.
> 	- 프라이머리 키는 `NULL` 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.
> - 프라이커리 키를 제외한 모든 인덱스는 세컨더리 인덱스(보조 키)로 분류한다.
> 	- 유니크 인덱스는 프라이머리 키와 성격이 비슷하고, 프라이머리 키를 대체해서 사용할 수 있다고 해서 대체 키라고도 한다.
> 	- 혹은 별로도 분류하기도 하고 그냥 세컨더리 인덱스로 분류하기도 한다.

데이터 저장 방식(알고리즘)별로 구분할 경우, 대표적으로 *B-Tree* 인덱스와 *Hash* 인덱스로 분류할 수 있다.
> 최근에는 *Fractal-Tree* 인덱스나 로그 기반의 *Merge-Tree* 인덱스 같은 알고리즘을 사용하는 DBMS도 개발되고 있다.
- B-Tree
	- B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘으로서, 상당히 오래전에 도입된 알고리즘이며 그만큼 성숙해진 상태이다.
	- B-Tree 인덱스는 컬럼의 값을 변경하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.
	- MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 B-Tree의 응용 알고리즘으로 볼 수 있다.
- Hash
	- Hash 인덱스 알고리즘은 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
	- 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.
	- Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

데이터 중복 허용 여부로 분류할 경우, *유니크 인덱스* 와 *유니크하지 인덱스* 로 구분할 수 있다.
→ 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에서는 상당히 중요한 문제가 된다.
→ 유니크 인덱스에 대해 동등 조건(Equal, =)으로 검색한다는 것은 항상 1건의 코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
→ 그뿐만 아니라 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점이 상당히 많다.
