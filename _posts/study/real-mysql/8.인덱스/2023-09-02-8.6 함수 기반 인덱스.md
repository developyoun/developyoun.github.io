---
title: 8.7 멀티 밸류 인덱스

categories:
- study

tags:
- database

toc: true
toc_sticky: true
toc_label: Contents
---

때로는 컬럼의 값을 변경해서 만들어진 값에 대해 인덱스를 구축해야 할 때도 있는데, 이러한 경우 **함수 기반의 인덱스**를 활용하면 된다.
> MySQL 8.0 버전부터 함수 기반 인덱스를 지원하기 시작함

함수 기반 인덱스를 구현하는 방법은 두 가지로 나뉜다.
- 가상 컬럼을 이용한 인덱스
- 함수를 이용한 인덱스
→ MySQL 서버의 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정에서만 차이가 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일하다.

## 8.6.1 가상 컬럼을 이용한 인덱스

```sql
CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY KEY (user_id)
);
```
이 테이블에서 가상 컬럼을 추가하고 그 가상 컬럼에 인덱스를 생성할 수 있다.
> 이전 버전에서는 full_name 컬럼을 추가하고 모든 레코드에 대해 full_name을 업데이트하는 작업을 거쳐야 했다.

```sql
ALTER TABLE user
ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
ADD INDEX ix_fullname (full_name)
```
- 가상 컬럼을 `VIRTUAL` 이나 `STORED` 옵션 중 어떤 옵션으로 생성되었든 관계없이 해당 가상 컬럼에 인덱스를 생성할 수 있다.
	- 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.

## 8.6.2 함수를 이용한 인덱스
```sql
CREATE TABLE user (
	user_id BIGINT,
	first_name VARCHAR(10),
	last_name VARCHAR(10),
	PRIMARY KEY (user_id),
	INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))
);
```
- 테이블의 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있게 됐다

함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어준다.
→ 함수 기반 인덱스를 제대로 활용하려면 반드시 **조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.**
```sql
EXPLAIN SELECT * FROM user WHERE CONCAT(first_name, ' ',last_name)='Matt Lee';
```

> 만약 옵티마이저가 표시하는 실행 계획이 예상하는 값으로 나오지 않는다면, CONCAT 함수에 사용된 공백 문자 리터럴 때문일 가능성이 높다.
> `collation_connection, collation_database, collation_server` 3개의 시스템 변수의 값을 동일 콜레이션으로 일치시킨 후, 테스트를 진행하자. 