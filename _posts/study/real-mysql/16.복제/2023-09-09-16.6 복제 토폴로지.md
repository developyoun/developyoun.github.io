---
title: 16.6 복제 토폴로지

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

MySQL의 복제는 사용자가 큰 어려움 없이 쉽고 간단하게 설정가능하다.  
구성 형태 또한 사용자의 필요에 맞게 원하는 형태로 자유롭게 구성할 수 있다.  
MySQL 5.7 버전부터 멀티 소스 복제 기능이 도입되면서 사용자가 구성할 수 있는 복제 형태는 더욱 다양해졌다.

## 16.6.1 싱글 레플리카 복제 구성
싱글 레플리카 복제는 하나의 소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태를 말한다.

싱글 레플리카 복제 형태는 가장 기본적인 형태로, 제일 많이 사용된다.
- 보통 어플리케이션 서버는 소스 서버에만 직접적으로 접근 (레플리카 서버는 접근x)
- 레플리카 서버는 소스 서버에서서 장애가 발생했을 때 사용될 수 있는 예비 서버 및 데이터 백업 수행의 용도

## 16.6.2 멀티 레플리카 복제 구성
멀티 레플리카 복제는 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태를 말한다.  
보통 싱글 레플리카 복제 구성에서 추가적인 용도의 레플리카 서버가 필요해졌을 때 자주 사용하는 형태이다.

새로 오픈될 서비스에서는 보통 싱글 레플리카 복제 구성으로 구축하고, 이후 트래픽이 증가하면 쓰기 보다 읽기 요청을 더 많이 처리하기 위해 멀티 레플리카 형태로 복제 구성을 가져가면서 요청 처리를 분산한다.  
배치, 통계, 분석 등의 여러 작업이 하나의 MySQL 서버 내에 있는 데이터의 경우에도 멀티 레플리카 형태로 복제를 구축해 레플리카 서버를 나눠 전용으로 사용할 수도 있다.

> 하지만 이러한 레플리카 서버들은 장애가 발생했을 떄 최대한 빠르게 복구돼야 하기 때문에 이와 같은 상황을 대비해 대체 서버 및 백업 수행 용도 외에는 최소한의 용도로만 사용되는 예비용 서버 한 대를 남겨놓는 것이 좋다.

## 16.6.3 체인 복제 구성
멀티 레플리카 복제 구성에서 레플리카 서버가 너무 많아 소스 서버의 성능이 악영향이 예상된다면 1:M:M 구조의 체인 복제 구성을 고려해볼 수 있다.

> 체인 복제 활용안은 책 p.497 ~ 501 에서 확인해볼 수 있음

## 16.6.4 듀얼 소스 복제 구성
듀얼 소스 복제 구성은 두 개의 MySQL 서버가 서로 소스 서버이자 레플리카 서버로 구성돼 있는 형태이다.

듀얼 소스 구성은 두 MySQL 서버 모두 쓰기가 가능하다는 것이 큰 특징이며, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 동일한 데이터를 갖게 된다.

듀얼 소스 구성에서는 목적에 따라 두 MySQL 서버를 `ACTIVE-PASSIVE` 또는 `ACTIVE-ACTIVE` 형태로 사용할 수 있다.
- `ACTIVE-PASSIVE`
    - 하나의 MySQL 서버에서만 쓰기 작업이 수행된다.
    - 예비 서버인 다른 MySQL 서버가 바로 쓰기 작업이 가능한 상태이므로, 기존 쓰기 작업이 수행되는 서버가 문제가 발생해도, 별도의 설정 변경없이 예비용 서버로 쓰기 작업을 전환할 수 있다. (싱글 레플리카 복제 구성과의 차이점)
    - 한 서버에서 다른 서버로 바로 쓰기가 전환될 수 있는 환경이 필요한 경우에 주로 사용된다.
- `ACTIVE-ACTIVE`
    - 두 서버 모두 쓰기 작업을 수행하는 형태
    - 지리적으로 매우 떨어진 위치에서 유입되는 쓰기 요청도 원활하게 처리하기 위해 주로 사용
    - 두 MySQL 서버 모두 동일한 데이터를 갖게 되지만 거리상으로 떨어져 있기 때문에, 복제를 통해 다른 지역의 MySQL 서버로 부터 넘어온 트랜잭션이 적용되기까지는 다소 시간이 걸릴 수 있다.
    - 서로의 트랜잭션이 전달 완료되어 적용되기 전까지 두 MySQL 서버는 서로 일관되지 않은 데이터를 가질 수 있음을 유의해야 한다.

듀얼 소스 복제 구성을 사용할 때는 아래와 같은 부분에서 문제가 발생할 수 있다.
- 동일한 데이터를 각 서버에서 변경
    - `ACTIVE-ACTIVE` 형태에서 동일한 데이터에 대한 트랜잭션이 동시에 유입되는 경우 나중에 처리된 트랜잭션이 최종적으로 반영되면서 사용자가 예상치 못한 방향으로 데이터가 처리될 수 있다.
- 테이블에서 Auto-Increment 키 사용
    - 거의 동일한 시점에 새로운 데이터가 서버로 유입될 경우, 같은 Auto-Increment 키 값을 갖게 될 수 있으므로 중복키 에러가 발생할 수 있다.
    - `ACTIVE-ACTIVE` 형태에서는 동시점에 동일한 데이터를 변경하는 트랜잭션이 있어서는 안되며, Auto-Increment 키 사용을 지양해야 한다. (글로벌 키를 사용하는 것을 권장)
    - 만약 Auto-Increment를 반드시 사용하고자 한다면 해당 키 값이 충돌하지 않도록 `auto_increment_offset` 시스템 변수와 `auto_increment_increment` 시스템 변수를 적절하게 변경하는 것이 좋다.

> ACTIVE-PASSIVE 형태를 사용할 때 양쪽 서버 모두에 쓰기 요청이 유입되는 상황이 절대 발생하지 않는다는 조건에서는 위 두가지 문제는 해당하지 않는다.

## 16.6.5 멀티 소스 복제 구성
멀티 소스 복제 구성은 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태를 말한다.  
멀티 소스 복제 구성은 다음과 같은 목적으로 사용된다.
- 여러 MySQL 서버에 존재하는 각기 다른 데이터를 하나의 MySQL 서버로 통합
- 여러 MySQL 서버의 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합
- 여러 MySQL 서버의 데이터들을 모아 하나의 MySQL 서버에서 백업을 수행

분석에 필요한 데이터들이 여러 곳에 나눠져 있어 이를 한곳으로 모아 좀 더 빠르고 편리하게 분석을 수행하고자 할 때 멀티 소스 복제 형태를 사용하면 매우 효율적이다.  
늘어날 서비스 트래픽에 대비해 사전에 동일한 스키마 구조를 가지는 샤드 형태로 구성해뒀으나 예상했던 것만큼 트래픽이 유입되지 않은 경우 멀티 소스 복제를 구성해서 샤딩된 테이블들을 데이터를 통합해 MySQL 서버 수를 줄일 수도 있다.  
다수의 MySQL 서버의 데이터를 하나의 MySQL 서버에서 백업하고자 할 때도 멀티 소스 복제 구성을 통해 손쉽게 할 수 있다.

> 멀티 소스 복제 형태를 사용할 때는 각 소스 서버로부터 유입되는 변경 이벤트들이 레플리카 서버로 복제됐을 때 서로 충돌을 일으킬 만한 부분이 없는지 사전에 충분한 검토가 필요하다  
> 또한, 멀티 소스 복제의 레플리카 서버는 각 소스 서버들의 대체 서버로 사용하기에는 여러움이 있으므로 장애 대비용 레플리카 서버는 멀티 소스가 아닌 각 소스 서버와 일대일 복제로 연결된 별도의 서버로 구축하는 것이 좋다.

### 16.6.5.1 멀티 소스 복제 동작
멀티 소스 복제에서 레플리카 서버는 자신과 연결된 소스 서버들의 변경 이벤트들을 동시점에 병렬로 동기화한다.  
→ 이는 각 소스 서버들에 대한 복제가 독립적으로 처리된다는 것이며, 각각 독립된 복제 처리를 **채널(Channel)** 이라고 한다.  
→ 각 복제 채널은 개별적인 레플리케이션 I/O 스레드, 릴레이 로그, 레플리케이션 SQL 스레드를 가지며 채널의 이름은 어느 소스 서버와의 복제 연결인지를 구별할 수 있는 식별자 역할을 한다.  
→ 멀티 소스 복제의 레플리카 서버는 최대 256개의 복제 채널을 생성할 수 있다.

사용자는 복제를 설정하는 `CHANGE REPLICATION SOURCE TO (또는 CHANGE MASTER TO)` 명령에서  "FOR CHANNEL" 구문을 사용해 복제 채널명을 지정할 수 있다.  
→ 사용자가 지정한 채널명은 복제 시작과 중지, 초기화 같은 복제 관련 명령에서도 사용될 수 있다.

> 관련 명령어는 책 p.505 참고

멀티 소스 복제에서도 단일 소스 복제와 동일하게 GTID 설정이나 반동기 복제 방식 설정 등이 모두 가능하다.  
또한, 각 복제 채널별로 멀티 스레드로 복제를 처리하거나 소스 서버의 변경 이벤를 필터링하도록 설정하는 것도 가능하다.

### 16.6.5.2 멀티 소스 복제 구축
멀티 소스 복제는 단일 소스 복제와 달리 여러 대의 소스 서버의 백업 데이터를 가져와야 한다.  
→ 만약 멀티 소스 복제를 소스 서버와 레플리카 서버 모두 아무런 데이터를 가지지 않은 상태라면 초기 데이터가 없으므로 그냥 멀티 소스 복제 연결만 하면 된다.  
→ 만약 한 서버만 데이터를 가지고 있는 상태라면 데이터를 가진 서버의 백업 데이터를 레플리카 서버에 복구하면 된다.  
→ 두 개 이상의 소스 서버에서 데이터를 가져와야 한다면 mysql 데이터베이스와 같이 공통으로 가지고 있는 데이터베이스와 InnoDB의 시스템 테이블 스페이스의 충돌과 병합을 고려해야 한다.

- **mysqldum와 같은 논리 수준의 백업 도구 이용**
    - InnoDB 시스템 테이블 스페이스를 물리적으로 백업하는 것이 아니므로 데이터를 적재할 떄 병합과 관련한 문제는 발생하지 않는다.
    - mysql 데이터베이스에 저장되는 스토어드 프로시저나 함수, 유저 정보나 권한과 관련된 테이블은 중복될 가능성이 있지만 그다지 레코드가 많지 않기 때문에 수작업으로도 조정이 가능하다.
    - 백업된 데이터가 매우 크다면 mysqldump로는 데이터 백업과 적재에 상당히 오랜 시간이 소요될 수 있다.
- **XtraBackup과 같은 물리 수준의 백업 도구 이용**
    - 해당 백업 도구를 사용하면 대용량의 데이터베이스를 빠르게 레플리카 서버로 가져올 수 있다.
    - XtraBackup과 같은 물리 수준의 백업은 시스템 테이블 스페이스를 포함해서 MySQL 서버의 모든 데이터 파일들을 그대로 복사해서 복구하게 된다.
    - 만약 두 소스 서버에서 데이터를 가져와야 한다면 시스템 테이블 스페이스를 문제없이 하나로 병합할 수 있는 방법은 없다.

여러 소스 서버의 데이터를 가져와 레플리카 서버의 초기 데이터로 적재할 때는 mysqldump와 XtraBackup을 적절히 혼합해서 사용하는 것이 제일 손쉬운 방법이다.

소스 서버 A와 소스 서버 B의 데이터를 가져와 레플리카 서버인 C에 멀티 소스 복제를 연결한다고 가정한다.
- **A서버와 B서버 모두 데이터가 크지 않은 경우**
    - mysqldump로도 충분히 백업할 수 있으며, 레플리카 서버에서도 할당한 시간 내에 복구할 수 있을 것으로 예상되면 mysqldump 결과를 차례대로 레플리카 서버로 적재하고 스토어드 프로시저나 함수, 유저 정보와 권한만 따로 확인해서 조정하면 된다.
- **A서버의 데이터는 크고 B서버의 데이터가 상대적으로 훨씬 작은 경우**
    - 데이터가 작은 쪽은 mysqldump를, 데이터가 큰 쪽은 XtraBackup을 이용하면 된다.
    - 데이터가 큰 서버를 먼저 XtraBackup으로 백업해서 레플리카 서버로 복구한다.
    - 이후 데이터가 적은 서버를 mysqldump로 백업해서 레플리카 서버로 적재한다.
    - 스토어드 프로시저나 함수, 유저 정보와 권한 정보는 별도로 한번 더 확인하는 것이 좋다.
- **A서버와 B서버 모두 데이터가 큰 경우**
    - 두 서버 모두 큰 데이터를 가지고 있다면 XtraBackup을 이용해 물리 수준의 백업을 수행한다.
    - 그리고 데이터 개수가 많은 쪽은 레플리카 서버로 복구한다.
    - 남은 백업은 InnoDB 시스템 테이블 스페이스 충돌로 인해 copy-back 명령으로는 복구할 수 없으므로, InnoDB 테이블들의 ibd 파일을 export 명령을 사용해 내보내고 레플리카 서버에서 import하는 헝태로 진행한다.
    - export하고 import하는 작업은 모두 수동으로 하나씩 진행해야 하므로, 가능하면 테이블 개수가 적은 쪽의 백업에 대해 이 방법을 수행하는 것이 좋다.

> 복제 연결 전 레플리카 서버에서 복제 동작과 관련된`master_info_repository`, `relay_log_info_repository` 시스템 변수들의 값이 반드시 TABLE로 설정되어 있어야 한다.

```ad-note
복제 소스 연결을 직접 진행해보는 과정은 책 p.507~514 참고해보면 된다.
```
