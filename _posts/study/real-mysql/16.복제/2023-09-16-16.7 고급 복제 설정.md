---
title: 16.7 고급 복제 설정

categories:
- real-mysql

tags:
- study
- database

toc: true
toc_sticky: true
toc_label: Contents
---

## 16.7.1 지연된 복제 (Delayed Replication)
복제는 최대한 빠르게 동기화해서 소스 서버와 레플리카 서버 간의 데이터를 동일한 상태로 만드는 것이 목적
- 소스 서버와 레플리카 서버 간의 데이터 동기화 지연이 없으면 없을수록 레플리카 서버를 이용한 장애 복구 용이
- 레플리카 서버를 서비스의 읽기 요청 처리 용도로 사용할 때도 유용

때로는 의도적으로 소스 서버와 레플리카 서버 간의 복제를 지연해야 할 때도 있다.  
→ MySQL에서는 문제 상황에 조금 더 유연하게 대처할 수 있도록 지연된 복제 기능을 제공
- 사용자는 지원된 복제를 사용하여 지연된 복제본을 통한 데이터 복구를 가능하게 함
- 이전 시점의 데이터 값에 대해 확인이 필요한 경우, 백업 데이터를 사용하는 대신 지연된 복제본을 활용할 수 있음
- MySQL 서버의 부하가 심할 때 쿼리 처리 지연 상황 중, 지연된 복제본을 사용하면 부하를 생성할 필요없이 이런 상황을 시뮬레이션 할 수 있음

MySQL의 지연된 복제 기능은 5.6 버전에서 처음 도입됐으며, 8.0 버전까지 몇가지 부분들이 개선되었음
```sql
-- 8.0.23 미만 버전
CHNAGE MASTER TO MASTER_DELAY=86400;

-- 8.0.23 이상 버전
CHANGE REPLICATION SOURCE TO SOURCE_DELAY=86400;
```
- 해당 명령을 통해 레플리카 서버를 소스 서버로부터 얼마나 지연시킬 것인지 설정 가능

MySQL 8.0 버전부터는 바이너리 로그에 `origin_commit_timestamp(OCT)` 와 `immediate_commit_timestamp(ICT)` 라는 타임스탬프가 추가되었다.
- `origin_commit_timestamp`
    - 트랜잭션이 원본 소스 서버에서 커밋된 시각
    - 밀리초 단위의 유닉스 타임스탬프 값으로 저장
- `immediate_commit_timestamp`
    - 트랜잭션이 직계 소스 서버에서 커밋된 시각
    - 밀리초 단위의 유닉스 타임스탬프 값으로 저장

> 직계 소스 서버: MySQL 서버 세 대가 체인 형태로 구성된 복제에서 가장 하위에 있는 레플리카 서버를 기준으로 바로 위의 소스 서버
> 원본 소스 서버: 가장 위에 있는 소스 서버, 즉 트랜잭션이 제일 처음 실행되는 소스 서버가 원본 소스

MySQL 8.0 미만 버전의 지연된 복제에서는 이벤트 그룹(트랜잭션) 단위가 아닌 개별 이벤트 단위로 지연 실행 여부를 확인했다
- 이로 인해 동일한 트랜잭션 내의 이벤트들이라 하더라도 각 이벤트 사이에 지연 대기가 발생
- 또한 지연 측정을 위한 기준 시각도 각 이벤트가 종료된 시각이 아닌 시작된 시각이 기준
    - 이 부분은 특히 체인 복제 구성에서 문제가 되었는데, 최하위 계층의 레플리카 서버에서는 자신의 직계 소스 서버가 아닌 원본 소스 서버의 시각을 기준으로 지연이 계산
- 하지만 MySQL 8.0 버전부터는 ICT 타임스탬프 값을 사용함에 따라 이러한 문제점이 모두 사라졌다.

지연된 복제가 활성화되면 `SHOW REPLICA STATUS` (또는 `SHOW SLAVE STATUS`) 명령의 결과에서 레플리카 서버가 얼마나 지연되고 있는지, 다음 트랜잭션을 실행할 때까지 얼마나 시간이 남았는지 확인할 수 있다.

만약 복제를 지연되지 않도록 다시 설정하고 싶은 경우에는 명령어를 실행해 지연 설정을 제거할 수 있다.
```sql
-- 8.0.23 미만 버전
STOP SLAVE SQL_THREAD;
CHANGE MASTER TO MASTER_DELAY=0;
START SLAVE SQL_THREAD;

-- 8.0.23 이상 버전
STOP REPLICA SQL_THREAD;
CHANGE REPLICATION SOURCE TO SOURCE_DELAY=0;
START REPLICA SQL_THREAD;
```

## 16.7.2 멀티 스레드 복제 (Multi-threaded Replication)
MySQL 복제에서는 레플리카 서버에서 소스 서버로부터 복제된 트랜잭션들을 하나의 스레드가 아닌 여러 스레드로 처리할 수 있게 하는 멀티 스레드 복제 기능을 제공

> 멀티 스레드 복제 기능은 MySQL 5.6 버전에서 처음 도입되었다.

기존의 단일 스레드 복제에서는 레플리케이션 SQL 스레드가 릴레이 로그 파일을 읽어서 바로 트랜잭션을 적용하는 형태  
멀티 스레드 복제에서는 SQL 스레드는 코디네이터 스레드로 불리며, 실제로 이벤트를 실행하는 스레드인 워커 스레드와 협업해서 동기화를 진행
1. 코디네이터 스레드는 릴레이 로그 파일에서 이벤트들을 읽은 뒤 설정된 방식에 따라 스케줄링해서 워커 스레드에 각 이벤트를 할당
2. 각 이벤트는 워커 스레드들의 큐에 적재
3. 워커 스레드는 큐에서 이벤트들을 꺼내 순차적으로 레플리카 서버에 적용

멀티 스레드 복제는 소스 서버로부터 복제된 트랜잭션들을 어떻게 병렬로 처리할 것인가에 따라 **데이터베이스 기반** 과 **LOGICAL CLOCK 기반** 방식으로 나뉜다.
- `slave_parallel_type` 시스템 변수를 통해 어떤 처리 방식으로 멀티 스레드 동기화를 진행할 것인지 설정할 수 있다.
    - 기본적으로 데이터베이스 기반 방식으로 설정
- `slave_parallel_workers` 시스템 변수를 통해 워커 스레드의 개수를 지정할 수 있다.
    - 0부터 최대 1024까지 설정할 수 있다.
    - 0으로 설정하면 멀티 스레드 복제 동기화를 사용하지 않고 단일 스레드 모드로 복제를 수행하게 된다.
- `slave_pending_jobs_size_max` 시스템 변수를 통해 워커 스레드의 큐에 할당할 수 있는 최대 메모리 크기를 설정할 수 있다.
    - 기본값은 128MB로, 작은 이벤트들이 빈번하게 실행되는 OLTP 환경에서는 기본값 그대로 사용해도 무방
    - 만약 소스 서버로부터 전달받은 이벤트 하나의 크기가 해당 설정 값을 초과하는 경우에는 워커 스레드들의 큐가 비워질 때까지 대기 후 해당 이벤트가 처리된다.
        - 이런 경우에는 해당 변수를 적절히 큰 값으로 변경하는 것이 좋다.
- 세 변수 모두 동적으로 변경 가능하다.

> `slave_parallel_workers` 변수를 1로 설정하는 것과 0으로 설정하는 것은 차이가 있다.
> 1인 경우에는 얼티 스레드 복제를 위한 코드 블록(코디네이션 작업이나 워커 스레드간의 동기화 등)이 모두 실행면서 실제 복제는 단일 스레드와 같은 형태로 수행
> 0인 경우에는 부가적인 작업을 거치지 않으며 기존 단일 스레드 복제 동기화와 동일한 로직으로 수행한다.


### 16.7.2.1 데이터베이스 기반 멀티 스레드 복제
데이터베이스 기반 멀티 스레드 복제 방식은 스키마 기반(Schema-based) 처리 방식이라고도 하며, MySQL에서 멀티 스레드 복제가 처음 도입됐을 때 유일하게 사용할 수 있던 방식이다.  
→ 데이터베이스 기반 멀티 스레드 복제는 MySQL 내의 데이터베이스 단위로 병렬 처리를 수행하는 형태
> 만약 MySQL 서버에 데이터베이스가 하나밖에 존재하지 않는다면 멀티 스레드 방식은 아무런 장점을 가지지 못한다.

> 여러 개의 데이터베이스가 있다면 레플리카 서버에서는 웬만하면 그 개수만큼 워커 스레드 수를 설정하는 것이 좋다.

서로 다른 데이터베이스를 참조하는 쿼리나 트랜잭션이 빈번하게 실행되는 경우, 예상했던 것보다 멀티 스레드 처리 효율이 낮아질 수 있다.  
하지만 MySQL 서버에 여러 개의 데이터베이스가 존재하고 각 데이터 베이스에 유입되는 DML이 서로 독립적이면서 양적으로 균등하게 실행되는 환경이라면 데이터베이스 기반 멀티 스레드 복제는 단일 스레드 복제보다 월등한 처리량을 보이므로 충분히 사용가치가 있는 방식이다.

데이터 베이스 기반 멀티 스레드 복제를 사용하려면 레플리카 서버를 설정한 후 복제를 연결하면 된다.
```mysqld
slave_parallel_type='DATABASE'
slave_parallel_workers=N (N>0)
```

만약 기존에 이미 단일 스레드 복제가 진행되고는 상황에서 데이터베이스 기반 멀티 스레드 복제로 전환하고 싶다면 SQL 스레드만 멈춘 후 멀티 스레드 복제를 설정하고 다시 시작하면 된다.
```sql
-- 8.0.22 미만 버전
STOP SLAVE SQL_THREAD;
SET GLOBAL slave_parallel_type='DATABASE';
SET GLOBAL slave_parallel_workers=4;
SET SLAVE SQL_THREAD;

-- 8.0.22 이상 버전
STOP REPLICA SQL_THREAD;
SET GLOBAL slave_parallel_type='DATABASE';
SET GLOBAL slave_parallel_workers=4;
SET REPLICA SQL_THREAD;
```

### 16.7.2.2 LOGICAL CLOCK 기반 멀티 스레드 복제
MySQL 5.7 버전부터 소스 서버로부터 넘어온 전체 트랜잭션들을 데이터베이스에 종속되지 않고 멀티 스레드로 처리하는 LOGICAL CLOCK 방식이 도입됐다.  
즉, 같은 데이터베이스 내에서도 멀티 스레드 동기화처리가 가능하다.

LOGICAL CLOCK 방식은 소스 서버에서 트랜잭션들이 바이너리 로그로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해 레플리카 서버에서 트랜잭션의 순번 값을 바탕으로 정해진 기준에 따라 병렬로 실행할 수 있게 한다.

LOGICAL CLOCK 방식이 도입되고 개선도 되면서 MySQL8.0 버전까지 크게 세 가지로 나뉜다.
- Commit-parent 기반 방식
- 잠금 (Lock) 기반 방식
- WriteSet 기반 방식

#### 16.7.2.2.1 바이너리 로그 그룹 커밋
MySQL 5.6 버전에서는 처리 성능 저하 문제를 개선하기 위해 여러 트랜잭션에 대한 커밋을 동시에 진행할 수 있게 코드가 바뀌었다.  
→ 또한 여러 트랜잭션을 함께 처리할 수 있도록 **바이너리 로그 그룹 커밋** 기능이 도입됐다.

바이너리 로그 그룹 커밋에서 트랜잭션들은 커밋 처리 과정 중 *Prepare* 이후 바이너리 로그 관련 처리를 진행할 때  
Flush Stage → Sync Stage → Commit Stage 세 단계를 거치면서 최종적으로 그룹 커밋 된다.
- 각 단계에서는 대기 큐가 존재하는데, 트랜잭션들은 순서대로 대기 큐에 등록된다.
- 비어있는 대기 큐에 첫 번째로 등록된 트랜잭션을 리더(Leader)라고 하며 다른 트랜잭션들은 팔로워(Follower)라고 한다.
- 팔로워는 리더에게 자신의 트랜잭션 처리에 대한 모든 것을 일임하며 리더는 큐에 등록된 팔로워들을 가져와 처리하고 다음 단계의 대기 큐에 등록한다.
- 다음 단계의 큐에 등록될 때는 큐가 비어있지 않은 경우 리더는 팔로워가 되고 해당 큐의 리더가 그 단계에서의 처리를 주도한다.
    - 리더는 팔로워가 될 수 있으나 팔로워는 절대 리더가 될 수 없다.
1. Flush 단계
    - 대기 큐에 등록된 각 트랜잭션들을 순서대로 바이너리 로그에 기록한다.
2. Sync 단계
    - 앞서 기록된 바이너리 로그 내용들을 디스크와 동기화하는 fsync() 시스템 콜이 수행된다.
3. Commit 단계
    - 대기 큐에 등록된 트랜잭션들에 대해 스토리지 엔진 커밋을 진행한다.

Sync 단계에서는 `sync_binlog` 옵션에 설정된 값에 따라 디스크 동기화를 진행하는데, `sync_binlog` 옵션이 1이면 Flush 단계에서 넘어온 전체 트랜잭션들에 대해 매번 디스크 동기화 작업을 수행하게 된다.  
트랜잭션별로 매번 동기화가 수행되는 것이 아니라 트랜잭션 그룹에 대해 동기화가 수행되는 것이라 Sync 단계에의 대기 큐에 트랜잭션이 많이 쌓이면 더 효율적이다.

사용자는 Sync 단계에서 더 많은 트랜잭션이 쌓여 한 번에 처리될 수 있도록 다음 두 시스템 변수들을 통해 Sync 단계의 실행을 지연시킬 수 있다.
- `binlog_group_commit_sync_delay`
    - 바이너리 로그를 디스크에 동기화하는 작업을 얼마 정도 지연시킬지 제어하는 변수 (마이크로초 단위)
    - 기본값은 0이며, 0이면 그룹 커밋에서 바이너리 로그 디스크 동기화가 지연없이 처리된다.
    - 0보다 큰 값으로 설정하는 경우, `sync_binlog` 시스템 변수의 값이 0 또는 1이면 `binlog_group_commit_sync_delay`에 설정된 시연이 매 그룹 커밋시 적용된다.
    - 0보다 큰 값으로 설정하는 경우, `sync_binlog` 시스템 변수의 값이 1보다 큰 N값으로 설정돼 있으면 N개의 바이너리 로그 그룹 커밋이 실행될 때마다 지연이 적용된다.
    - 0보다 큰 값으로 설정하면 지연으로 인해 한 번에 처리하게 되는 트랜잭션 수가 늘어나므로 바이너리 로그에 대한 fsync() 시스템 호출 수를 줄일 수 있다.
    - 값이 크게 설정될수록 MySQL 서버에서 트랜잭션들의 커밋이 완료되기까지의 시간이 오래 걸리게 된다.
- `binlog_group_commit_sync_no_delay_count`
    - 바이너리 로그의 동기화 작업이 진행되기 전에 지연되어 대기할 수 있는 최대 트랜잭션 수를 설정하는 변수
    - `binlog_group_commit_sync_delay` 변수에 설정된 지연 시간이 아직 남아있더라도 `binlog_group_commit_sync_no_delay_count` 변수에 지정된 수만큼 트랜잭션이 대기하게 되면 바이너리 로그를 디스크에 동기화한다.
    - `binlog_group_commit_sync_delay` 값이 0인 경우에는 이 변수에 설정된 값은 무시된다.

Commit 단계에서는 대기 큐에 등록된 트랜잭션들에 대해 스토리지 엔진 커밋을 진행하며, 스토리지 엔진 커밋은 대기 큐에 등록된 순서대로 혹은 병렬로도 처리될 수 있다.
- 대기 큐에 등록된 순서대로 커밋되는 경우
    - 대기 큐의 리더에 의해 처리가 진행
    - 트랜잭션들은 바이너리 로그에 기록된 순서와 스토리지 엔진에 커밋된 순서가 일치하게 된다.
- 스토리지 엔진 커밋이 병렬로 처리되는 경우
    - 리더가 아닌 각 트랜잭션들이 커밋을 수행
    - 사용자는 `binlog_order_commits` 변수를 통해 트랜잭션들이 커밋되는 순서를 제어할 수 있다.
    - `binlog_order_commits`
        - 불리언 변수로 0 이나 1 또는 ON이나 OFF로 설정할 수 있다.
        - 기본값은 1(ON)이며, 1로 설정된 경우 트랜잭션들이 바이너리 로그 파일에 기록된 순서대로 스토리지 엔진에 커밋된다.
        - 0으로 설정되면 트랜잭션들의 스토리지 엔진 커밋이 바이너리 로그에 기록된 순서와 상관없이 병렬로 처리된다.

#### 16.7.2.2.2 Commit-parent 기반 LOGICAL CLOCK 방식
동일 시점에 커밋된 트랜잭션들을 레플리카 서버에서 병렬로 실행할 수 있게 한다.  
커밋 시점이 같은 트랜잭션들은 잠금 경합 등과 같이 서로 충돌하는 부분이 없는 트랜잭션들이므로 병렬로 실행될 수 있다.

Commit-parent 기반 LOGICAL CLOCK 방식이 적용된 MySQL 버전을 사용하는 레플리카 서버에서는 LOGICAL CLOCK 멀티 스레드 동기화가 활성화돼 있는 경우, 소스 서버에서 같은 시점에 커밋된 트랜잭션들을 복제 동기화할 때 병렬로 처리한다.  
같은 시점에 커밋 처리된 트랜잭션들을 식별할 수 있도록 바이너리 로그에 트랜잭션을 기록할 때 `commit_seq_no` 이라는 값을 함께 기록한다.
- **commit_seq_no**
    - 해당 트랜잭션이 커밋될 당시, 가장 최근에 커밋된 트랜잭션의 순번값을 저장
    - 해당 값은 글로벌하게 관리되는 commit clock 이라는 64비트 정숫값을 기반으로 한다.
    - 각 트랜잭션이 커밋을 위해 Prepare 단계에 진입했을 때 설정되며 당시 commit clock 값이 저장된다.
    - 따라서 같은 시점에 커밋 처리가 시작된 트랜잭션들은 동일한 `commit_seq_no` 값을 갖게 된다.
    - 레플리카 서버에서는 복제된 트랜잭션들의 `commit_seq_no` 값을 바탕으로 같은 값을 가진 트랜잭션들을 병렬로 처리하게 된다.

Commit-parent 기반에서는 소스 서버에서 같은 그룹으로 커밋된 트랜잭션 수가 많으면 많을수록 레플리카 서버에서의 트랜잭션 병렬 처리율이 향상된다.
- 사용자는 소스서버에서 `binlog_group_commit_sync_delay` 시스템 변수와 `binlog_group_commit_sync_no_delay_count` 시스템 변수에 적절한 값을 설정해 그룹 커밋되는 트랜잭션 수를 늘릴 수 있다.
- 이는 소스 서버에서 트랜잭션들의 처리 속도를 느리게 하는 대신, 레플리카 서버에서의 처리 속도를 높이는 방법이다
- 하지만 이로 인해, 소스 서버에서 트랜잭션을 실행하는 클라이언트들이 영향을 받을 수 있기에, 설정을 변경한 후 모니터링을 해야 한다.

#### 16.7.2.2.3 잠금 기반 LOGICAL CLOCK 방식
MySQL 5.7.6 버전부터는 잠금 기반 LOGICAL CLOCK 방식의 멀티 스레드 복제를 사용하게 된다.

잠금 기반 방식에서는 선행 트랜잭션의 순번 값이 동일하지 않더라도 커밋 처리 시점이 겹친다면 그 트랜잭션들은 레플리카 서버에서 병렬로 처리될 수 있다.  
이를 위해 MySQL 서버에서는 트랜잭션을 바이너리 로그에 기록할 때 `sequence_number`와 `last_commited` 라는 값을 함께 기록한다.
- **sequence_number**
    - 커밋된 트랜잭션에 대한 논리적인 순번 값
    - 매 트랜잭션이 커밋될 때마다 값이 증가한다.
- **last_commited**
    - 현 트랜잭션 이전에 커밋된 가장 최신 트랜잭션의 sequence_number 값이 저장된다.
- 바이너리 로그 파일이 새로운 파일로 로테이션되는 경우, `sequence_number` 는 1로, `last_commited` 값은 0으로 초기화 된다.

잠금 기반 LOGICAL CLOCK 방식이 적용된 MySQL 버전을 사용하는 레플리카 서버에서는 멀티 스레드 동기화가 활성화돼 있는 경우, 병렬로 트랜잭션을 실행할 때
```markdown
실행하려는 트랜잭션의 last_commited 값 < 현재 실행 중인 트랜잭션들이 가지는 가장 작은 sequence_number 값
```
조건을 기준으로 트랜잭션들의 실행 가능 여부를 판단한다.

잠금 기반 LOGICAL CLOCK 방식은 소스 서버에서 커밋 처리 시점이 겹치는 트랜잭션 수가 많을 수록 레플리카 서버에서 최대한 병렬로 처리되므로 소스 서버에서 그룹 커밋되는 트랜잭션 수에 영향을 받는다. (Commit-parent 방식과 동일)  
→ 즉, `binlog_group_commit_sync_delay` 시스템 변수와 `binlog_group_commit_sync_no_delay_count` 시스템 변수 값을 적절히 조정해서 레플리카 서버의 병렬 처리율을 향상 시킬 수 있다.

#### 16.7.2.2.4 WriteSet 기반 LOGICAL CLOCK 방식
WriteSet 기반 방식은 MySQL 8.0.1 버전에서 도입된 방식으로, 트랜잭션 커밋  처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬처리 여부를 결정한다.

기존 잠금 방식에서는 커밋 처리 시점이 겹치지 않는 두 트랜잭션은 병렬로 실행될 수 없었다.  
그러나, 두 트랜잭션이 서로 다른 데이터를 변경하는 것이라면 WriteSet 기반 방식에서 레플리카 서버가 두 트랜잭션을 병렬로 실행할 수 있다.  
즉 동일한 데이터를 변경하지 않는 트랜잭션들은 레플리카 서버에서 모두 병렬로 실행될 수 있는 것이다.

WriteSet 기반에서는 같은 세션에서 실행된 트랜잭션들의 병렬 처리 여부에 따라 `WRITESET`과 `WRITESET_SESSION` 타입으로 나뉜다.
- 사용자는 `binlog_transaction_dependency_tracking` 시스템 변수를 통해 원하는 타입을 설정할 수 있다.
    - `COMMIT_ORDER`
        - `binlog_transaction_dependency_tracking` 시스템 변수의 기본값
        - 5.7 버전의 잠금 기반 방식과 동일하게 동작 (= 커밋 처리 시점이 겹치는 트랜잭션들은 모두 병렬로 처리될 수 있다.)
    - `WRITESET`
        - 서로 다른 데이터를 변경한 트랜잭션들은 모두 병렬로 처리 가능
    - `WRTIESET_SESSION`
        - 동일한 세션에서 실행된 트랜잭션들은 병렬로 처리될 수 없다
        - 그 외에는 WRITESET으로 설정했을 때와 동일하게 동작한다.

WriteSet 기반 방식에서는 각 트랜잭션에서 변경한 데이터를 기준으로 병렬 처리를 위한 트랜잭션들의 종속관계를 정의 한다.
- 이를 위해 내부적으로 트랜잭션에 의해 변경된 데이터들의 목록을 관리한다.
- 이 변경된 데이터들은 하나하나 전부 해시값으로 표현된다.
- 해싱된 변경 데이터를 WriteSet 이라고 한다.
- WriteSet은 `WriteSet = hash(index, name, db_name, db_name_length, table_name, table_name_length, value, value_length)` 조합으로 생성된다.

> WriteSet은 테이블에 존재하는 유니크한 키의 개수만큼 만들어진다. 따라서 하나의 변경 데이터는 여러 개의 WriteSet을 가질 수 있다.

WriteSet을 생성할 때 사용되는 해시 알고리즘으로는 `transaction_write_set_extraction` 시스템 변수에 지정된 알고리즘이 사용된다.
- 해당 변수는 OFF, MURMUR32, XXHASH64 세 가지 값으로 설정 가능하다.
- 기본값은 XXHASH64 이다.

트랜잭션들의 WriteSet은 MySQL 서버 메모리에서 해시맵(Hash Map) 테이블로 그 히스토리가 관리되는데, 히스토리 테이블에는 변경된 데이터의 해시값인 WriteSet과 해당 데이터를 변경한 트랜잭션의 `sequence_number` 값이 Key-Value 형태로 저장된다.  
사용자는 `binlog_transaction_dependency_history_size` 시스템 변수를 통해 히스토리 테이블이 최대로 가질 수 있는 해싱 데이터(WriteSet) 개수를 정할 수 있다. (기본값은 25000)  
저장된 데이터 수가 지정된 최대 개수 만큼 도달하면 히스토리 테이블은 다시 초기화 되면 DDL 쿼리가 실행된 경우에도 초기화된다.

WriteSet 기반 방식에서도 마찬가지로 트랜잭션이 커밋되면 바이너리 로그에 트랜잭션 정보와 함께 last_committed 값과 sequece_number 값이 함께 기록되며 레플리카 서버에서는 이를 바탕으로 병렬 처리를 수행한다.
- WRITESET과 WRITESET_SESSION 타입 모두 트랜잭션 커밋을 처리할 때 트랜잭션의 last_committed 값을 1차적으로 COMMIT_ORDER 타입을 기반으로 설정한다.
- WriteSet이 존재하는지 확인한 수 이를 바탕으로 다시 last_committed 값을 설정하게 된다.

트랜잭션에서는 만약 WriteSet 히스토리 테이블에 자신의 WriteSet과 충돌되는 WriteSet 데이터가 존재하는 경우 WrtieSet에 매핑된 sequence_number 값을 가져와 가진의 last_committed에 저장하고 해당 WriteSet의 sequence_number를 가진의 sequence_number 값으로 업데이트 한다.  
WRITESET_SESSION 타입에서는 이렇게 결정된 last_committed 값을 , 같은 세션에서 커밋된 마지막 트랜션의 sequence_number 값과 한번 더 비교해서 둘 중 더 큰 값을 선택해 최종적으로 last_committed에 저장한다.

WriteSet 기반 방식에서는 레플리카 서버에서의 트랜잭션 병렬 처리가 소스 서버에서 동시에 커밋되는 트랜잭션 수에 의존적이지 않으므로, 그룹 커밋되는 트랜잭션 수를 늘리기 위해 의도적으로 소스 서버의 트랜잭션 커밋 속도를 저하시킬 필요가 없다.  
WriteSet 기반 방식은 어느 방식보다도 레플리카 서버에서의 병렬 처리성을 높이지는 방식이지만 트랜잭션 커밋시 추가적인 메모리 공간이 필요하며 매 트랜잭션마다 WriteSet 히스토리 테이블에 저장된 값들을 계속 비교해야 하므로 이에 따른 오버헤드가 발생한다.

### 16.7.2.3 멀티 스레드 복제와 복제 포지션 정보
멀티 스레드 복제에서 각 워커 스레드들이 실행한 바이너리 로그 이벤트의 포지션 정보는 `relay_log_info_repository` 시스템 변수에 지정된 값에 따라 MySQL 서버의 mysql 데이터베이스 내 `slave_worker_info` 테이블 혹은 데이터 디렉터리 내 "worker-replay-log.info"라는 접두사를 가진 파일들에 각 스레드 별로 저장된다.
- 워커 스레드들은 이벤트 실행 완료할 때마다 해당 데이터를 갱신한다.
- 현재 복제 이벤트의 처리 현황을 보여주는 어플라이어 메타데이터에는 워커 스레드들이 실행한 이벤트들에서 로우 워터마크에 해당하는 이벤트의 포지션 값이 저장된다.
- 포지션 값은 코디네이터 스레드가 수행하는 체크 포인트 작업에 의해 주기적으로 갱신된다.

코디네이터 스레드는 시스템 변수들에 설정된 값을 바탕으로 워커 스레드들에서 실행된 이벤트들에 대해 체크포인트를 수행해 어플라이어 메타데이터를 갱신한다.
- slave_checkpoint_period
    - 코디네이터 스레드들의 어플라이어 메타데이터 갱신 작업의 실행 주기를 결정하는 시스템 변수
    - 기본값은 300이며 단위는 밀리초
- slave_checkpoint_group
    - slave_checkpoint_period 시스템 변수와 동일한 역할로 사용
    - 시간 대신 트랜잭션의 개수를 지정
    - 10으로 설정하면 코디네이터 스레드는 10개의 트랜잭션을 실행한 후 어플라이어 메타데이터를 갱신하도록 체크포인트를 발생시킨다.

## 16.7.3 크래시 세이프 복제
> MySQL 서버를 운영하다 보면 예기치 못한 장애로 인해 MySQL이 비정상 종료되는 경우를 종종 겪곤하는데, 레플리카 서버였다면 비정상 종료 후 다시 MySQL을 구동시켰을 때, 소스 서버와의 복제 동기화가 실패할 수 있다.

MySQL에서는 비정상 종료된 후 재구동됐을 때도 복제가 원활하게 재개될 수 있게 여러 설정을 제공하는데, 이를 통해 사용자는 서버 장애 이후에도 문제없이 복제가 진행되는 크래시 세이프 복제를 실현할 수 있다.  
크래시 세이프 복제는 단순히 어떤 옵션 하나를 활성화해서 적용하는 기능이 아니라 여러 가지 복제 관련 옵션들을 복제 사용 형태에 따라 적절히 설정했을 때 얻게되는 효과라 할  수 있다.

### 16.7.3.1 서버 장애와 복제 실패
MySQL 서버가 비정상 종료하는 경우 처리한 내역과 포지션 정보 간의 불일치가 발생할 수 있다.
- I/O 스레드가 릴레이 로그에 이벤트를 기록한 후 아직 포지션 정보 파일에 업데이트 하지 않은 상태에서 MySQL이 비정상 종료되면 MySQL을 재구동할 때 릴레이 로그에 동일한 이벤트가 기록될 수 있다.
- SQL 스레드가 릴레이 로그에 기록된 트랜잭션을 커밋한 후 아직 포지션 정보 파일에 업데이트를 하지 않은 상태에서 MySQL이 비정상 종료되면 MySQL을 재구동할 때 동일한 트랜잭션이 재실행 될 수 있다.

> 불일치로 인해 흔히 겪는 Duplicated key 에러가 발생할 수 있는데, 동일한 INSERT 쿼리가 두 번 실행됐을 때 발생할 수 있다.  
> 불일치 상황에 따라 다양한 에러가 발생할 수 있으며 최악의 경우에는 에러 없이 데이터가 잘못 될 수 있다.

MySQL 5.6 버전부터는 이 포지션 정보들을 TABLE 형태로도 관리할 수 있게 됐다.  
TABLE로 관리하는 경우 InnoDB 엔진을 사용하므로 SQL 스레드가 트랜잭션 적용과 포지션 정보 업데이트를 한 트랜잭션으로 묶어 원자적으로 처리할 수 있게 된다.  
이로인해 MySQL이 비정상적으로 종료됐을 때 포시션 불일치로 인해 SQL 스레드가 동일한 쿼리를 재실행하는 문제는 방지할 수 있게 됐다.

I/O 스레드의 포지션 불일치 문제는 `relay_log_recovery` 옵션이 도입되면서 해결되었다.  
해당 옵션을 활성화해서 MySQL 서버를 재구동하면 MySQL 서버는 I/O 스레드의 포지션을 SQL 스레드가 마지막으로 실행했던 포지션으로 초기화하고 새로운 릴레이 로그 파일 을 생성해서 SQL 스레드가 읽어야 할 릴레이 로그 포지션 위치를 초기화한다.  
이로 과정으로 인해 MySQL 서버는 비정상적으로 종료되기 전 마지막에 실행했던 트랜잭션 이후로 다시 정상적인 복제를 시작할 수 있다.

```bash
relay_log_recovery=ON
relay_log_info_repository=TABLE
```

### 16.7.3.2 복제 사용 형태별 크래시 세이프 복제 설정
MySQL 복제는 사용자가 설정한 내용에 따라 복제 타입 및 동기화 방식이 다르며, 크래시 세이프 복제 설정도 조금씩 달라질 수 있다.

#### 16.7.3.2.1 바이너리 로그 파일 위치 기반 복제 + 싱글 스레드 동기화
바이너리 로그  파일 위치 기반이면서 싱글 스레드로 복제 동기화가 처리되는 복제 형태에서는 옵션을 설정 했을 때 크래시 세이프 복제가 된다.
```sh
relay_log_recovery=ON
relay_log_info_repository=TABLE
```
- 최소 옵션 설정 셋과 동일하며 MySQL 서버만 비정상적으로 종료됐을 경우에 한해 복제가 정상적으로 재개될 수 있다.

#### 16.7.3.2.2 바이너리 로그 파일 위치 기반 복제 + 멀티 스레드 동기화
바이너리 로그 파일 위치 기반이면서 멀티 스레드로 복제 동기화가 처리되는 복제 형태에서는 레플리카 서버에서 복제된 트랜잭션들의 커밋 순서가 소스 서버에서와 동일하도록 설정됐는지 여부에 따라 크래시 세이프 복제를 위한 옵션 셋이 달라짐

1. 소스 서버와 트랜잭션 커밋 순서 일치 여부: **커밋 순서 일치**
```sh
relay_log_recovery=ON
relay_log_info_repository=TABLE
```

2. 소스 서버와 트랜잭션 커밋 순서 일치 여부: **커밋 순서 불일치**
```sh
relay_log_recovery=ON
relay_log_info_repository=TABLE
sync_relay_log=1
```

레플리카 서버에서 트랜잭션의 커밋 순서가 소스 서버와 일치하도록 설정된 경우에는 최소 옵션 셋으로만 설정해도 크래시 세이프 복제가 된다.  
커밋 순서가 일치하지 않는 경우에는 `sync_relay_log=1` 옵션을 추가로 함께 설정해야 크래시 세이프한 복제가 될 수 있다.
- `sync_relay_log`
    - 릴레이 로그를 디스크와 얼마나 자주 동기화할 것인지 제어하는 옵션
    - 0으로 설정되면 MySQL에서는 동기화를 하지 않고 운영체제 설정에 따라 동기화 수행
    - 0으로 크게 설정되면 릴레이 로그에 지정된 수만큼 이벤트가 기록됐을 때 디스크와 동기화한다
    - 기본 값은 10000

`sync_relay_log` 값이 1이 아닌 0이나 1이상의 값을 사용하면 MySQL 서버가 비정상적으로 종료됐을 때 미처 디스크에 동기화하지 못한 릴레이 로그의 내용이 유실될 수 있다.  
그 이유는 멀티 스레드로 동기화될 때 발생할 수 있는 *트랜잭션 갭* 때문이다.
- 트랜잭션 갭은 멀티 스레드 복제에서 병렬 처리로 인해 트랜잭션들이 순서대로 처리되지 않아 일시적으로 발생하는 트랜잭션 간의 간격을 의미한다.
- 멀티 스레드 동기화를 사용하는 경우 `relay_log_recovery`가 활성화돼 있는 MySQL에서는 재구동시 트랜잭션 갭을 메우는 작업이 이뤄진다.

`sync_relay_log` 옵션이 1이면 이벤트 릴레이 로그에 기록될 때마다 디스크에도 동기화가 처리되므로 MySQL이 비정상적으로 종료되더라도 릴레이 로그에서 이벤트 손실을 최소화할 수 있게 된다.  
하지만, 디스크에 부하를 주게 되며 복제시 성능이 저하될 수 있음을 유의해야 한다.

멀티 스레드 복제를 사용할 때는 **LOGICAL_CLOCK 방식**을 사용하고 **slave_preserve_commit_order 옵션을 1로** 설정해서 트랜잭션 갭이 발생하지 않게 함으로써 sync_relay_log=1 설정 없이도 크래시 세이프한 복제가 될 수 있게 하는 것을 권장한다.

#### 16.7.3.2.3 GTID 기반 복제 + 싱글 스레드 동기화
GTID 기반이면서 싱글 스레드로 복제 동기화 처리되는 복제 형태에서는 mysql.grid_exectued 테이블 데이터가 복제된 트랜잭션이 적용될 때마다 매번 함께 갱신되는지 여부에 따라 크래시한 세이프 복제를 위한 옵션 셋이 달라진다.
- **gtid_executed 테이블 데이터가 매 트랜잭션 적용 시 갱신되는 경우**
```bash
relay_log_recovery=ON
# MySQL 8.0.23 미만 버전
MASTER_AUTO_POSITION=1
# MySQL 8.0.23 이상 버전
SOURCE_AUTO_POSITION=1
```
- **gtid_executed 테이블 데이터가 매 트랜잭션 적용 시 갱신되지 않는 경우**
```bash
relay_log_recovery=ON
# MySQL 8.0.23 미만 버전
MASTER_AUTO_POSITION=1
# MySQL 8.0.23 이상 버전
SOURCE_AUTO_POSITION=1
sync_binlog=1
innodb_flush_log_at_trx_commit=1
```

#### 16.7.3.2.4 GTID 기반 복제 + 멀티 스레드 동기화
GTID 기반이면서 멀티 스레드로 복제 동기화가 처리되는 복제 형태에서 크래시 세이프한 복제 설정은 싱글 스레드로 동기화되는 경우와 동일하다

한 가지 유의할 점은 멀티 스레드 복제인 경우, MySQL 서버가 비정상적으로 종료된 후 `relay_log_recovery=ON` 설정으로 재구동 시 트랜잭션 갭을 메우는 작업이 수행된다는 점이다.  
그러나 SOURCE_AUTO_POSITION 옵션을 사용하는 GTID 기반 복제에서는 불필요한 작업이다  
그래서 MySQL 8.0.18/5.7.28 버전부터는 GTID 기반이면서 SOURCE_AUTO_POSITION 옵션을 사용하는 경우에 대해서는 이러한 작업이 자동으로 생략되도록 코드가 수정됐다.

## 16.7.4 필터링된 복제 (Filtered Replication)
MySQL 복제에서는 소스 서버의 특정 이벤트들만 레플리카 서버에 적용될 수 있도록 필터링 기능을 제공한다.
- 필터링의 주체는 소스 서버와 레플리카 서버 둘 다 될 수 있다
- 레플리카 서버에서 좀 더 다양한 형태의 필터링을 사용할 수 있다.

소스 서버에서는 발생한 이벤트들 중 특정 이벤트등만 바이너리 로그에 기록하거나 혹은 기록하지 않음으로써 복제에서 이벤트가 필터링될 수 있게 한다.
- 소스 서버에서의 필터링은 데이터베이스 단위로만 가능하다
- 두가지 옵션을 사용해 MySQL 서버에서 특정 데이터베이스에 대한 이벤트들만 바이너리 로그에 기록되게 하거나 혹은 기록되지 않게 할 수 있다.
    - binlog-do-db
        - 바이너리 로그에 기록할 데이터베이스명을 지정한다
        - 이 옵션에 지정된 데이터베이스에 대한 이벤트들만 바이너리 로그에 기록된다.
    - binlog-ignore-db
        - 바이너리 로그에 기록하지 않을 데이터베이스명을 지정한다.
        - 이 옵션에 지정된 데이터베이스에 대한 이벤트 들은 바이너리 로그에 기록되지 않는다.
- 두 옵션은 MySQL 서버를 시작할 때 커맨드 라인이나 설정 파일에 지정해서 사용 가능하다
    - MySQL 서버를 구동하는 중에는 동적으로 변경할 수 없고 재시작을 통해서만 변경할 수 있다.
    - 옵션에 설정한 값은 `SHOW MASTER STATUS` 명령을 통해 적용된 내용을 확인할 수 있다.

레플리카 서버에서는 소스 서버에서보다 훨씬 더 유연한 형태로 필터링 설정이 가능하다
- MySQL 서버를 재시작하지 않고 동적으로 필터링 설정을 변경할 수도 있다.
    - 레플리카 서버에서의 필터링은 릴레이 로그에 저장된 이벤트들을 실행하는 시점에 적용된다.
- 레플리카 서버를 시작할 때 커맨드 라인 혹은 설정 파일에 옵션을 지정하거나 구동중인 상태에서 `CHANGE REPLICATION FILTER` 구문을 사용해 복제 필터링을 설정
- `CHANGE REPLICATION FILTER` 구문은 다양한 옵션을 가진다.
    - 책 p.549 ~ 550에서 확인할 수 있다.
    - 해당 구문을 사용해 복제 필터링을 적용하려면 복제 시작 전 해당 구문을 사용하면 된다.
    - 복제가 이미 시작된 상태라면 STOP REPLICA SQL_THREAD 명령을 실행해 SQL 스레드를 멈춘 후 해당 구문을 사용한 후 START REPLICA SQL_THREAD 명령으로 SQL 스레드를 재시작하면 필터링이 적용된다.

복제 필터링이 적용된 레플리카 서버에서는 복제된 이벤트 실행 시 먼저 데이터베이스 수준으로 설정된 필터링 옵션들을 바탕으로 1차적으로 필터링하고, 그다음 테이블 수준으로 설정된 필터링 옵션들을 체크해서 최적으로 이벤트의 적용 여부를 결정하게 된다.  
데이터베이스 수준의 필터링 옵션들의 경우 복제되어 넘어온 이벤트의 바이너리 로그 포맷에 따라 같은 이벤트라도 필터링 처리 결과가 달라질 수 있음을 유의해야 한다.

사용자는 레플리카 서버에서 필터링 처리가 일관될 수 있도록 다음과 같은 방식으로 쿼리를 사용해야 한다.
- **ROW 포맷 사용 시**
    - DDL 문에 대해 USE 문을 사용해 디폴트 데이터베이스가 설정되게 한다
    - 쿼리에서 데이터베이스명을 지정하지 않는다
- **STARTMENT 또는 MIXED 포맷 사용 시**
    - DML 및 DDL 문 모두 USE 문을 사용해 디폴트 데이터베이스가 설정되게 하고 쿼리에서 데이터베이스명을 지정하지 않는다
    - 복제 대상 데이터과 복제 제외 대상 테이블을 모두 변경하는 DML을 사용하지 않는다.