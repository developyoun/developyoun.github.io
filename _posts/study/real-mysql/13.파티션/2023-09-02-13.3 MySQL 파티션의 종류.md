---
title: 13.3 MySQL 파티션의 종류

categories:
- study

tags:
- database

toc: true
toc_sticky: true
toc_label: Contents
---

다른 DBMS와 마찬가지로 MySQL에서도 4가지 기본 파티션 기법을 제공하고 있으며, 해시와 파티션에 대해서는 리니어 파티션과 같은 추가적인 기법도 제공한다.
- 레인지 파티션
- 리스트 파티션
- 해시 파티션
- 키 파티션

## 13.3.1 레인지 파티션
파티션 키의 연속된 범위로 파티션을 정의하는 방법
→ 일반적으로 사용되는 파티션 방법 중 하나
→ 다른 파티션 방법과는 달리, **MAXVALUE**라는 키워드를 이용해 명시되지 않은 범위의 키 값이 담신 레코드를 저장하는 파티션 정의 가능

### 13.3.1.1 레인지 파티션의 용도
- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

데이터베이스의 파티션 장점은 다음 2가지로 구분할 수 있다
- 큰 테이블을 작은 크기의 파티션으로 분리
- 필요한 파티션만 접근 (쓰기 + 읽기)

> 실제 데이터베이스 서버의 파티션에서 두 가지 장점을 모두 갖기는 어렵지만, 이력을 저장하는 테이블에서 레인지 파티션은 두 장점을 어렵지 않게 가질 수 있다.

### 13.3.1.2 레인지 파티션 테이블 생성
```sql
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	...
) PARTITION BY RANGE( YEAR(hired)) (
	PARTITION p0 VALUES LESS THAN (1991),
	PARTITION p1 VALUES LESS THAN (1996),
	PARTITION p2 VALUES LESS THAN (2001),
	PARTITION p3 VALUES LESS THAN MAXVALUE
)
```
- PARTITION BY RANGE 키워드로 레인지 파티션 정의
- PARTITION BY RANGE 뒤에 컬럼 또는 내방 함수를 이용해 파티션 키 명시
- VALUES LESS THAN으로 명시된 값보다 작은 값만 해당 파티션에 저장하게 설정
- VALUES LESS THAN MAXVALUE로 명시되지 않은 레코드를 저장할 파티션 지정
- 테이블과 각 파티션은 같은 스토리지 엔진으로 정의할 수 있다.

### 13.3.1.3 레인지 파티션의 분리와 병합
#### 13.3.1.3.1 단순 파티션의 추가
```sql
ALTER TABLE employees 
ADD PARTITION (PARTITION p4 VALUES LESS THAN (2011));
```
- 하지만, 여기서 하나의 레코드는 반드시 하나의 파티션만 저장돼야 한다는 기본 조건을 벗어나게 된다면 에러가 발생한다.
	- 이런 경우에는, `ALTER TABLE ... REORGANIZE PARTION` 명령을 사용해야 한다.

ALTER TABLE ... REORGANIZE PARTION 명령은 파티션의 레코드를 모두 새로운 두 개의 파티션으로 복사하는 작업을 필요로 한다.
→ 파티션의 레코드가 매우 많다면 이 작업은 매우 오랜 시작이 걸릴 것이다.

레인지 파티션에서는 일반적으로 LESS THAN MAXVALUE 절을 사용하는 파티션은 추가하지 않고, 미래에 사용될 파티션을 미리 2~3개 정도 더 많들어 두는 형태로 테이블을 생성하기도 한다.
→ 그리고 배치 스크립트를 이용해 주기적으로 파티션 테이블의 여유 기간을 판단해 파티션을 자동으로 추가하는 방법을 사용한다.
→ 하지만 배치 스크립트의 오류로 파티션이 자동으로 추가되지 못할 수도 있다.

#### 13.3.1.3.2 파티션 삭제
레인지 파티션을 사용하는 테이블에서 파티션을 삭제하려면 `DROP PARTIION` 키워드에 삭제하려는 파티션의 이름을 지정하면 된다.
→ 레인지 파티션 및 리스트 파이션 테이블에서 특정 파티션을 삭제하는 작업은 아주 빠르게 처리되므로 날짜 단위로 파티션된 테이블에서 오래된 데이터를 삭제하는 용도로 자주 사용된다.
```sql
ALTER TABLE employees DROP PARTION p0;
```

레인지 파티션을 사용하는 테이블에서 파티션을 삭제할 때 가장 오래된 파티션 순서로만 삭제할 수 있다.
→ 즉, 중간에 있는 파티션을 먼저 삭제할 수는 없다.

#### 13.3.1.3.3 기존 파티션의 분리
하나의 파티션을 두 개 이상의 파티션으로 분리하고자 할 때는 `REORGANIZE PARTION` 명령을 사용하면 된다.
→ MAXVALUE 파티션뿐만 아니라, 다른 파티션들도 해당 명령을 이용해 분리할 수 있다.

REORGANIZE PARTITION 명령은 기존 파티션의 레코드를 새로운 파티션으로 복사해야 하기 때문에 기존 파티션의 레코드 건수에 따라 시간이 오래 걸릴 수도 있다.
→ 기존 파티션의 레코드가 많다면 온라인 DDL로 실행할 수 있게, ALGORITHM과 LOCK 절을 사용하자.

#### 13.3.1.3.4 기존 파티션의 병합
여러 파티션을 하나의 파티션으로 병합하는 작업도 `REORGANIZE PARTION` 명령으로 처리할 수 있다.
→ 파티션을 병합하는 경우에도 파티션 재구성이 필요하며, 작업은 테이블에 대해서 읽기 잠금을 필요로 한다는 것을 주의해야 한다.

## 13.3.2 리스트 파티션
레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만, 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다.
> 리스트 파티션에서는 레인지 파티션과 같이 MAXVALUE 파티션을 정의할 수 없다.

### 13.3.2.1 리스트 파티션의 용도
테이블이 아래와 같은 특성을 지닐 때는 리스트 파티션을 사용하는 것이 좋다.
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 때

### 13.3.2.2 리스트 파티션 테이블 생성
```sql
CREATE TABLE product(
	id INT NOT NULL,
	name VARCHAR(30),
	category_id INT NOT NULL,
	...
) PARTITION BY LIST(category_id) (
	PARTITION p_appliance VALUES IN (3),
	PARTITION p_computer VALUES IN (1, 9),
	PARTITION p_sports VALUES IN (2, 6, 7),
	PARTITION p_etc VALUES IN (4, 5, 8, NULL)
)
```
- `PARTITION BY LIST` 키워드로 생성할 파티션이 리스트 파티션이라는 것을 명시
- `PARTITION BY LIST` 키워드 뒤에 파티션 키 정의
- VALUES IN (…) 을 이용해 파티션 별로 저장할 파티션 키 값의 목록 나열
- 파티션별로 저장할 키 값 중에 NULL을 명시할 수도 있다.
- 레인지 파티션과는 달리, 나머지 모든 값을 저장하는 MAXVALUE 파티션은 정의할 수 없다.

> 정수 타입의 파티션 키뿐만 아니라 파티션 타입이 문자열 타입일 때도 리스트 파티션을 사용할 수 있다.

### 13.3.2.3 리스트 파티션의 분리와 병합
파티션을 정의하는 부분에서 `VALUES LESS THAN` 이 아닌 `VALUES IN` 을 사용한다는 것 외에는 레인지 파티션의 추가 및 삭제, 병합 작업이 모두 같다.
→ 특정 파티션의 레코드 건수가 많아져서 두 개 이상의 파티션으로 분리하거나 그 반대로 병합하려면 `REORGANIZE PARTITION `명령을 이용하면 된다.
### 13.3.2.4 리스트 파티션의 주의 사항
다른 파티션 방법에 비해 리스트 파티션은 다음과 같은 제약사항이 있다.
- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있다.

## 13.3.3 해시 파티션
해시 파티션은 다음과 같은 특성을 지닌 테이블에 적합하다.
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때

### 13.3.3.2 해시 파티션 테이블 생성
```sql
-- 1. 파티션 개수만 지정
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	...
) PARTITION BY HASH(id) PARTITIONS 4;

-- 2. 파티션의 이름을 별도로 지정하고자 할 때
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	...
) PARTITION BY HASH(id)
PARTITIONS 4 (
	PARTITION p0 ENGINE=INNODB,
	PARTITION p1 ENGINE=INNODB,
	PARTITION p2 ENGINE=INNODB,
	PARTITION p3 ENGINE=INNODB,
);
```
- PARTITION BY HASH 키워드로 파티션 종류를 해시 파티션으로 지정
- PARTITION BY HASH 키워드 뒤에 파티션 키 명시
- 해시 파티션의 파티션 키 또는 파티션 표현식은 반드시 정수 타입의 값을 반환함
- PARTITION n으로 몇 개의 파티션을 생성할 것인지 명시
- 파티션의 개수뿐만 아니라, 각 파티션의 이름을 명시하려면 뒤에 파티션을 나열하면 된다.
	- 파티션의 개수만 지정하면 각 파티션의 이름은 기본적으로 p0, p1, p2 … 와 같은 규칙으로 생성된다.

### 13.3.3.3 해시 파티션의 분리와 병합
해시 파티션의 분리와 병합은 (리스트 파티션이나 레인지 파티션과는 달리) 대상 테이블의 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요
→ 파티션의 분리나 병합으로 인해 파티션의 개수가 변경된다는 것은 해시 함수의 알고리즘을 변경하는 것이므로 전체 파티션이 영향을 받는 것은 피할 수 없다.

#### 13.3.3.3.1 해시 파티션 추가
해시 파티션은 특정 파티션 키 값을 테이블의 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정
→ 즉, 해시 파티션은 테이블에 존재하는 **파티션의 개수에 의해 파티션 알고리즘이 변한다**.
> 해시 파티션에서는 새로운 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치 돼야 한다.

```sql
-- 1. 파티션 1개만 추가하면서 파티션 이름을 부여하는 경우
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
	ADD PARTITION(PARTITION p5 ENGINE=INNODB);

-- 2. 동시에 6개의 파티션을 별도로 이름 없이 추가하는 경우
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED,
	ADD PARTITION PARTITIONS 6;
```

해시 파티션에서 파티션을 추가하는 작업은 INPLACE 알고리즘으로 실행된다고 하더라도 레코드 리빌드 작업이 필요하고 테이블에 대한 읽기 잠금이 필요하다.
→ 이런 부분 때문에, 해시 파티션에서 파티션을 추가하거나 생성하는 작업은 많은 부하를 발생시킨다
→ 또한, 다른 트랜잭션에서 동일 테이블에 데이터를 변경하는 작업은 허용되지 않는다.

#### 13.3.3.3.2 해시 파티션 삭제
해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없다.
→ 해시나 키 파티션을 사용하는 테이블에서 특정 파티션을 삭제하려고 하면 에러 메시지가 발생하면서 종료된다.
```sql
ALTER TABLE employees DROP PARTITION p0;
Error Code: 1512
DROP PARTITION can only be used on RANGE/LIST partitions
```

#### 13.3.3.3.3 해시 파티션 분할
해시 파티션이나 키 파티션에서 특정 파티션을 두 개 이상의 파티션으로 분할하는 기능은 없다.
→ 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능

#### 13.3.3.3.4 해시 파티션 병합
해시나 키 파티션은 2개 이상의 파티션을 하나의 파티션으로 통합하는 기능은 제공하지 않는다.
→ 파티션의 개수를 줄이는 것만 가능하다.

파티션의 개수를 줄일 때는 COALESCE PARTITION 명령을 사용하면 된다.
```sql
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED
COALESCE PARTITION 1;
```
- COALESCE PARTITION 뒤에 명시한 숫자는 줄이고자 하는 파티션의 개수를 의미한다.
- 삭제되는 파티션에 저장돼 있던 레코드가 남은 파티션으로 복사되는 것이 아니라, 테이블의 모든 레코드가 재배치 되는 작업이 수행돼야 한다.
	- 즉, INPLACE 알고리즘을 실행되긴 하지만, 테이블의 전체 레코드에 대해 리빌드 작업이 필요하고 다른 트랜잭션의 데이터 변경이 허용되지 않는다.

#### 13.3.3.3.5 해시 파티션 주의사항
- 특정 파티션만 삭제하는 것은 불가능
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존 모든 데이터의 재배치 작업이 필요
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책링지 확인이 필요
- 일반적으로 사용자들에게 익숙한 파티션의 조작이나 특성은 대부분 리스트 파티션이나 레인지 파티션에만 해당하는 것들이 많다.
	- 해시 파티션이나 키 파티션을 사용하거나 조작할 때는 주의가 필요하다.

## 13.3.4 키 파티션
키 파티션은 해시 파티션과 사용법과 특성이 거의 같다.
→ 해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 사용자가 명시한다.
→ 키 파티션은 해시 값의 계산도 MySQL 서버가 수행한다.

키 파티션에서는 정수 타입이나 정숫값을 반환하는 표현식 뿐만 아니라 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다.
→ MySQL 서버는 선정된 파티션 키의 값을 `MD5()` 함수를 이용해 해시 값을 계산하고, 그 값을 MOD 연산해서 데이터를 각 파티션에 분배한다.

```sql
-- 1. 프라이커리 키가 있는 경우 자동으로 프라이머리 키가 파티션 키로 사용됨
CREATE TABLE k1 (
	id INT NOT NULL,
	name VARCHAR(20),
	PRIMARY KEY (id)
)
-- 괄호의 내용을 비워 두면 자동으로 프라이머리 키의 모든 컬럼이 파티션 키가 됨
-- 그렇지 않고 프라이머리 키의 일부만 명시할 수도 있음
	PARTITION BY KEY()
		PARTITIONS 2;

-- 2. 프라이머리 키가 없는 경우 유니크 키(존재한다면)가 파티션 키로 사용됨
CREATE TABLE k1 (
	id INT NOT NULL,
	name VARCHAR(20),
	UNIQUE KEY (id)
)
-- 괄호의 내용을 비워 두면 자동으로 프라이머리 키의 모든 컬럼이 파티션 키가 됨
-- 그렇지 않고 프라이머리 키의 일부만 명시할 수도 있음
	PARTITION BY KEY()
		PARTITIONS 2;

-- 3. 프라이머리 키나 유니크 키의 컬럼 일부를 파티션 키로 명시적으로 설정
CREATE TABLE dept_emp (
	emp_no INT NOT NULL,
	dept_no CHAR(4) NOT NULL,
	...
	PARIMARY KEY (dept_nol, emp_no)
)
-- 괄호의 내용에 프라이머리 키나 유니크 키를 구성하는 컬럼 중에서
-- 일부만 선택해 파티션 키로 설정하는 것도 가능하다.
	PARTITION BY KEY(dept_no)
		PARTITIONS 2;
```
- PARTITION BY KEY 키워드로 키 파티션 정의
- PARTITION BY KEY 키워드 뒤에 파티션 키 컬럼 명시
	- 만약, 아무 컬럼도 명시하지 않으면 MySQL 서버가 자동으로 프라이머리 키나 유니크 키의 모든 컬럼을 파티션 키로 선택
	- PK가 있는 경우 프라이머리 키의 모든 컬럼으로, PK가 없다면 유니크 인덱스의 모든 컬럼으로 파티션 키를 구성
- 프라이머리 키나 유니크 키를 구성하는 컬럼 중에서 일부만 파티션 키로 명시하는 것도 가능
- PARTITIONS 키워드로 생성할 파티션 개수를 지정

### 13.3.4.2 키 파티션의 주의사항 및 특이사항
- 키 파티션은 MySQL 서버가 내부적으로 `MD5()` 함수를 이용해 파티션하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 된다.
- 프라이머리 키나 유니크 키를 구성하는 컬럼 중 일부만으로 파티션할 수 있다.
- 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL이어야 한다.
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 효율적이다.

## 13.3.5 리니어 해시 파티션/리니어 키 파티션
해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션만이 아니라 테이블의 전체 파티션에 저장된 레코드의 재분배 작업이 발생한다.
→ 이러한 단점을 최소화하기 위해 **리니어 해시 파티션/리니어 키 파티션 알고리즘**이 고안되었다.
→ 해당 파티션은 각 레코드 분배를 위해 'Power-of-two (2의 승수)' 알고리즘을 이용한다.
→ 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화 해준다.

### 13.3.5.1 리니어 해시 파티션/리니어 키 파티션의 추가 및 통합
리니어 해시 파티션/리니어 키 파티션의 경우 단순히 나머지 연산으로 레코드가 저장될 파티션을 결정하는 것이 아니라, Power-of-two 분배 방식을 사용하기 때문에 파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 이동 작업을 하면 된다.
→ 그래서 파티션을 추가하거나 통합하는 작업에서 나머지 파티션의 데이터는 재분배 대상이 되지 않는 것이다.

#### 13.3.5.1.1 리니어 해시 파티션/리니어 키 파티션의 추가
리니어 해시 파티션이나 리니어 키 파티션에 새로운 파티션을 추가하는 명령은 일반 해시 파티션이나 키 파티션과 동일하다.
→ 하지만 Power-of-two 알고리즘으로 레코드가 분배돼 있기 때문에 새로운 파티션을 추가할 때도 특정 파티션의 레코드만 재분배하면 된다.
→ 다른 파티션 데이터는 레코드 재분배 작업과 관련이 없기 때문에 일반 해시 파티션이나 키 파티션의 파티션 추가보다 매우 빠르게 처리할 수 있다.

#### 13.3.5.1.2 리니어 해시 파티션/리니어 키 파티션의 통합
리니어 해시 파티션이나 리니어 키 파티션에서 여러 파티션을 하나의 파티션으로 통합하는 작업 또한 새로운 파티션을 추가할 때와 같이 일부 파티션에 대해서만 레코드 통합 작업이 필요하다.
→ 통합되는 파티션만 레코드 이동이 필요하며, 나머지 레코드는 레코드 재분배 작업에서 제외된다.

#### 13.3.5.1.3 리니어 해시 파티션/리니어 키 파티션과 관련된 주의사항
리니어 파티션은 Power-of-two 알고리즘을 사용하기 때문에, 파티션을 추가하거나 통합할 때 작업의 범위를 최소화하는 대신 각 파티션이 가지는 레코드의 건수는 일반 해시 파티션이나 키 파티션보다는 덜 균등해질 수 있다.
→ 새로운 파티션을 추가하거나 삭제해야할 요건이 많다면 리니어 해시 파티션 혹은 리니어 키 파티션을 적용하는 것이 좋다.
→ 파티션을 조정할 필요가 거의 없다면 일반 해시 파티션이나 키 파티션을 이용하는 것이 좋다.

## 13.3.6 파티션 테이블의 쿼리 성능
쿼리의 실행 계획이 수립될 때 불필요한 파티션을 모두 배제하고 꼭 필요한 파티션만 걸러내는 과정을 **파티션 프루닝(Partition prunning)** 이라고 한다.
→ 쿼리의 성능은 테이블에서 얼마나 많은 파티션을 프루닝할 수 있는지가 관건이다.
→ 옵티마이저가 수립하는 실행 계획에서 어떤 파티션이 제외되고 어떤 파티션만 접근하는지는 쿼리의 실행 계획으로 확인할 수 있다.

```ad-note
파티션 테이블에서 쿼리가 실행될 때 테이블의 모든 파티션을 읽을지 아니면 일부 파티션만 읽을지는 성능에 아주 큰 영향을 미친다.
```

일반적으로 레인지 파티션이나 리스트 파티션을 사용하는 테이블에서는 `CREATE TABLE` 또는 `ALTER TABLE` 명령으로 개별 파티션을 명시해야 한다.
→ 그래서 레인지 파티션이나 리스트 파티션이 사용되는 테이블의 파티션 개수는 10~20개 내외로 적은 편이다.
해시 파티션이나 키 파티션의 경우, 단순히 `CREATE TABLE` 명령에 파티션의 개수만 지정하면 되기 때문에 많은 파티션을 가진 테이블도 쉽게 생성할 수 있다.

파티션을 사용할 때는 반드시 파티션 프루닝이 얼마나 도움이 될지를 먼저 예측해보고 응용 프로그램에 적용하자.
```ad-tip
레인지 파티션 이외의 파티션을 적용할 때는 파티션 프루닝을 더 많이 고민해보고 적용할 것을 권한다.
```
