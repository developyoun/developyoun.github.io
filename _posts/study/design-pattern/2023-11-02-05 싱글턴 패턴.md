---
title: 05.싱글턴 패턴
categories:
- 디자인패턴
tags:
- design-pattern
- study
toc: true
toc_sticky: true
toc_label: Contents
---

스레드 풀, 캐시, 대화상자, 사용자 설정, 레지스트리 객체, 로그 기록 객체, 디바이스 드라이버 등 하나만 있어도 잘 돌아가는 객체는 많다.  
→ 오히려 2개 이상이면 자원을 불필요하게 잡든지 결과에 일관적이지 않은 문제가 발생할 수 있다.

## 정의
**싱글톤 패턴은 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.**
- 싱글톤 패턴을 실제 적용할 떈, 하나뿐인 인스턴스를 관리하도록 만들면 된다.
- 다른 어떤 클래스에서도 인스턴스를 추가로 만들지 못하게 해야한다.
- 어디서든 그 하나뿐인 인스턴스에 접근할 수 있도록 전역 접근 지점을 제공한다.

```java
public class Singleton {

    private static Singleton instance;
    
    private Singleton() {
        // 외부에서 호출못하게 private로 생성자 지정
    }

    public static Singleton getInstance() {
    		if (instance == null) {
			instance = new Singleton()
		}
		return instance;
    }
}
```

## 문제점
싱글톤 패턴의 문제점 중 하나는 바로 **동시성** 문제이다  
즉, 싱글스레드가 아닌 멀티스레드 환경에서 여러 스레드가 `getInstance()` 메소드에 접근하여 여러개의 인스턴스가 동시에 생성될 수 있다는 것.

![](https://i.imgur.com/U7A7STI.png)

## 문제점 해결하기

### 1. syncronized 키워드 사용하기
`syncronized` 키워드를 붙힌 메서드 블럭은 하나의 스레드만 접근할 수 있도록 하여 동시성 문제를 해결할 수 있다.  
→ 이는 한 스레드가 메소드 사용을 끝내기 전까지 다른 스레드가 기다리며, 2개의 스레드가 메서드를 동시에 실행하는 일을 방지할 수 있다.

```java
public class Singleton {
	// ... 생략

	public static syncronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton()
		}
		return instance;
	}

	// ... 생략
}
```

하지만, 인스턴스가 생성되는 초기 시점을 제외하면 불필요한 오버헤드를 발생시키는 상황이 발생될 수 있다.  
→ 만약 `getInstance()` 메소드가 어플리케이션에 큰 부담을 주지 않는다면 그냥 사용하되 동기화는 성능이 100배 정도 저하된다는 사실을 기억하자.

### 2. 초기에만 인스턴스를 만드는 방법
말 그대로 처음부터 인스턴스를 생성하고 이후에는 생성된 인스턴스만 반환시키는 방법이다.

```java
public class Singleton {
	private static Singleton instance = new Singleton();

	private Singleton();

	public static syncronized Singleton getInstance() {
		// 처음부터 Singleton 인스턴스를 만들어서 instance에 관리하므로 그냥 반환하면 된다.
		return instance;
	}
}

```

### 3. DCL을 사용한 동기화 방법
DCL (Double Checked Locking)을 사용하면 인스턴스가 생성되어 있는지 확인한 다음 생성되지 않았을 때 동기화 할 수 있다.
> DCL은 자바 1.4 이상 버전에서 사용가능

```java
public class Singleton {
	private volatile static Singleton instance;

	private Singleton();

	public static syncronized Singleton getInstance() {
		if (instance == null) {
			syncronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```

> volatile
> - volatile로 선언된 변수가 있는 코드는 최적화 되지 않는다.
> - votatile 키워드는 변수를 main memory에 저장하겠다고 명시하는 것이다.
> - 변수의 값을 Read할 때마다 CPU cache에 저장된 값이 아닌, main memory에 읽는 것이다.
> https://ttl-blog.tistory.com/238


## Enum 클래스를 이용한 Singleton
enum으로 생성한 Singleton은 동기화, 클래스 로딩, 리플렉션, 직렬화 역직렬화 문제등을 해결할 수 있는 방법이다. (강추)

### Enum의 특징
- enum 타입은 기본적으로 직렬화 가능하므로 Serializable 인터페이스를 구현할 필요 없고 리플렉션 문제도 발생하지 않음
- 인스턴스가 JVM 내에 하나만 존재한다는 것이 100% 보장된다.
- 클래스처럼 메소드, 생성자 모두 가질 수 있다.
- 런타임시에 값이 설정되면 안되기 때문에 생성자는 private로 제한된다. (인스턴스 생성 불가능)

```java
public enum SingletonEnum {
    INSTANCE;
    int value;
    
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
```

```java
public class EnumDemo {
    
    public static void main(String[] args) {
        SingletonEnum singleton = SingletonEnum.INSTANCE;
        
        System.out.println(singleton.getValue());
        singleton.setValue(2);
    }
}
```