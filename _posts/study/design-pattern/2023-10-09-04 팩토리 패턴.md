---
title: 04.팩토리 패턴
categories:
- 디자인패턴
tags:
- design-pattern
- study
toc: true
toc_sticky: true
toc_label: Contents
---
> 객체의 인스턴스를 만드는 작업이 항상 공개되어야 하는 것은 아니다. 오히려 모든 것을 공개했다가다는 결합 문제가 생길 수 있다.
> 팩토리 패턴은 불필요한 의존성을 없애서 결합 문제를 해결하는 방법을 제공한다.

## new 를 이용한 객체 생성의 문제점
사실 "new" 자체에는 문제가 없지만, "변화"라는 것을 조심해서 new를 사용해야 한다.

인터페이스에 맞춰서 코드를 작성하면 시스템에서 일어날 수 있는 여러 변화에 대응할 수 있다. 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하기만 하면 된다. (다형성 덕분)  
반대로 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야 하므로 문제가 발생할 수 있다.

> 새로운 구상 형식을 써서 확장해야 할 때는 어떻게 해서든 다시 열 수 있게 해야 한다. (OCP)

---

> 팩토리(factory)란?
> 객체를 생성 처리하는 클래스를 의미한다. 

## 간단한 팩토리 (Simple Factory)
> 간단한 팩토리는 디자인 패턴이라기 보다, 프로그래밍에서 자주 쓰이는 관용구에 가깝다

간단한 팩토리는 객체를 생성하는 클래스를 따로 두는 방법을 의미한다.  

```java

/* Simple Pizza Factory class */
public class SimplePizzaFactory {

	public Pizza createPizza(String type) {
		Pizza pizza;
		// ... 생략 (객체 정의)
		return pizza;
	}
}

/* Concrete Pizza Class */
public class PizzaStore {

	SimplePizzaFactory factory;

	public PizzaStore(SimplePizzaFactory factory) {
		this.factory = factory;
	}

	public Pizza orderPizza(String type) {

		// 생성한 객체 전달받음 (생성은 팩토리)
		pizza = factory.createPizza(type);

		// ... 생략 (객체 메서드 실행)
		return pizza;
	}

}
```

---
## 팩토리 메소드 패턴
팩토리 메소드 패턴은 서브 클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화 한다.  
**즉, 객체를 생성하는 일을 서브클래스에서 결정하게 하는 패턴**

```java
/* 상위 class */
public abstract class PizzaStore {

	public Pizza orderPizza(String type) {
		Pizza pizza;
		
		pizza = createPizza(type);

		// ...생략 (객체 메서드 실행)
		return pizza;
	}

	// 객체 생성은 PizzaStore를 상속받는 서브 클래스에서 구현
	protected abstract Pizza createPizza(String type);
}

/* sub1 class */
public class SubPizzaStore1 extends PizzaStore {

	Pizza createPizza(String item) {
		// ... 생략 (객체 생성)
		return pizza
	}
}

/* sub2 class */
public class SubPizzaStore2 extends PizzaStore {

	Pizza createPizza(String item) {
		// ... 생략 (객체 생성)
		return pizza
	}
}
```

팩토리 메소드 패턴 (Factory Method Pattern)은 
- 객체를 생성할 때 필요한 인터페이스를 만든다.
- 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.
- 팩토리 메소드 패턴을 사용하면 클래스 인스턴스를 만드는 일은 서브클래스에게 맡기게 된다.
- 사용하는 서브클래스에 따라 생상되는 객체 인스턴스가 결정된다.

---

## 의존성 뒤집기 원칙 (Dependency Inversion Principle)
"추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다."  
즉, 고수준 구성 요소가 저수준 구성 요소에 의존하면 안되며, 항상 추상화에 의존하게 만들어야 한다.

### 의존성 뒤집기 원칙을 지키는 방법
- 변수에 구상 클래스의 레퍼런스를 저장하지 않는다.
- 구상 클래스에서 유도된 클래스를 만들지 않는다.
- 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 않는다.

> 의존성 뒤집기는 항상 지켜야하는 것은 아니며 지향하는 바를 나타내는 것이다.

---
## 추상 팩토리 패턴 (Abstract Factory Pattern)
구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스 제공하며, 구상클래스는 서브클래스에서 만든다.  
즉, **추상 팩토리 패턴은 하나의 팩토리에서 여러개의 제품군 조합을 생성할 수 있게 해주는 패턴이다.** (팩토리 메서드 패턴을 조금 더 캡슐화)

![](https://i.imgur.com/ZGtGGT1.png)


