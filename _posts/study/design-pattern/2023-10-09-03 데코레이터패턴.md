---
title: 03.데코레이터 패턴

categories:
- 디자인패턴

tags:
- design-pattern
- study

toc: true
toc_sticky: true
toc_label: Contents
---

> 객체 작성이라는 형식으로 실행 중에 클래스를 꾸미는 (데코레이션하는) 방법.
> 데코레이터 패턴은 기존 클래스 코드를 바꾸지 않고도 객체에 새로운 임무를 추가할 수 있다.

## OCP (Open-Closed Principle)
: 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하게 된다면, **새로운 기능을 추가할 때 급변하는 주변 환경에 잘 적응된 유연하고 튼튼한 디자인을 만들 수 있다.**

코드에서 확장해야 할 부분을 선택할 떄는 세심한 주의를 기울여야 하며, 무조건 OCP를 적용한다면 쓸데없는 일을 하며 시간을 낭비할 수 있다.

> 데코레이터 패턴은 이런 OCP를 준수하는 패턴중 하나이다.

## 예제의 문제점 살펴보기
: 다양한 음료를 포괄하는 주문 시스템 구축
### 1. 메뉴별로 가격을 지정하는 방법
![](https://i.imgur.com/TRjDSia.png)
- 고객이 주문할 때 다양한 조합으로 음료를 시킬 수 있다.
- 각각 추가할 때마다 커피 가격이 올라가야 하기에 주문 시스템을 구축할 때 고려해야함
### 2.  슈퍼 클래스(Beverage)에서 첨가물 가격을 계산하는 방법
![](https://i.imgur.com/Zc3W7jw.png)
- 첨가물 가격을 변경될때마다 기존 코드를 수정해야함
- 첨가물 종류가 달라지면 메소드 수정해야 하며, 동시에 슈퍼클래스의 cost()도 고쳐야 한다.

## 데코레이터 패턴 살펴보기
### 모카와 휘핑크림을 추가한 다크로스트 커피를 주문한 케이스

1. DarkRoast 객체를 가져옴
2. Mocha 객체를 장식
3. Whip 객체를 장식
4. cost() 메소드 호출 (첨가물 가격을 계산하는 일은 해당 객체에서 수행)
   ![](https://i.imgur.com/hwp4wZd.png)
- DarkRoast 객체 생성
- Mocha 객체 생성해서 DarkRoast를 감쌈
- Whip 데코레이터로 Mocha를 감쌈

![](https://i.imgur.com/GNVdMI6.png)
1. Whip의 cost() 메소드 호출
2. Whip은 Mocha의 cost() 메소드 호출
3. Mocha는 DarkRoast의 cost() 메소드 호출
4. DarkRoast 값 반환
5. Mocha는 DarkRoast에서 받은 값에서 mocha 값을 더해서 값 반환
6. Whip은 Mocha에서 받은 값에서 whip 값을 더해서 값 반환

### 지금까지 정리
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관없다
- 데코레이터는 자신이 장식하고 있는 객체에서 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다.
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다.

## 데코레이터 패턴의 정의

### 데코레이터 패턴
: 객체에 추가 요소를 동적으로 더할 수 있는 패턴. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
![](https://i.imgur.com/0lYgfwU.png)
- Component: 행동을 정의한 추상 클래스
- ConcreteComponent: Component를 구현한 클래스
- Decorator: 자신이 장식할 구성 요소와 같은 인터페이스 또는 추상 클래스를 구현한 클래스
- 각 데코레이터 안에는 Component 객체가 들어있다. (데코레이터에는 구성 요소의 레퍼런스를 포함한 인스턴스 변수가 있다)
- ConcreteDecorator: Decorator를 구현한 클래스
- 새로운 메소드를 추가할 수 있으나, 일반적으로는 추가하는 대신 Component에 원래 있던 메소드를 별도의 작업으로 처리해서 새로운 기능을 추가함

### 예제 다이어그램
![](https://i.imgur.com/wFhnY4I.png)

### 커피 주문 시스템 코드 만들기

*Baverage.class*
```java
public abstract class Beverage {
	String description = "제목 없음";

	public String getDescription() {
		return description;
	}

	public abstract double cost();
}
```

*CondimentDecorator.class*
```java
public abstract class CondimentDecorator extends Beverage {

	Beverage beverage;
	
	public abstract String getDescription();
}
```

*Espresso.class*
```java
public class Espresso extents Beverage {

	public Espresso() {
		description = "에스프레소";
	}

	public double cost() {
		return 1.99;
	}
}
```

*HouseBlend.class*
```java
public class HouseBlend extends Beverage {

	public HouseBlend() {
		description = "하우스 블렌드 커피";
	}

	public double cost() {
		return .89;
	}
}
```

*Mocha.class*
```java
public class Mocha extends CondimentDecorator {

	public Mocha(Beverage beverage) {
		this.beverage = beverage;
	}

	public String getDescription() {
		return beverage.getDescription() + "모카";
	}

	public double cost() {
		return beverage.cose() + .20;
	}
}
```

*Test.class*
```java
public class Test {

	public static void main(String args[]) {
		Beverage beverage = new Espresso();
		
		Beverage beverage2 = new DarkRoast();
		beverage2 = new Mocha(beverage2);
		beverage2 = new Mocha(beverage2);
		beverage2 = new Whip(beverage2);

		Beverage beverage = new HouseBlend();
		beverage3 = new Soy (beverage3);
		beverage3 = new Mocha(beverage3);
		beverage3 = new Whip(beverage3);
}
```


## 핵심 정리
- 디자인 유연성 면에서 상속으로 확장하는 일은 별로 좋은 선택이 아니다
- 기존 코드 수정 없이 행동을 확장해야하는 상황도 있다
- 구성과 위임으로 실행 중에 새로운 행동을 추가할 수 있다
- 상속 대신 데코레이터 패턴으로 행동을 확장할 수 있다.
- 데코레이터 패턴은 구상 구성요소를 감싸 주는 데코레이터를 사용한다.
- 데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영한다.
    - 상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가진다.
- 데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 확장한다.
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없다
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다
    - 클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외
- 데코레이터 패턴을 사용하면 자잘한 객체가 매우 많이 추가될 수 있고, 많이 사용하면 코드가 필요 이상으로 복잡해진다. (빌더 패턴으로 해결가능?)