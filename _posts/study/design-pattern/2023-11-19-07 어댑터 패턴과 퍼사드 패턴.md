---
title: 07.어댑터 패턴과 퍼사드 패턴
categories:
- 디자인패턴

tags:
- design-pattern
- study

toc: true
toc_sticky: true
toc_label: Contents
---

> **어댑터**
> 한 클래스의 인터페이스를 사용하고자 하는 다른 인터페이스로 변환시켜주는 역할

## 객체지향 어댑터
객체지향 어댑터는 클라이언트로부터 요청을 받아, 새로운 클래스를 클라이언트가 받아들일 수 있는 형태의 요청으로 변환해주는 중개인 역할을 한다.

`Duck` 인터페이스
```java
public interface Duck {
	public void quack();
	public void fly();
}
```

`MallardDuck` 클래스 (Duck 구현체)
```java
public class MallardDuck implements Duck{
	public void quack() {
		System.out.println("꽥");
	}

	public void fly() {
		System.out.println("날다");
	}
}
```

`Turkey` 인터페이스
```java
public interface Turkey {
	public void gobble();
	public void fly();
}
```

`WildTurkey` 클래스 (Turkey 구현체)
```java
public class WildTurkey implements Turkey {
	public void gobble() {
		System.out.println("골골");
	}

	public void fly() {
		System.out.println("짧게 날다");
	}
}
```

예제
```java
public static void main(String[] args) {
	// 오리 객체
	Duck duck = new MallardDuck();
	// 칠면조 객체
	Turkey turkey = new WildTurkey();
	// Turkey 객체를 감싼 어댑터 (Duck 객체 타입)
	Duck turkeyAdapter = new TurkeyAdapter(turkey);

	testDuck(turkeyAdapter);
}

static void testDuck(Duck duck) {
	duck.quack();
	duck.fly();
}
```


## 어댑터 패턴
어댑터 패턴은 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.
![](https://i.imgur.com/PIPGAdV.png)

### 클라이언트에서 어댑터를 사용하는 방법
1. 클라이언트에서 타깃 인터페이스로 메소드를 호출해서 어댑터에 요청을 보낸다
2. 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 메소드 호출로 변환한다.
3. 클라이언트는 호출 결과를 받긴 하지만 중간에 어댑터가 있다는 사실을 모른다.

> 클래스 어댑터
> 어댑터에는 두 종류가 있는데, 객체 어댑터와 클래스 어댑터이다. 그 중 클래스 어댑터를 사용하려면 다중 상속이 필요하지만 자바에서는 다중 상속이 불가능 하므로 책에서는 언급하지 않는다.
> ![](https://i.imgur.com/MdV4Wc1.png)

## Enumberation을 Iterator에 적용시키기
![](https://i.imgur.com/BqzeZQh.png)
- Iterator의 hasNext() ←→ Enumeration의 hasMoreElements()
- Iterator의 next() ←→ Enumeration의 nextElement()
- Iterator의 remove() ←→ Enumeration X

어댑터
```java
public class Enumeration implements Iterator<Object> {
	Enumeration<?> enumeration;

	public EnumerationIterator(Enumeration<?> enumeration) {
		this.enumeration = enumeration;
	}

	public boolean hasNext() {
		return enumeration.hasMoreElements();
	}

	public Object next() {
		return enumeration.nextElements();
	}

	public void remove() {
		throw new UnsuppoertedOperationException();
	}

}
```

---

## 퍼사드 패턴
퍼사드는 인터페이스를 단순하게 만들고 클라이언트와 구성 요소로 이루어진 서브시스템을 분리하는 역할을 한다.

**퍼사드 패턴**은 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어주며, 고수준 인터페이스도 정의하므로 서브시스템을 더 편리하게 사용할 수 있게 한다.

> 퍼사드와 어댑터는 둘 다 여러 개의 클래스를 감쌀 수 있으나, 퍼사드의 경우에는 인터페이스를 단순하게 하는 반면, 어댑터는 인터페이스를 다른 인터페이스로 변환하는 용도로 쓰인다.

![](https://i.imgur.com/GG8JBRt.png)

---

## 최소 지식 원칙 (Principle Of Least Knowledge)
시스템을 디자인할 때 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수와 상호작용 방식에 주의를 기울여야 한다.  
이 원칙은 여러 클래스가 복잡하게 얽혀 있어서, 시스템의 한 부분을 변경했을 때 다른 부분까지 줄줄이 고쳐야하는 상황을 미리 방지할 수 있다.

### 가이드라인
최소 지식 원칙은 친구를 만들지 않는 4개의 가이드라인을 제시한다.
- 객체 자체
- 메소드에 매개변수로 전달된 객체
- 메소드를 생성하거나 인스턴스를 만든 객체
- 객체에 속하는 구성 요소

최소 지식 원칙을 지키지 않는 경우
```java
public float getTemp() {
	Thermometer thermometer = station.getThermometer();
	return thermometer.getTemperature();
}
```

최소 지식 원칙을 지키는 경우
```java
public float getTemp() {
	return station.getTemperature();
}
```

