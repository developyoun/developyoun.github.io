---
title: 09.반복자 패턴과 컴포지트 패턴
categories:
- 디자인패턴
tags:
- design-pattern
- study
toc: true
toc_sticky: true
toc_label: Contents
---

## 반복자 패턴의 정의
**반복자 패턴(Iterator Pattern)** 은 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공한다.
- 집합체 내에서 어떤 식으로 일이 처리되는지 전혀 모르는 상태에서 안에 들어있는 모든 항목을 대상으로 반복작업이 가능하다
- 컬렉션 객체 안에 들어있는 모든 항목에 접근하는 방식이 통일될 수 있다.
	- 접근 방식 통일로 인해, 종류에 관계없이 모든 집합체에 사용할 수 있는 다형적인 코드를 만들 수 있다.
- 컬렉션 객체가 모든 항목에 일일이 접근하지 않고 반복자 객체가 이를 수행하게 할 수 있다.
	- 이로 인해 집합체의 인터페이스와 구현이 간단해지며 객체 컬렉션은 자신의 일만 수행하게 할 수 있다.

## 반복자 패턴의 구조
![](https://i.imgur.com/1s0x6sR.png)

- `Aggregate`: ConcreteIterator 객체를 반환하는 인터페이스
- `ConcreteAggregate`: 여러 요소들이 이루어져 있는 데이터 집합체
- `Iterator`: 집합체 내의 요소들을 순서대로 검색하기 위한 인터페이스
- `ConcreteIterator`: 반복자 객체

## 반복자 패턴 예제

### AS-IS
**List class**
```java
public class ListClass {
	List<Item> items;

	public ListClass() {
		items = new ArrayList<Item>();
		// 생략... (addItem 메서드 호출)
	}

	public void addItem(파라미터) {
		Item item = new Item(...);
		items.add(item);
	}

	public ArrayList<Item> getItems() {
		return items;
	}

}
```

**Array Class**
```java
public class ArrayClass {
	static final int MAX_ITEMS = 6;
	int numOfItems = 0;
	Item[] items;

	public ArrayClass() {
		items = new Item[MAX_ITEMS];
		// 생략... (addItem 메서드 호출)
	}

	public void addItem(파라미터) {
		Item item = new Item(...);
		items[numOfItems] = item;
		numOfItems += 1
	}

	public Item[] getItems() {
		return items;
	}

}
```

**Print class**
```java
public class PrintClass {

	listClass listClass;
	ArrayClass arrayClass;

	public PrintClass(ListClass listClass, ArrayClass arrayClass) {
		this.listClass = listClass
		this.arrayClass = arrayClass;
	}

	public void printItems() {
		ArrayList<Item> listItems = listItems = listClass.getItems();;
		Item[] arrayItems = arrayItems = arrayClass.getItems();;

		for (int i=0; i < listItems.size(); i++) {
			// 생략
		}

		for (int i=0; i < arrayItems.length; i++) {
			// 생략
		}
	}
	
}
```
List 클래스 및 Array 클래스는 동일한 메서드명을 사용하고 있지만 다른 리턴 형식으로 인해 문제가 발생한다.  
만약, 위와 같이 다른 리턴 형식을 함께 쓰려면 클래스 개수만큼 중복된 코드가 필요해질 수 있다.


### TO-BE

**Iterator 인터페이스**
```java
public interface Iterator() {
	boolean hasNext();
	Item next();
}
```

**List 반복자 클래스**
```java
public class ListIterator implements Iterator {

	public Item next() {
		// 생략
	}

	public boolean hasNext() {
		// 생략
	}

}
```

**List Class**
```java
public class ListClass {
	List<Item> items;

	public ListClass() {
		items = new ArrayList<Item>();
		// 생략... (addItem 메서드 호출)
	}

	public void addItem(파라미터) {
		Item item = new Item(...);
		items.add(item);
	}

	// getItems 제거 && createIterator 생성
	public Iterator createIterator() {
		return new ListIterator(items);
	}

}
```

**Array 반복자 클래스**
```java
public class ArrayIterator implements Iterator {

	public Item next() {
		// 생략
	}

	public boolean hasNext() {
		// 생략
	}

}
```

**Array Class**
```java
public class ArrayClass {
	static final int MAX_ITEMS = 6;
	int numOfItems = 0;
	Item[] items;

	public ArrayClass() {
		items = new Item[MAX_ITEMS];
		// 생략... (addItem 메서드 호출)
	}

	public void addItem(파라미터) {
		Item item = new Item(...);
		items[numOfItems] = item;
		numOfItems += 1
	}

	// getItems 제거 && createIterator 생성
	public Iterator createIterator() {
		return new ArrayIterator(items);
	}

}
```

**Print class**
```java
public class PrintClass {

	listClass listClass;
	ArrayClass arrayClass;

	public PrintClass(ListClass listClass, ArrayClass arrayClass) {
		this.listClass = listClass
		this.arrayClass = arrayClass;
	}

	public void printItems() {
		ArrayList<Item> listIterator = listItems = listClass.createIterator();
		Item[] arrayItems = arrayIterator = arrayClass.createIterator();

		printItems(listIterator);
		printItems(arrayIterator);
	}

	private void printItems(Iterator iterator) {
		while (iterator.hasNext()) {
			// 생략
		}
	}
	
}
```


```ad-note
## 단일 역할 원칙
**어떤 클래스가 바뀌는 이유는 하나뿐이어야 한다.**
- 클래스를 고치는 일은 최대한 피해야 한다
- 하나의 역할은 하나의 클래스에서만 맡아야 한다.
- 역할이 2개 이상이라면 바뀔 수 있는 부분도 2개 이상이다.
```

## 컴포지트 패턴
객체를 트리구조로 구성해서 부분-객체 계층구조로 구현하는 패턴. 컴포지트 패턴을 사용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있다.
- 부분-전체 계층 구조란, 부분들이 계층을 이루고 있지만 모든 부분을 묶어서 전체로 다룰 수 있는 구조를 말한다.
- 트리구조는 각각의 개별 객체들이 모두 복합 객체가 될 수 있다
- 컴포지트 패턴을 적용한 디자인은 간단한 코드만 가지고도 똑같은 작업을 전체 메뉴 구조를 대상으로 반복해서 적용할 수 있다.

![](https://i.imgur.com/JrGbMh4.png)


![](https://i.imgur.com/Mvb0hKz.png)

