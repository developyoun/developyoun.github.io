---
title: 02. 옵저버 패턴

categories:
- 디자인패턴

tags:
- design-pattern
- study

toc: true
toc_sticky: true
toc_label: Contents
---

> 뭔가 중요한 일이 일어났을 때 객체에게 새 소식을 알려줄 수 있는 패턴

## 옵저버 패턴 이해하기
1. 신문사가 사업을 시작하고 신문을 찍어냄
2. 신문사에 구독을 신청하면 구독을 해지하기 전까지 새로운 신문이 나올 때마다 배달을 받음
3. 신문을 더 이상 보고 싶지 않으면 구독을 해제함
4. 신문사가 망하지 않는 이상 꾸준하게 신문을 구독하거나 해지

**신문사 + 구독자 = 옵저버 패턴**

- 주제
    - 주제에서 중요한 데이터를 관리
    - 주제 데이터가 변경되면 옵저버에게 소식 전달
    - 데이터가 바뀌면 새로운 데이터 값이 어떤 방법으로든 옵저버에게 전달
- 옵저버
    - 옵저버 객체들은 주제를 구독 (주제 객체에 등록)
    - 주제 데이터가 바뀌면 갱신 내용을 전달 받음
    - 옵저버가 아닌 객체는 주제 데이터가 바뀌어도 연락받지 못함

## 옵저버 패턴의 정의
**옵저버 패턴(Observer Pattern)** 은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고, 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.

주제와 옵저버로 일대다 관계가 정의된다. 옵저버는 주제 딸려 있으며 주제의 상태가 바뀌면 옵저버에게 정보가 전달됨.  
옵저버 패턴은 여러 가지 방법으로 구현할 수 있지만, 보통은 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현한다.

## 옵저버 패턴의 구조
![](https://i.imgur.com/AGHIYJx.png)
- Subject 인터페이스
    - 객체에서 옵저버로 등록하거나 옵저버 목록에서 탈퇴하고 싶을 때 이 인터페이스에 있는 메소드를 사용
- Observer 인터페이스
    - 옵저버가 될 가능성이 있는 객체는 반드시 Observer 인터페이스를 구현해야 한다.
    - 이 인터페이스에서는 주제의 상태가 바뀌었을 때 호출되는 update() 메소드밖에 없다.
- Subject 구현체
    - 주제 역할을 하는 구상 클래스에서는 항상 Subject 인터페이스를 구현해야 한다.
    - 주제 클래스에는 등록 및 해지용 메소드와 상태가 바뀔 때마다 모든 옵저버에게 연락하는 notifyObserver() 메소드도 구현해야 한다.
    - 주제 클래스에는 상태를 설정하고 알아내는 getter/setter 메소드가 들어있을 수 있다.
- Observer 구현체
    - Observer 인터페이스만 구현한다면 무엇이든 옵저버 클래스가 될 수 있다.
    - 각 옵저버는 특정 주제에 등록해서 연락받을 수 있다.

## 느슨한 결합의 위력

**느슨한 결합(Loose Coupling)** 은 객체들이 상호작용할 수 있지만, 서로를 잘 모르는 관계를 의미한다.  
느슨한 결합을 활용하면 유연성이 아주 좋아지며 옵저버 패턴은 느슨한 결합을 보여주는 훌륭한 예이다.
- **주제는 옵저버가 특정 인터페이스(Observer 인터페이스)를 구현한다는 사실만 안다.**
    - 옵저버의 구상 클래스가 무엇인지, 옵저버가 무엇을 하는지는 알 필요도 없다
- **옵저버는 언제든지 새로 추가할 수 있다.**
    - 주제는 Observer 인터페이스를 구현하는 객체의 목록에만 의존하므로 언제든지 새로운 옵저버를 추가할 수 있다.
    - 실행 중에 하나의 옵저버를 다른 옵저버로 바꿔도 주제는 계속해서 다른 옵저버에 데이터를 보낼 수 있다. (제거도 마찬가지)
- **새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없다.**
    - 옵저버가 되어야 하는 새로운 구상 클래스가 생겨도 새로운 클래스 형식을 받아들일 수 있도록 주제를 바꿔야 할 필요는 없다.
    - 단지 새로운 클래스에서 Observer 인터페이스를 구현하고 옵저버로 등록하기만 하면 된다.
- **주제와 옵저버는 서로 독립적으로 재사용할 수 있다.**
    - 주제나 옵저버를 다른 용도로 활용한다고 해도 손쉽게 재사용할 수 있다.
    - 그 이유는 둘이 서로 단단하게 결합되있지 않기 때문이다.
- **주제나 옵저버가 달라져도 서로에게 영향을 미치지는 않는다.**
    - 서로 느슨하게 결합되어 있으므로 주제나 옵저버 인터페이스를 구현한다는 조건만 만족하면 어떻게 고쳐도 문제가 없다.

> **디자인 원칙**
> 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.

## 옵저버 패턴 예제

*인터페이스*
```java
public interface Subject {
	// 옵저버 등록
	public void registerObserver(Observer o);
	// 옵저버 해제
	public void removeObserver(Observer o);
	// 옵저버 알림
	public void notifyObserver();
}

public interface Observer {
	// 모든 옵저버는 Observer 인터페이스를 구현해야한다. (즉, 모든 옵저버에서 update를 구현해야 함)
	public void update(float temp, float humidity, float presure);
}

public interface DisplayElement {
	// 디스플레이 항목을 화면에 표시할 때 호출되는 메서드
	public void display();
}
```

*클래스 구현체*
```java
public class WeatherData implements Subject {
	// 옵저버 객체들을 저장하는 리스트
	private List<Observer> observers;
	private float temperature;
	private float humidity;
	private float pressure;

	public WeatherData() {
		// 생성자로 옵저버 리스트 객체를 생성
		observers = new ArrayList<Observer>();
	}

	public void registerObserver(Observer o) {
		// 옵저버 등록 구현
		observers.add(o);
	}

	public void removeObserver(Observer o) {
		// 옵저버 해제 구현
		observers.remove(o);
	}

	public void notifyObservers() {
		// 모든 옵저버에게 상태 변화를 알려줌
		for (Observer observer: observers) {
			observer.update(temperature, humidity, pressure);
		}
	}

	public void measurementsChanged() {
		// 갱신된 측정값을 받으면 옵저버들에게 알림
		notifyObservers();
	}

	public void setMeasurements(float temperature, float humidity, float pressure) {
		this.temperature = temperature;
		this.humidity = humidity;
		this.pressure = pressure;
		measurementsChanged();
	}

	// ....
}
```

*디스플레이 요소 구현체*
```java
public class CurrentConditionsDisplay implements Observer, DisplayElement{  
    private float temperature;  
    private float humidity;  
    private WeatherData weatherData;  
  
    public CurrentConditionsDisplay(WeatherData weatherData) {  
        this.weatherData = weatherData;  
        weatherData.registerObserver(this);  
    }  
    
    public void update(float temperature, float humidity, float pressure) {  
        this.temperature = temperature;  
        this.humidity = humidity;  
        display();  
    }  
    
    public void display() {  
        System.out.println("현재 상태: 온도 " + temperature + "F, 습도 " + humidity + "%");  
    }
}
```

*테스트*
```java
public static void main(String[] args) {  
	WeatherData weatherData = new WeatherData();  
	CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);  
  
	weatherData.setMeasurements(80, 65, 30.4f);  
	weatherData.setMeasurements(82, 70, 32.2f);  
	weatherData.setMeasurements(44, 12, 22.2f);  
}
```

> 자바에는 옵저버 패턴용 `Observable` 클래스와 `Oberser` 인터페이스가 있었고, 이를 통해 직접 코드를 작성하지 않아도 옵저버를 추가 및 삭제, 알림까지 보내는 메서드를 제공했음. 그러나 각자 자신의 코드에서 기본적인 옵저버 패턴을 사용하는게 낫다고 생각하면서 자바 9 이후로 사용하지 않음

> 옵저버의 알림 순서에 의존하지 않는 것이 권고 사항임

---

## 풀 방식으로 코드 바꾸기

> 주제가 옵저버로 데이터를 보내는 푸시(Push)를 사용하거나 옵저버가 주제로부터 데이터를 당겨오는 풀(Pull) 방식 중 어느 하나를 선택하는 일은 구현 방법의 문제라고 볼 수 있다.  
> 하지만 대체로 "옵저버가 필요한 데이터를 골라서 가져가도록 만드는 방식"이 더 좋다

`WeatherData.class`
```java
public void notifyObservers {
	for (Observer observer: observers) {
		// 기존 인자 제거
		observer.update();
	}
}
```

`Observer.interface`
```java
public interface Observer {
	// 기존 인자 제거
	public void update();
}
```

`CurrentConditionsDisplay.class`
```java
public void update() {
	// 주제의 getter 메서드 사용
	this.temperature = weatherData.getTemperature();
	this.humidity = weatherData.getHumidity();
	display();
}
```

---

## 정리
- 옵저버 패턴은 객체들 사이에 일대다 관계를 정의
- 주제는 동일한 인터페이스를 써서 옵저버에게 연락
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있다
- 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모른다
    - 이들 사이의 결합은 느슨한 결합이다
- 옵저버 패턴을 사용하면 주제가 데이터를 보내거나(푸시 방식) 옵저버가 데이터를 가져올(풀 방식) 수 있다.
    - 일반적으로 풀 방식이 더 옳은 방식이라고 간주한다
- 스윙은 다른 GUI 프레임워크와 마찬가지로 옵저버 패턴을 많이 사용한다
- 다른 언어의 프레임워크에서도 옵저버 패턴을 많이 사용한다
- 옵저버 패턴은 여러 개의 주제와 메시지 유형이 있는 복잡한 상황에서 사용하는 출판-구독 패턴과 친척이다
- 옵저버 패턴은 자주 쓰이는 패턴으로 모델-뷰-컨트롤러 (MVC)에서 다시 만날 수 있다.

---

## 옵저버 패턴의 특징

### 사용
- 앱이 한정된 시간, 특정한 케이스에만 다른 객체를 관찰해야 하는 경우
- 대상 객체의 상태가 변경될 때마다 다른 객체의 동작을 트리거 할 때
- 한 객체의 상태가 변경되면서, 다른 객체도 변경해야 할 때
    - 여기서 어떤 객체들이 변경되어야 하는지 몰라도 될 때
- MVC 패턴에서도 사용됨
    - Model과 View의 관계는 옵저버 패턴의 Subject 역할과 Observer 역할과 대응된다.
    - 하나의 Model에 다수의 View가 대응한다

### 장점
- 주제의 상태 변경을 주기적으로 조회하지 않고 자동으로 감지할 수 있다.
- 발행자의 코드를 변경하지 않고도 새 구독자 클래스를 도입할 수 있어, 개방 폐쇄 원칙(OCP) 준수
- 런타임 시점에서 발행자와 구독 알림 관계를 맺을 수 있다
- 상태를 변경하는 객체(Subject)와 변경을 감지하는 객체(Observer)의 관계를 느슨하게 유지할 수 있다. (느근한 결합)

### 단점
- 구독자는 알림 순서를 제어할 수 없고, 무작위 순서로 알림을 받음
    - 하드 코딩으로 구현할 수 있지만 복잡성과 결합성이 높아지기 때문에 추천되지 않음
- 옵저버 패턴을 자주 사용하면 구조와 동작을 알아보기 힘들어져 코드 복잡도가 증가함
- 다수의 옵저버 객체를 등록 이후 해지하지 않는다면 메모리 누수가 발생할 수 있음

> [참조 링크](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%98%B5%EC%A0%80%EB%B2%84Observer-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)
