---
title: 11. 프록시 패턴
categories:
- 디자인패턴
tags:
- design-pattern
- study
toc: true
toc_sticky: true
toc_label: Contents
---

## 프록시 패턴의 정의
***프록시 패턴(Proxy Pattern)*** 은 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공한다.  
프록시 패턴을 사용하면 원격 객체, 생성하기 힘든 객체, 보안이 중요한 객체와 같은 다른 객체로의 접근을 제어하는 객체를 만들 수 있다. 

![](https://i.imgur.com/QbqXEEU.jpg)
- *Subject* 
	- RealSubject와 Proxy를 같은 인터페이스로 묶기 위한 인터페이스
- *RealSubject*
	- 실제 작업을 처리하는 객체
- *Proxy*
	- RealSubject로의 접근을 제어하는 역할

```ad-note
*Good*
- 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조할 수 있다.
- 실체 객체의 메소드를 숨기고 인터페이스를 통해노출 가능하다
- 원격 객체를 사용할 수 있다.
- 원래 객체에 대한 접근을 제어할 수 있다.

*Bad*
- 객체 생성시 단계가 추가되므로 빈번한 객체 생성이 필요한 경우 성능 저하 가능성이 있다.
- 프록시 내부에서 객체 생성을 위해 스레드 생성, 동기화가 구현되는 경우 성능이 저하될 수 있다.
- 로직이 난해해져서 가독성이 떨어질 수 있다.
```

---
## 프록시 패턴의 종류

### 1. 원격 프록시 (Remote Proxy)
원격 프록시는 다른 주소 공간에서 돌아가고 있는 객체(원격 객체)의 로컬 대변자의 역할을 한다.
> *로컬 대변자 (Local Representative)*
> 어떤 메소드를 호출하면 다른 원격 객체한테 그 메소드 호출을 전달하주는 역할을 하는 객체

![](https://i.imgur.com/tZyc2YJ.png)

- 클라이언트 객체(Client Object)는 진짜 서비스의 메소드를 호출한다고 생각한다. 클라이언트 보조 객체에서 실제로 자신이 원하는 작업을 처리한다고 생각한다.
- 클라이언트 보조 객체(Client Helper)는 진짜 서비스인 척 하지만, 실제로는 진짜 객체에 대한 프록시이다.
- 서비스 보조 객체 (Service Helper)는 클라이언트 보조 객체로부터 요청을 받아 그 내용을 해석하여 진짜 서비스에 있는 메소드를 호출한다.
- 서비스 객체(Service Object)는 진짜 서비스이다. 실제로 작업을 처리하는 메소드가 들어있다.
#### 1-1. Remote Method Invocation, 원격 메소드 호출)
RMI는 자바 진영에서, 원격 프록시를 구현하게 해준다.
> 기본적으로, 다른 힙에 위치한 객체에 대한 레퍼런스를 가져올 수는 없지만, 어떤 변수가 어떤 객체를 참조하려면 그 객체는 그 선언문이 들어있는 코드와 같은 힙 공간에 위치해야만 한다.
> RMI를 이용하면 원격 JVM에 있는 객체를 찾아서 그 메소드를 호출할 수 있다.

```ad-note
클라이언트 보조 객체는 스텁(stub) 이라고 하고, 서비스 보조 객체는 스켈레톤(skeleton)이라고 부른다.
```
![](https://i.imgur.com/6LYVomj.jpg)
- RMI에서는 클라이언트 보조객체와 서비스 보조객체를 만들어준다.
	- 보조 객체는 원격 서비스와 똑같은 메소드가 들어있다.
- 클라이언트에서 원격 객체를 찾아서 그 원격 객체에 접근하기 위해 쓸 수 있는 룩업(look up) 서비스도 제공한다.
- 클라이언트 입장에서는 로컬 메소드 호출과 같은 방식으로 메소드를 호출하지만, 실제로는 클라이언트 보조객체에서 네트워크를 통해 호출을 전송할 수 있다.

### 2. 보호 프록시 (Protection Proxy)
접근권한을 바탕으로 객체에 대한 접근을 제어하는 프록시.  
실제 프록시 클래스는 컴파일 시점이 아닌 런타임 중에 생성되기 때문에 **동적 프록시(*Dynamic Proxy* )** 라고도 부른다.
```java
class Proxy implements ISubject {
    private RealSubject subject; // 대상 객체를 composition
    boolean access; // 접근 권한

    Proxy(RealSubject subject, boolean access) {
        this.subject = subject;
        this.access = access;
    }

    public void action() {
        if(access) {
            subject.action(); // 위임
            /* do something */
            System.out.println("프록시 객체 액션 !!");
        }
    }
}

class Client {
    public static void main(String[] args) {
        ISubject sub = new Proxy(new RealSubject(), false);
        sub.action();
    }
}
```
- 프록시 객체를 통해 클라리언트 자격 증명이 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있게 한다.

### 3. 가상 프록시 (Vitual Proxy)
생성하는데 많은 비용이 드는 객체를 대신하는 프록시.  
진짜 객체가 필요한 상황이 오기 전까지 객체의 생성을 미루는 기능을 제공한다.
```java
class Proxy implements ISubject {
    private RealSubject subject; // 대상 객체를 composition

    Proxy() {
    }

    public void action() {
    	// 프록시 객체는 실제 요청(action(메소드 호출)이 들어 왔을 때 실제 객체를 생성한다.
        if(subject == null){
            subject = new RealSubject();
        }
        subject.action(); // 위임
        /* do something */
        System.out.println("프록시 객체 액션 !!");
    }
}

class Client {
    public static void main(String[] args) {
        ISubject sub = new Proxy();
        sub.action();
    }
}
```
- 서비스가 시작될 때 객체를 생성하는 대신, 객체 초기화가 실제로 필요한 시점에 초기화 될 수 있도록 지연할 수 있다.

### 4. 기타 프록시
#### 4-1. 방화벽 프록시 (Firewall Proxy)
일련의 네트워크 자원으로의 접근을 제어함으로써 '나쁜' 클라이언트로부터 보호한다.
#### 4-2. 스마트 레퍼런스 프록시 (Smart Reference Proxy)
객체가 참조될 때마다 추가 행동을 제공한다.
#### 4-3. 캐싱 프록시 (Caching Proxy)
비용이 많이 드는 작업의 결과를 임시로 저장한다.  
여러 클라이언트에서 결과를 공유하게 해 줌으로써 계산 시간과 네트워크 지연을 줄여주는 효과가 있다.
#### 4-4. 동기화 프록시 (Syschronization Proxy)
여러 스레드에서 객체에 접근할 때 안전하게 작업을 처리할 수 있게 해준다.
#### 4-5. 복잡도 숨김 프록시 (Complexity Hiding Proxy)
복잡한 클래스 집합으로서의 접근을 제어하고, 그 복잡도를 숨겨준다.  
퍼사드 프록시(Facade Proxy)라고 부르기도 한다.
> 프록시는 접근을 제어하지만, 퍼사드 패턴은 대체 인터페이스만 제공한다

#### 4-6. 지연 복사 프록시 (Copy-On-Write Proxy)
클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어한다. (변형된 가상 프록시)

```ad-note
모든 변경된 프록시의 공통점은, 클라이언트가 실제 객체의 메소드를 호출하면 그 호출을 중간에 가로챈다는 점이다.
```

