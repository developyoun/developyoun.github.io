---
title: 3.1 쿠버네티스 이해하기

categories:
- 쿠버네티스/도커

tags:
- kubenetes
- docker

toc: true
toc_sticky: true
toc_label: Contents
---

> 컨테이너 인프라 환경❔
>
> * 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경이다.
> * 컨테이너란 하나 이상의 목적을 위해 독립적으로 작동하는 프로세스이다.
> * 컨테이너 인프라 환경을 구축하면, 여러 사람이 만져서 설정의 일관성이 떨어진 서버(일명, 눈송이 서버)를 방지하는데 효과적이다.

> 가상화 환경
>
> * 각각의 가상 머신이 모두 독립적인 운영 체제 커널을 가지고 있어야 한다.
> * 그만큼, 자원을 더 소모하고 성능이 떨어진다.
> * 기존에는 가상화 환경에서 상용 솔루션(VMware)를 이용해 안정적으로 시스템을 운용했었지만, 애플리케이션의 복잡도가 늘어나면서 부족함이 드러났다.

> 컨테이너 오케스트레이션❔
>
> **오케스트레이션** 이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것.
>
> **컨테이너 오케스트레이션** 은 다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어준다.

**3.1.1 왜 쿠버네티스일까**

컨테이너 오케스트레이션을 제공하는 대표적인 솔루션은 4가지가 있다.

* **도커 스웜(Docker Swarm)**
    * 설치가 간단하며 사용하기 용이하다.
    * 그만큼 기능이 다양하지 않아 대규모 환경에 부적합(그러나, 사용자 환경을 변경하여 적용할 수 있다)
    * 즉, 소규모 환경에서는 유용하나 대규모 환경에서는 잘 사용하지 않는다.
* **메소스(Mesos)**
    * 아파치 재단의 역사와 전통이 있는 오픈소스 프로젝트의 클러스터 도구이다. (트위터, 에어비앤비, 애플, 우버 등 다양한 곳에서 검증됨)
    * 2016년 DC/OS의 지원으로 매우 간결해졌다.
    * 기능을 충분히 활용하기 위해선 분산 관리 시스템과 연동해야 한다. → 여러가지 솔루션을 유기적으로 구성해야하는 부담이 존재한다.
* **노매드(Nomad)**
    * 베이그런트를 만든 해시코프사의 컨테이너 오케스트레이션이며 간단한 구성으로 환경을 제공한다.
    * 기능이 부족하여, 복잡하게 여러 기능을 사용하는 환경이 아닌 가볍고 간단한 기능만 필요한 환경에서 사용하기를 권장한다.
    * 해시코프의 Consul(서비스 검색), Vault(암호화 저장소)와의 연동이 원할하므로 이런 도구에 대한 성숙도가 있는 조직에선 고려해볼만 하다.
* **쿠버네티스(Kubenetes)**
    * 쉽게 사용할 수 있도록 도와주는 도구들이 있어서 설치가 쉬워지는 추세
    * 다양한 형태의 쿠버네티스가 지속적으로 계속 발전되고 있어서 컨테이너 오케스트레이션을 넘어 IT인프라 자체를 컨테이너화 하며 인프라 제품군을 쿠버네티스 위에서 동작할 수 있게 만든다.
    * 거의 모든 벤더와 오픈소스 진영 모두에서 쿠버네티스를 지원하고 그에 맞게 개발되고 있는 중이다.
    * 그렇기에 만약, 컨테이너 오케스트레이션을 학습하거나 도입하려고 한다면 우선적으로 고려해야 한다.

> DC/OS (Data Center OS)
>
> 대규모 서버 환경에서 자원을 유연하게 공유하며 하나의 자원처럼 관리하는 도구

| 구분       | 도커 스웜   | 메소스    | 노매드   | 쿠버네티스   |
| -------- | ------- | ------ | ----- | ------- |
| 설치 난이도   | 쉬움      | 매우 어려움 | 쉬움    | 어려움     |
| 사용 편의성   | 매우 좋음   | 좋음     | 매우 좋음 | 좋음      |
| 세부 설정 지원 | 거의 없음   | 있음     | 거의 없음 | 다양하게 있음 |
| 안정성      | 매우 안정적임 | 안정적임   | 안정적임  | 매우 안정적임 |
| 확장성      | 어려움     | 매우 잘 됨 | 어려움   | 매우 잘 됨  |
| 정보량      | 많음      | 적음     | 적음    | 매우 많음   |
| 에코 파트너   | 없음      | 거의 없음  | 있음    | 매우 많음   |
| 학습 곡선    | 쉬움      | 매우 어려움 | 어려움   | 어려움     |

***

#### 3.1.2 쿠버네티스 구성 방법

**1** . 퍼블릭 클라우드 업체에서 제공하는 관리형 쿠버네티스

* EKS (Amazon Elastic Kubenetes), AKS(Azure Kubenetes Services), GKE(Google Kubenetes Engine)
* 구성이 이미 다 갖춰서 있으며, 마스터 노드를 클라우드 업체에서 관리한다. (학습용으론 비추)

**2** . 플랫폼에서 제공하는 설치형 쿠버네티스

* 수세의 Rancher, 레드햇의 OpenShift
* 유료이기에 접근하기 어렵다.

**3** . 쿠버네티스 클러스터를 자동으로 구성해주는 솔루션 (구성형 쿠버네티스)

* Kubeadm, kops(Kubenetes Operations), KRIB(Kubenetes Rebar Integrated Bootstrap), kubespray
* 위 4가지 중, kubeadm이 가장 널리 알려져 있으며 사용자가 변경하기도 수월하고 온프레미스와 클라우드를 모두 지원하며 배우기 쉽다.

***

#### 3.1.3 쿠버네티스 구성하기

추후 작성...

***

#### 3.1.4 파드 배포를 중심으로 쿠버네티스 구성 요소 살펴보기

> 쿠버네티스 구성 요소의 이름 생성 규칙
>
> * 쿠버네티스의 구성 요소는 동시에 여러 개가 존재하는 경우 중복된 이름을 피하고자 뒤에 해시코드가 삽입된다.
> * 이떼, 해시 코드는 무작위 문자열로 생성된다. (ex. Kube-proxy-34lkj, kube-proxy-mlk77)
> * 구성 요소의 이름을 직접 지정할 수도 있지만, 구성 요소는 언제라도 문제를 발견하면 다시 생성되는 특성을 가지는 파드로 이루어져 있어서 자동으로 이름을 지정하는 것이 관리하기 쉽다.

> Calico
>
> calico란 컨테이너, 가상 머신 및 기본 호스트 기반 워크로드를 위한 오픈 소스 네트워킹 및 네트워크 보안 솔루션

#### ✅ 관리자나 개발자가 파드를 배포할 때

**마스터 노드**

* `kubectl`
    * 쿠버네티스 클러스터에 명령을 내리는 역할을 맡음
    * 다른 구성 요고들과 다르게 바로 실행되는 명령 형태인 바이너리로 배포된다.
        * 그렇기에 꼭 마스터 노드에 있을 필요는 없다.
        * 그러나, 통상적으로 API 서버와 주로 통신하므로 API 서버가 마스터 노드에 위치한다면 마스터 노드에 구성하는 것이 좋다.
* `API 서버`
    * 쿠버네티스 클러스터의 중심 역할을 하는 통로
    * 주로 상태 값을 저장하는 etcd와 통신
        * 그러나, 그 밖의 요소들과도 통신하므로 API서버의 역할은 중요하다.
* `etcd`
    * 구성 요소들의 상태 값이 모두 저장되는 곳.
    * 실제로 etcd외의 다른 구성 요소는 상태 값을 관리하지 않는다.
        * etcd의 정보만 백업되어 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스터는 복구가 가능
    * etcd는 분산 저장이 가능한 key-value 저장소이기에, 복제하여 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있음

> etcd
>
> etcd는 리눅스의 구성 정보를 주로 가지고 있는 etc 디렉토리와 distributed(퍼뜨렸다)의 합성어.
>
> 즉, etcd는 구성 정보를 퍼뜨려 저장하겠다는 의미.

* `컨트롤러 매니저`
    * 쿠버네티스 클러스터의 오브젝트 상태를 관리
    * 워커 노드에서 통신이 되지 않는 경우에, 상태 체크와 복구는 컨트롤러 매니저에 속판 노트 컨트롤러에서 이루어 진다.
    * 다양한 상태 값을 관리하는 주체들이 컨트롤러 매니저에 소속되어 각자의 역할을 수행한다.
* `스케줄러`
    * 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지 결정하고 할당한다.
    * 파트를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리하는 역할을 담당.

**워커 노드**

* `kubelet`
    * 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달
    * 이 파드 안의 컨테이너들이 정상적으로 작동하는 모니터링
* `컨테이너 런타임`
    * CRI, Container Runtime Interface
    * 파드를 이루는 컨테이너의 실행을 담당
    * 파드 안에서 다양한 종류의 컨테이너가 문제없이 작동하게 만드는 표준 인터페이스
* `파드(Pod)`
    * 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위
        * 즉, 웹서버 역할과 로그나 데이터 분석도 가능
    * 파드는 **언제라도 죽을 수 있는 존재**
        * 가상머신은 언제라도 죽을 수 있다고 가정하고 디자인하지 않는다.
        * 그러나 파드는 언제라도 죽을 수 있다 가정하고 설계되었다.

**선택 가능한 요소**

이 선택 가능한 요소는 깊은 내용이라, 이런 요소가 있다는 정도만 알면 된다.

* 네트워크 플러그인
    * 쿠버네티스 클러스터의 통신을 위해서 네트워크 플러그인을 선택하고 구성해야 하는데, 이 네트워크 플러그인은 일반적은 CNI로 구성한다.
    * 주로 사용하는 CNI는 캘리고, 플래널, 실리움, 큐브 라우터, 노마나, 위브넷, Canal이 있다.
* CoreDNS
    * 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS 서버이다.
    * 쿠버네티스 클러스터에서 도메인 이름을 이용해 통신하는 데 사용.
    * 실무에서 쿠버네티스 클러스터를 구성하여 사용할 때는 IP보다 도메인 네임을 편리하게 관리해주는 CoreDNS를 사용하는 것이 일반적.

> CNI (Container Network Interface)
>
> 컨테이너 네트워크 인터페이스는 클라우드 네이티브 컴퓨팅 재단의 프로젝트로, 컨테이너의 네트워크 안정성과 확장성을 보장하기 위해 개발 되었다.
>
> CNI에 사용할 수 있는 네트워크 플러그인은 다양한데, 구성 방식과 지원하는 기능, 성능이 각기 다르므로 사용 목적에 맞게 선택하면 된다.

#### ✅ 사용자가 배포된 파드에 접속할 때

* `kube-proxy`
    * 쿠버네티스 클러스터는 파드가 위한 노드에 kube-proxy를 통해 파드가 통신할 수 있는 네트워크를 설정한다.
        * 실제 통신은 br\_netfilter와 iptables로 관리
* `파드`
    * 이미 배포된 파드에 접속하고 필요한 내용을 전달 받는다.
    * 대부분 사용자는 파드가 어느 워커 노드에 위치하는지 신경쓰지 않아도 된다.

***

#### 3.1.5 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기

**파드의 생명주기**

<figure><img src="https://thebook.io/img/080241/100.jpg" alt=""><figcaption></figcaption></figure>

1. (M) kubectl을 통해 API 서버에 파드 생성을 요청
2. (M) 업데이트가 있을 때마다 매번 API 서버에 전달
    1. API 서버는 etcd에 전달하고 내용을 모두 기록하면서 상태값을 최신으로 유지
    2. etcd는 API 서버에 업데이트 되었음을 알림
3. (M) API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지
    1. 컨트롤러 매니저는 파드를 생성하고 이 상태를 API 서버에 전달 (이때는 아직 어떤 워커 노드에 파드를 적용할지 결정되지 않은 상태로 파드만 생성)
4. (M) API 서버에 파드가 생성되었다는 정보를 스케줄러가 인지
    1. 스케줄러는 생성된 파드를 어떤 워커 노드에 적용할지 조건을 고려해 결정하고 해당 워커 노드에 파드를 띄우도록 요청
5. (M, W) API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 스케줄러가 kubelet으로 확인
6. (W) kubelet에서 컨테이너 런타임으로 파드 생성을 요청
7. (W) 파드 생성
8. 파드 사용가능 상태 구성

**선언적인 시스템 구조의 쿠버네티스**

쿠버네티스는 작업을 순서대로 진행하는 **워크플로 구조가 아닌,** **선언적인 시스템 구조** 를 가지고 있다.

즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조로 되어있다.

추구하는 상태를 API 서버에 선언하면 다른 요소들이 API 서버에 와서 현재 상태와 비교하고 그에 맞게 상태를 변경하려 한다. 여기서 API는 현재 상태 값을 가지고 있는데 이것을 보존해야 하기에 etcd가 필요한다.

그러나, 워커 노드는 워크플로 구조로 설계되었다. 쿠버네티스가 kubelet과 컨테이너 런타임을 통해 파드를 새로 생성하고 제거해야하는 구조이기 때문이다. (선언적 구조가 어려움)