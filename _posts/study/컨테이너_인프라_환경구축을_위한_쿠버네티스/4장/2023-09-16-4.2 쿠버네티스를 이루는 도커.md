---
title: 4.2 쿠버네티스를 이루는 도커

categories:
- 쿠버네티스/도커

tags:
- kubenetes
- docker

toc: true
toc_sticky: true
toc_label: Contents
---

> 도커 컨테이너 이미지도 그대로는 사용할 수 없고, 도커와 같은 CRI로 불러들여야 컨테이너가 실제로 작동한다.
>
> 따라서, 컨테이너를 삭제할 때는 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야만 디스크의 용량을 온전히 확보할 수 있다.

#### 4.2.1 컨테이너 이미지 알아보기

이미지는 레지스트리라고 하는 저장소에 모여있다.

> 레지스트리는 도커허브([https://hub.docker.com](https://hub.docker.com))처럼 공개된 유명 레지스트리일 수 있고, 내부에 구축된 레지스트리일 수도 있다.

`docker search {검색어}` 를 입력하면 특정한 이름을 포함하는 이미지가 있는지 찾는다.

![](https://i.imgur.com/vmrE17D.png)

* INDEX: 이미지가 저장된 레지스트리 이름.
* NAME: 검색된 이미지 이름.
    * 공식 이미지를 제외한 나머지는 레지스트리 주소/ 저장소 소유자/이미지 이름 으로 되어 있다.
* DESCRIPTION: 이미지에 대한 설명.
* STARS: 해당 이미지를 내려받은 사용자에게 받은 평가 횟수.
    * 숫자가 클수록 신뢰성높은 이미지일 수 있다.
* OFFICIAL: \[OK] 표시는 해당 이미지에 포함된 어플리케이션, 미들웨어 등을 개발한 업체에서 공식적으로 제공한 이미지라는 의미.
* AUTOMATED: \[OK] 표시는 도커 허브에서 자체적으로 제공하는 이미지 빌드 자동화 기능을 활용해 생성한 이미지를 의미.

`docker pull {이미지명}` 을 이용해 이미지를 내려받을 수 있다.

![](https://i.imgur.com/TEF9j96.png)

* 태그: Using default tag와 함께 뒤에 따라오는 태그 이름을 통해 이미지를 내려받을 때 사용한 태그를 알 수 있다.
    * 아무런 조건을 주지않고 이미지 이름만으로 pull을 수행하면 기본으로 latest 태그가 적용된다.
* 레이어: bb263680fed1, 258f176fd226, a0bc35e70773 등은 pull을 수행해 내려받은 레이어이다.
    * 하나의 이미지는 여러 개의 레이어로 이루어져 있어서 레이어마다 pull complete 메시지가 발생한다.
* 다이제스트: 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경을 식별할 수 있다.
    * 식별자는 해시함수로 생성되며 이미지가 동일한지 검증하는 데 사용한다.
    * 다이제스트는 고유한 값이므로 다이제스트가 같은 이미지는 이름이나 태그가 다르더라도 같은 이미지이다.
* 상태: 이미지는 내려받은 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있다.
    * 형식은 레지스트리 이름/이미지 이름:태그 이다.

**이미지 태그**

태그는 이름이 동일한 이미지에 추가하는 식별자이다. 이름이 동일해도 도커 이미지의 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하는데 사용한다.

**이미지의 레이어 구조**

이미지는 어플리케이션과 각종 파일을 담고 있다는 점에서 ZIP과 같은 압축 파일과 유사하다. 하지만, 이미지는 같은 내용일 경우여러 이미지를 동일한 레이어에 공유하므로 전체 용량은 감소한다.

**- nginx:latest 를 받은 이후, nginx:stable 을 내려받은 상태**

위의 그림에서 Already exists 메시지를 나타내는 레이어는 기존에 내려받은 이미지와 공유되는 레이어이기에 나타나는 것이다.

> `docker images {이미지명}` 명령을 치게되면 해당 이미지를 내려받은 이미지목록을 출력한다.
>
![](https://i.imgur.com/m09TXgK.png)
>
> `docker history {이미지명:태그}` 명령을 하게되면 해당 이미지가 어떤 과정을 거쳐 생성되었는지 확인할 수 있다.
>
![](https://i.imgur.com/W6vwk6T.png)

도커로 작성된 컨테이너는 레이어를 재사용하기 때문에 여러 이미지를 내려받더라도 디스크 용량을 효율적으로 사용할 수 있다.

**4.2.2 컨테이너 실행하기**

`docker run -d --restart always {이미지명}` 명령을 통해 새로운 컨테이너를 실행할 수 있다.

* \-d(--detach): 컨테이너를 백그라운드에서 구동한다는 의미.
    * 해당 옵션을 생략하면 컨테이너 내부에서 실행되는 어플리케이션의상태가 화면에 계속 표시된다.
*   \--restart always: 컨테이너의 재시작되 관련된 정책을 의미하는 옵션.

    * 옵션에 따라 컨테이너를 시작하는 방법이 다르다.

    | 값              | 컨테이너 비정상 종료시                | 도커 서비스 시작 시               |
        | -------------- | --------------------------- | ------------------------- |
    | no(기본값)        | 컨테이너를 재시작하지 않음              | 컨테이너를 시작하지 않음             |
    | on-failure     | 컨테이너를 재시작함 (exit code != 0) | 컨테이너를 시작함                 |
    | always         | 컨테이너를 재시작함 (always)         | 컨테이너를 시작함                 |
    | unless-stopped | 컨테이너를 재시작함                  | 사용자가 직접 정지하지 않은 컨테이너만 시작함 |

`docker ps` 명령으로 생성한 컨테이너 상태를 확인할 수 있다. (ps: process status 프로세스 상태)

![](https://i.imgur.com/KTKlvkK.png)

* CONTAINER ID: 컨테이너를 식별하기 위한 고유 ID.
    * ID에는 docker run을 실행한 결과가 일부 표시되는데, 이를 통해 이미지나 컨테이너를 식별할 수 있다.
* IMAGE: 컨테이너를 만드는 데 사용한 이미지.
* COMMAND: 컨테이너가 생성될 때 내부에서 작동할 프로그램을 실행한 명령.
* CREATED: 컨테이너가 생성된 시각을 표시.
* STATUS: 컨테이너가 작동을 시작한 시각을 표시.
    * CREATED와 달리, 커네티언를 중지했다가 다시 시작할 경우 초기화 된다.
* PORTS: 컨테이너가 사용하는 포트와 프로토콜을 표시.
* NAMES: 컨테이너 이름을 표시.
    * docker run에 --name 옵션을 주어 직접 지정할 수 있지만, 그렇지 않을 경우, 도커가 임의로 부여한 값을 나타난다.

> `docker ps -f {key}={value}` 명령을 이용해 컨테이너를 검색하는 필터링 옵션을 줄 수 있다.
>
> 필터링키는 여러가지가 존재할 수 있다. 아래는 자주 사용하는 필터링 키이다.
>
> * id: 컨테이너 아이디
> * name: 컨테이너 이름
> * label: 컨테이너 레이블
> * exited: 컨테이너가 종료되었을 때 반환하는 숫자 코드
> * status: 컨테이너의 작동 상태
> * ancestor: 컨테이너가 사용하는 이미지

![](https://i.imgur.com/OBuGzWu.png)

> 컨테이너는 **변경 불가능한 인프라** 를 지향한다. 변경 불가능한 인프라는 초기에 인프라를 구성하면 임의로 디렉터리 연결이나 포트 노출과 같은 설정을 변경 수 없다.
>
> 즉, 컨테이너 적용된 설정을 변경하려면 **새로운 컨테이너를 생성해야 한다.**

`docker run -p {요청받을 호스트 포트}:{연결할 컨테이너 포트}` 명령을 이용하여 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션을 줄 수 있다.

![](https://i.imgur.com/B8sAYWP.png)

* \[PORTS] 0.0.0.0:8080 -> 80/tcp: 0.0.0.0의 8080번 포트로 들어온 요청을 컨테이너 내부의 80번 포트로 전달한다는 의미.

#### 4.2.3 컨테이너 내부 파일 변경하기

도커는 컨테이너 내부에서 컨테이너 외부의 파일을 사용할수 있는 방법으로 크게 4가지를 제공한다.

* docker cp: `docker cp {호스트 경로} {컨테이너 이름}:{컨테이너 내부 경로}` 형식으로 호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사한다.
    * 컨테이너에 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해 사용한다.
    * 컨테이너에 저장돼있는 설정 및 로그를 추출해 확인하는 목적으로 사용한다.
* Dockerfile ADD: 이미지는 Dockerfile을 기반으로 만들어지는데, 이때 Dockerfile에 ADD라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드할 때 지정한 파일이 이미지내로 복사된다.
    * 이후, 해당 이미지를 기반으로 구동한 컨테이너에서는 복사한 파일을 사용할 수 있다.
    * 그러나, 사용자가 원하는 파일을 선택해 사용할 수 없다는 약점이 존재한다.
* 바인드 마운트: 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽 동시에 반영되는 방법이다.
    * 새로운 컨테이너를 구동할 때도 호스트와 연결할 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있다.
    * 데이터베이스의 데이터 디렉터리나 서버의 첨부 파일 디렉터리처럼 컨테이너가 바뀌어도 없어지면 안되는 자료는 이 방법으로 보존가능하다.
* 볼륨: 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결한다.
    * 여기서의 볼륨은 쿠버네티스에서의 볼륨과 유사하다.
    * 도커가 관리하는 볼륨 공간을 NFS와 같은 공유 디렉터리에 생성한다면 다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용할 수 있다.

| 구분       | docker cp | Dockerfile ADD   | 바인드 마운트      | 볼륨             |
| -------- | --------- | ---------------- | ------------ | -------------- |
| 컨테이너 적용  | 구동 중 복사   | 이미지 생성 시 복사      | 구동 시 디렉터리 연결 | 구동 시 도커의 볼륨 연결 |
| 파일 보관 위치 | 컨테이너 내부   | 컨테이너 내부          | 호스트(디렉터리)    | 호스트(도커 볼륨)     |
| 주 활용 용도  | 임시 파일     | 컨테이너 생성 시 필요한 파일 | 보존이 필요한 파일   | 보존이 필요한 파일     |
| 관리 편의성   | 좋지 못함     | 좋음               | 좋음           | 매우 좋음          |
| 파일 보존성   | 좋지 못함     | 좋음               | 매우 좋음        | 매우 좋음          |

> 웹 페이지를 연결하는 것처럼 오랫동안 고정된 내용을 각 사용자마다 다르게 취하는 경우에는 바인드 마운트 혹은 볼륨을 사용하는 것이 효과적인 방법이다.

**바인드 마운트**

docker를 구동시키면서 -v 옵션을 주어, 호스트 디렉토리와 컨테이너 디렉토리를 연결할 하는 방법이다.

```
docker -v {호스트 디렉토리}:{컨테이너 디렉토리 경로}
```

바인드 마운트는 호스트 디렉토리의 내용을 그대로 컨테이너 디렉토리에 덮어 씌운다. 그렇기에 컨테이너 디렉토리에 어떠한 내용이 있다 라더라도 해당 내용은 삭제된다.

**볼륨**

볼륨은 도커가 직접 관리하며 컨테이너에 제공하는 호스트의 공간이다.

`docker volume create {볼륨 명}` 명령을 통해 볼륨을 생성한다.

![](https://i.imgur.com/Z2TpdXv.png)

`docker volume inspect {볼륨 명}` 을 통해 생성된 볼륨을 조회한다. (드라이버 종류, 호스트에 연결된 디렉토리, 볼륨 이름 등을 조회할 수 있다.)

![](https://i.imgur.com/nEdGxnb.png)

`docker run -v {볼륨 이름}:{컨테이너 디렉토리}` 명령을 통해 해당 볼륨과 컨테이너를 연결한다.

여기서 볼륨은 기존 바인드 마운트 처럼 디렉토리를 덮어씌우는 구조가 아닌, **양쪽을 서로 동기화시키는** 구조로 되어 있어, 비어있는 볼륨을 연결하는 경우에는 컨테이너 디렉토리의 파일이 보존된다. 그러나, 볼륨에 컨테이너 디렉토리와 동일한 파일이 존재한 상태로 연결하면 덮어씌워지니 주의해야 한다.

> 사용중인 볼륨을 조회할 때에는 `docker volume ls` 명령을 사용하며, 볼륨을 삭제할 때에는 `docker volume rm {볼륨 명}` 명령을 이용하면 된다.
>
> 당연히, 해당 볼륨을 삭제할 때는 연결된 컨테이너가 없어야 한다.

#### 4.2.4 사용하지 않는 컨테이너 정리하기

사용하고 더 이상 사용하지 않는 컨테이너는 공간을 확보하기 위해 삭제하는 것이 좋다. 컨테이너나 이미지를 삭제하기 전에 먼저 컨테이너를 정지해야 한다.

`docker ps -f ancestor=nginx` 명령을 이용해 nginx 이미지를 사용하는 컨테이너를 조회하고,

`docker stop %{컨테이너 id}%` 를 통해 해당 컨테이너를 정지할 수 있다.

`docker stop $(docker ps -q -f ancestor=nginx)` 명령을 통해 nginx 이미지를 사용하는 모든 컨테이너의 ID를 출력하여 다수의 컨테이너를 정지할 수 있다.

> \-q(--quiet) 옵션은 조회된 모든 값 중 ID값만 출력하는 옵션이다.

`docker rm $(docker ps -aq -f ancestor=nginx)` 명령으로 nginx 이미지를 사용하는 모든 컨테이너의 ID를 뽑고, 다수의 컨테이너를 삭제한다.

> 일반적인 docker ps 옵션으로는 중지된 컨테이너가 출력되지 않으므로 -a(--all) 옵션을 더해 준다.

`docker rmi $(docker images -q nginx)` 명령으로 nginx 이미지로 구성된 다양한 태그의 이미지들를 뽑아 삭제한다.

> 이미지는 컨테이너가 정지 상태가 아닌 삭제 상태일 때 삭제할 수 있으므로, 미리 컨테이너를 삭제해두어야 이미지 삭제가 가능하다.